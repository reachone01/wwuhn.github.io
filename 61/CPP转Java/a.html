<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>

<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:75.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:100%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	margin-left:2em;
	color:blue;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
height:28px;
//white-space:nowrap;
//overflow:hidden; 
//text-overflow:ellipsis; 
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
padding-left:2px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
pre{
    margin-left:2em;
	}
a:visited, a:link{
    color:blue;
}
a:visited{
    color:#CC0000;
}a:hover{
    color:green;
	}
pre{
	font-size:120%;
	line-height:130%;
	padding:5px;
	margin-left:2em;
	background-color:RGB(240,240,240);
    color:blue;
	margin-left:2em;
	}
	ul{
	list-style-type:none;
	}
</style>
</head>

<body>

<div id="container">





<h4>CPP转Java快速入门</h4>


<p>       有C&#43;&#43;基础&#xff0c;Java零基础。想学Java。目前我采用的方法是&#xff1a;</p> 
<p><font color="#00dd00"><strong>先看一些Java入门视频</strong></font>&#xff08;B站、腾讯课堂到处都有&#xff09;快速了解Java这门语言&#xff0c;包括IDE怎么使用、基本输入输出、基本数据类型等&#xff0c;发现好些基础知识都差不多&#xff0c;毕竟都是面向对象的语言。</p><p>然后<font color="#00dd00"><strong>力扣做题</strong></font>&#xff0c;先用C&#43;&#43;写一遍&#xff0c;做题思路保持不变&#xff0c;将C&#43;&#43;里用到的API替换成Java的&#xff08;比如你这道题是用C&#43;&#43;的unordered_map写的&#xff0c;你用Java写的时候换成对应的HashMap写一遍&#xff0c;遇到不知道的就去百度一下&#xff09;&#xff0c;用Java多刷几道题就大概能记住那些类的使用方法了&#xff0c;这时候基本上就会用Java写代码了。</p><p>会用Java写代码算是刚刚入门了&#xff0c;如果想要代码写得好&#xff0c;必须要掌握语言的特性&#xff0c;包括Java各种类的底层原理什么的&#xff0c;这些可以<font color="#00dd00"><strong>买本书看</strong></font>。推荐书籍《Java核心技术》。</p><p>要想深入学习Java&#xff0c;看书肯定不够啊&#xff0c;去GitHub上找点项目做&#xff0c;然后在工作中实践等等</p></ul> 
<p>       </p> 
<p>        由于博主初学Java&#xff0c;下面的内容如有错误的地方&#xff0c;还望各位Java大佬指出来。</p> 
<p>       </p> 
<h2><a id="font_color00dddd1IDEfont_15"></a><font color="#00dddd"><strong>1、IDE选择</strong></font></h2> 
<ul><li>免费&#xff1a;Eclipse、IntelliJ Idea社区版</li><li>收费&#xff1a;IntelliJ Idea旗舰版</li><li>附上<a href="https://www.jetbrains.com/idea/download/#section&#61;windows">IntelliJ Idea官网下载链接</a></li></ul> 
<p>       </p> 
<h2><a id="font_color00dddd2JVMJREJDKfont_23"></a><font color="#00dddd"><strong>2、JVM、JRE与JDK</strong></font></h2> 
<ul><li><font color="#dd00dd"><strong>JVM</strong></font>&#xff08;Java Virtual Machine&#xff09;&#xff0c;Java虚拟机&#xff0c;JVM 是 Java 能够跨平台的核心。</li><li><font color="#dd00dd"><strong>JRE</strong></font>&#xff08;Java Runtime Envirnment&#xff09;&#xff0c;Java运行环境&#xff0c;JRE相对于 JVM&#xff0c;多了 Java 基础类库&#xff0c;你写好的Java程序需要有JRE才能运行。</li><li><font color="#dd00dd"><strong>JDK</strong></font>&#xff08;Java Development Kit) &#xff0c;Java 开发工具包&#xff0c;包含了Java运行环境&#xff08;JRE&#xff09;、Java工具和Java基础的类库。你写的Java程序如果要调试&#xff0c;需要有JDK&#xff0c;由于JDK包含了JRE&#xff0c;JRE包含了JVM&#xff0c;因此你的IDE只要装了JDK就不需要额外装JRE和JVM了。<br /> <img src="1.png" width="50%" /></li></ul> 
<p>       </p> 
<h2><a id="font_color00dddd3JavaCfont_32"></a><font color="#00dddd"><strong>3、Java和C&#43;&#43;相同的一些基础知识</strong></font></h2> 
<ul><li> <p><font color="#dd00dd"><strong>基本数据类型</strong></font>&#xff1a;char、int、long、double……<br /> 布尔类型不同&#xff08;Java boolean&#xff0c;C&#43;&#43; bool&#xff09;</p> </li><li> <p><font color="#dd00dd"><strong>运算符</strong></font>&#xff1a;&#43;、-、*、\、%、&#43;&#43;、–、&#61;、&amp;&amp;、||、&#xff01;、&lt;、&gt;、&#61;&#61;……</p> </li><li> <p><font color="#dd00dd"><strong>判断语句</strong></font>&#xff1a;if、switch</p> </li><li> <p><font color="#dd00dd"><strong>循环语句</strong></font>&#xff1a;普通for语句、while语句、do-while语句</p> </li><li> <p>continue、break、 关系表达式&#xff1f;表达式1&#xff1a;表达式2 用法相同。</p> </li><li> <p><font color="#dd00dd"><strong>类</strong></font>同样有封装、继承、多态等概念&#xff1b;有private、pubic、this、static 等关键字&#xff1b;有构造函数&#xff0c;用法类似。</p> </li><li> <p><font color="#dd00dd"><strong>方法&#xff08;函数&#xff09;</strong></font>同样有定义、调用、重载等概念。</p> </li></ul> 
<p>       </p> 
<h2><a id="font_color00dddd4font_50"></a><font color="#00dddd"><strong>4、内存模型</strong></font></h2> 
<table><thead>
<tr><th>java</th><th>C&#43;&#43;</th></tr></thead><tbody>
<tr>
<td><img src="2.png" width="100%" /></td>
<td><img src="3.png" width="100%" /></td></tr></tbody></table>
<p>       </p> 
<p>       </p> 
<p>       </p> 
<h2><a id="font_color00dddd5font_65"></a><font color="#00dddd"><strong>5、数组</strong></font></h2> 
<p><img src="4.png" /></p> 
<p>       </p> 
<p>       </p> 
<p>       </p> 
<h2><a id="font_color00dddd6font_76"></a><font color="#00dddd"><strong>6、类的定义与使用</strong></font></h2> 
<p><img src="5.png" /></p> 
<p><strong>类的内存模型</strong></p> 
<p>        仍以前面的代码为例&#xff0c;学生类Student实例化了一个对象stu1。</p> 
<p><font color="#dd00dd"><strong>Java</strong></font></p>

<p>在main()方法中使用类Student&#xff0c;先实例化一个对象stu1&#xff0c;对象stu1占用堆内存&#xff0c;stu1的内存中又存放着类Student的各个方法的地址。</p>
<p><img src="6.png" width="100%" /></p> 
<p><font color="#dd00dd"><strong>C&#43;&#43;</strong></font><p>

<p><img src="7.png" width="100%" /></p>  

<p>若类有虚函数的情况&#xff0c;请看<a href="https://blog.csdn.net/weixin_43222324/article/details/109767675">图解C&#43;&#43;多态&#xff0c;虚函数、虚函数表、虚指针、重写与覆盖<br /> </a></p> 
<p>       </p> 
<p>       </p> 
<p>       </p> 
<h2><a id="API_105"></a>接下来是常用API的对比</h2> 
<p>       </p> 
<p>       </p> 
<p>       </p> 
<h2><a id="font_color00dddd1__font_112"></a><font color="#00dddd"><strong>1、输入 --------------------------------------</strong></font></h2> 
<p><font color="#dd00dd"><strong>Java------Scanner</strong></font></p> 


<pre><code class="prism language-java"><span class="token comment">// 导包</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span><span class="token punctuation">;</span>
<span class="token comment">// System.in 代表从键盘进行输入</span>
<span class="token class-name">Scanner</span> sc <span class="token operator">&#61;</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取键盘上输入的int型数据</span>
<span class="token keyword">int</span> number <span class="token operator">&#61;</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出看看</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取键盘上输入的字符串</span>
<span class="token class-name">String</span> str<span class="token operator">&#61;</span>sc<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出看看</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>       <br /> <font color="#dd00dd"><strong>C&#43;&#43; ------cin</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 包含头文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token comment">// 输入int型数据</span>
<span class="token keyword">int</span> number<span class="token punctuation">;</span>
cin <span class="token operator">&gt;&gt;</span> number<span class="token punctuation">;</span>
<span class="token comment">// 输入string型数据</span>
string str<span class="token punctuation">;</span>
cin <span class="token operator">&gt;&gt;</span> str<span class="token punctuation">;</span>
<span class="token comment">// 输出看看</span>
cout <span class="token operator">&lt;&lt;</span> number <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> 
<p>       </p> 
<p>       </p> 
<h2><a id="font_color00dddd2__font_154"></a><font color="#00dddd"><strong>2、随机数 --------------------------------------------------------------</strong></font></h2> 
<p><font color="#dd00dd"><strong>Java------Random</strong></font></p> 
<pre><code class="prism language-java"><span class="token comment">// 导包</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span><span class="token punctuation">;</span>
<span class="token comment">// 使用</span>
<span class="token class-name">Random</span> ran<span class="token operator">&#61;</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出范围为INT_MIN~INT_MAX的10个随机数</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">&#61;</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">&#43;&#43;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ran<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出范围为[0,n)的10个随机数</span>
<span class="token keyword">int</span> n<span class="token operator">&#61;</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">&#61;</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">&#43;&#43;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ran<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>       <br /> <font color="#dd00dd"><strong>C&#43;&#43; ------rand</strong></font></p> 
<pre><code class="prism language-cpp"><span class="token comment">// 包含头文件</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token comment">// 使用</span>
<span class="token comment">// 设置种子&#xff0c;如果不设置&#xff0c;种子默认为1</span>
<span class="token function">srand</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出100个伪随机数</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">&#61;</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">&#43;&#43;</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&#34; &#34;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>       </p> 
<p>       </p> 
<h2><a id="font_color00dddd3__font_193"></a><font color="#00dddd"><strong>3、动态数组 ----------------------------------------------------------</strong></font></h2> 
<p><font color="#dd00dd"><strong>Java------ArrayList</strong></font><br />        </p> 
<table id="tbrowser"><thead><tr><th align="left">ArrayList&lt;E&gt;   list &#61; new ArrayList();</th><th align="left">创建一个名为list的空数组链表&#xff0c;存放E类型的对象</th></tr></thead><tbody><tr><td align="left"><strong>ArrayList&lt;E&gt;   list &#61; new ArrayList(n);</strong></td><td align="left">创建一个数组链表list&#xff0c;存放E类型的对象&#xff0c;初始容量大小为n</td></tr><tr><td align="left"><strong>list.get(index);</strong></td><td align="left"><strong>访问</strong>下标为index的元素</td></tr><tr><td align="left"><strong>Object[] c&#61;list.toArray();</strong></td><td align="left">获取一个数组c&#xff0c;c中所有元素是数组链表中的元素&#xff0c;即将数组链表转换为一个数组</td></tr><tr><td align="left"><strong>list.set(index,element);</strong></td><td align="left">将下标为index的元素<strong>修改</strong>为element</td></tr><tr><td align="left"><strong>list.add(element);</strong></td><td align="left">在list的尾部<strong>添加</strong>元素element</td></tr><tr><td align="left"><strong>list.add(index,element);</strong></td><td align="left">在list的下标为index的位置<strong>添加</strong>元素element</td></tr><tr><td align="left"><strong>list.remove(index);</strong></td><td align="left"><strong>删除</strong>下标为index的元素</td></tr><tr><td align="left"><strong>list.clear();</strong></td><td align="left"><strong>删除</strong>所有元素</td></tr><tr><td align="left"><strong>list.size();</strong></td><td align="left">返回值为数组链表的<strong>大小</strong></td></tr><tr><td align="left"><strong>list.isEmpty();</strong></td><td align="left">数组链表为<strong>空</strong>则返回true&#xff0c;否则返回false</td></tr><tr><td align="left"><strong>list.contains(element);</strong></td><td align="left">数组链表中<strong>包含元素</strong>element则返回true&#xff0c;否则返回false</td></tr><tr><td align="left"><strong>list.indexOf(element);</strong></td><td align="left">返回元素element在数组链表中<strong>第一次出现的位置</strong>&#xff0c;如果链表中没有这个元素则返回-1</td></tr><tr><td align="left"><strong>list.lastIndexOf(element);</strong></td><td align="left">返回元素element在数组链表中<strong>最后一次出现的位置</strong>&#xff0c;如果链表中没有这个元素则返回-1</td></tr></tbody></table>
<p>       </p> 
<p>        上表中&lt;&gt;尖括号内E代表泛型&#xff0c;泛型只能是引用类型比如String&#xff0c;不能是基本类型比如int&#xff0c;如果希望用ArrayList存储基本类型的数据&#xff0c;必须使用基本类型对应的引用类型&#xff0c;对应关系见下表。</p> 
<table id="tbrowser"><thead><tr><th>基本类型</th><th>引用类型</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolea</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table>
<p>       <br /> <font color="#dd00dd"><strong>C&#43;&#43; ------vector</strong></font></p> 
<p><a href="https://blog.csdn.net/weixin_43222324/article/details/111180922">【C&#43;&#43;】STL顺序容器之vector用法总结</a></p> 
<p>       </p> 
<p>       </p> 
<h2><a id="font_color00dddd4_font_237"></a><font color="#00dddd"><strong>4、字符串 ----------------------------------------------------------</strong></font></h2> 
<p><font color="#dd00dd"><strong>Java------String</strong></font></p> 
<table id="tbrowser"><thead><tr><th align="left">初始化</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong>String s1 &#61; new String(“hello world&#xff01;”);</strong></td><td align="left">创建一个字符串对象&#xff0c;内容为&#34;hello world&#xff01;&#34;</td></tr><tr><td align="left"><strong>String s1 &#61; “hello world&#xff01;”;</strong></td><td align="left">创建一个字符串对象&#xff0c;内容为&#34;hello world&#xff01;&#34;</td></tr><tr><td align="left"><strong>String s1 &#61; new String();</strong></td><td align="left">创建一个空字符串对象</td></tr><tr><td align="left"><strong>char c1[] &#61; {‘h’,‘e’,‘l’,‘l’,‘o’}; String s1 &#61; new String(c1);</strong></td><td align="left">创建一个字符串对象&#xff0c;内容为&#34;hello&#34;</td></tr><tr><td align="left"><strong>byte b1[]&#61;{104,101}; String s1 &#61; new String(b1);</strong></td><td align="left">创建一个字符串对象&#xff0c;内容为&#34;he&#34;</td></tr></tbody></table> 
<table id="tbrowser"><thead><tr><th align="left">查找</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong>s1.contains(String s2);</strong></td><td align="left">s1中<strong>包含</strong>s2则返回true&#xff0c;否则返回false</td></tr><tr><td align="left"><strong>s1.charAt(int index);</strong></td><td align="left">返回下标为index的字符</td></tr><tr><td align="left"><strong>s1.indexOf(char element);</strong></td><td align="left">返回字符element在s1中<strong>第一次</strong>出现的位置&#xff0c;如果s1中没有则返回-1</td></tr><tr><td align="left"><strong>s1.indexOf(char element,int index);</strong></td><td align="left">返回字符element <strong>从s1的index位置开始&#xff0c;第一次</strong>出现的位置&#xff0c;如果没有则返回-1</td></tr><tr><td align="left"><strong>s1.indexOf(String s2);</strong></td><td align="left">返回字符串s2在s1中<strong>第一次</strong>出现的位置&#xff0c;如果s1中没有s2则返回-1</td></tr><tr><td align="left"><strong>s1.indexOf(String s2,int index);</strong></td><td align="left">返回字符串s2 <strong>从s1的index位置开始&#xff0c;第一次</strong>出现的位置&#xff0c;如果没有则返回-1</td></tr><tr><td align="left"><strong>s1.lastIndexOf(char element);</strong></td><td align="left">返回字符element在s1中<strong>最后一次</strong>出现的位置&#xff0c;如果s1中没有则返回-1</td></tr><tr><td align="left"><strong>s1.lastIndexOf(char element,int index);</strong></td><td align="left">返回字符element <strong>从s1的index位置开始&#xff0c;最后一次</strong>出现的位置&#xff0c;如果没有则返回-1</td></tr><tr><td align="left"><strong>s1.lastIndexOf(String s2);</strong></td><td align="left">返回字符串s2在s1中<strong>最后一次</strong>出现的位置&#xff0c;如果s1中没有则返回-1</td></tr><tr><td align="left"><strong>s1.lastIndexOf(String s2,int index);</strong></td><td align="left">返回字符串s2 <strong>从s1的index位置开始&#xff0c;最后一次</strong>出现的位置&#xff0c;如果没有则返回-1</td></tr></tbody></table> 
<table id="tbrowser"><thead><tr><th align="left">比较</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong>s1.equals(s2);</strong></td><td align="left">s1与s2<strong>相等</strong>则返回true&#xff0c;否则返回false</td></tr><tr><td align="left"><strong>s1.equalsIgnoreCase(s2);</strong></td><td align="left"><strong>忽略大小写</strong>的情况下&#xff0c;s1与s2<strong>相等</strong>则返回true&#xff0c;否则返回false</td></tr><tr><td align="left"><strong>s1.compareTo(s2);</strong></td><td align="left">比较s1与s2的大小&#xff0c;s1&gt;s2返回正数&#xff0c;s1&#61;s2返回0&#xff0c;否则返回负数</td></tr><tr><td align="left"><strong>s1.compareToIgnoreCase(s2);</strong></td><td align="left"><strong>忽略大小写</strong>的情况下&#xff0c;比较s1与s2的大小&#xff0c;s1&gt;s2返回正数&#xff0c;s1&#61;s2返回0&#xff0c;否则返回负数</td></tr></tbody></table> 
<table id="tbrowser"><thead><tr><th align="left">替换</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong>String result&#61;s1.replace(oldChar,newChar);</strong></td><td align="left">将s1中的字符oldChar<strong>替换</strong>为字符newChar,结果保存在result中</td></tr><tr><td align="left"><strong>String result&#61;s1.replace(target,replacement);</strong></td><td align="left">将s1中的字符串target<strong>替换</strong>为字符串replacement&#xff0c;结果保存在result中</td></tr><tr><td align="left"><strong>String result&#61;s1.replaceAll(target,replacement);</strong></td><td align="left">将s1中的target<strong>全部替换</strong>为replacement&#xff0c;结果保存在result中&#xff0c;target和replacement都是正则表达式</td></tr><tr><td align="left"><strong>String result&#61;s1.replaceFirst(target,replacement);</strong></td><td align="left">将s1中的<strong>第一个</strong>target<strong>替换</strong>为replacement&#xff0c;结果保存在result中&#xff0c;target和replacement都是正则表达式</td></tr></tbody></table> 
<table id="tbrowser"><thead><tr><th align="left">其他</th><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong>s1.length();</strong></td><td align="left">返回值为字符串的<strong>长度</strong></td></tr><tr><td align="left"><strong>s1.isEmpty();</strong></td><td align="left">字符串为<strong>空</strong>则返回true&#xff0c;否则返回false</td></tr><tr><td align="left"><strong>String result&#61;s1.substring(index);</strong></td><td align="left">得到s1从下标index开始的<strong>子串</strong>&#xff0c;结果保存在result中</td></tr><tr><td align="left"><strong>String result&#61;s1.substring(index1,inex2);</strong></td><td align="left">得到s1从下标index1开始到下标index2结束的<strong>子串</strong>&#xff08;左闭右开&#xff09;&#xff0c;结果保存在result中</td></tr><tr><td align="left"><strong>String result&#61;s1.toLowerCase();</strong></td><td align="left">将s1中的大写字符<strong>变换成</strong>对应的<strong>小写字母</strong>&#xff0c;结果保存在result中</td></tr><tr><td align="left"><strong>String result&#61;s1.toUpperCase();</strong></td><td align="left">将s1中的小写字符<strong>变换成</strong>对应的<strong>大写字母</strong>&#xff0c;结果保存在result中</td></tr><tr><td align="left"><strong>String result&#61;s1.concat(s2);</strong></td><td align="left">将s1和s2<strong>拼接</strong>后的结果保存在result中&#xff0c;注意&#xff0c;s1、s2的值不会改变</td></tr><tr><td align="left"><strong>String result[]&#61;s1.split(regex);</strong></td><td align="left">根据正则表达式regex将s1<strong>拆分</strong>开&#xff0c;结果保存在result[]字符串数组中</td></tr></tbody></table>
<p>       <br /> <font color="#dd00dd"><strong>C&#43;&#43; ------string</strong></font></p> 
<p><a href="https://blog.csdn.net/weixin_43222324/article/details/111245854">【C&#43;&#43;】STL顺序容器之string用法总结</a></p> 
<p>       </p> 
<p>       </p> 
<h2><a id="font_color00dddd5_font_298"></a><font color="#00dddd"><strong>5、操作数组的工具类 ----------------------------------------------</strong></font></h2> 
<p><font color="#dd00dd"><strong>Java------Arrays</strong></font></p> 


<table id="tbrowser"><thead>
<tr></tr>

<tr><td align="left">int[] a&#61;new int[]{8,1,2,3,7,5,4,6,7,0};</td><td align="left">以数组名为a进行举例</td></tr></thead><tbody><tr><td align="left"><strong>System.out.println(Arrays.toString(a));</strong></td><td align="left"><strong>打印</strong>数组</td></tr><tr><td align="left"><strong>Arrays.sort(a);</strong></td><td align="left">对整个数组<strong>排序</strong></td></tr><tr><td align="left"><strong>Arrays.sort(a,index1,index2);</strong></td><td align="left">对下标i范围为ndex1~index2&#xff08;左闭右开&#xff09;的元素进行<strong>排序</strong></td></tr><tr><td align="left"><strong>int result&#61;Arrays.binarySearch(a,target);</strong></td><td align="left"><strong>二分查找</strong>元素target&#xff0c;若找到则返回target的索引&#xff0c;否则返回负数</td></tr><tr><td align="left"><strong>Arrays.fill(a,value);</strong></td><td align="left">将数组元素全部<strong>填充</strong>为value</td></tr><tr><td align="left"><strong>Arrays.fill(a,index1,index2,value);</strong></td><td align="left">将下标从index1开始到index2的元素&#xff08;左闭右开&#xff09;&#xff0c;<strong>填充</strong>为value</td></tr><tr><td align="left"><strong>int[] b&#61;Arrays.copyOf(a,length);</strong></td><td align="left">将数组a的前length个元素<strong>拷贝</strong>给数组b</td></tr><tr><td align="left"><strong>int[] c&#61;Arrays.copyOfRange(a,index1,index2);</strong></td><td align="left">将数组a的下标从index1开始到index2的元素<strong>拷贝</strong>给数组b</td></tr></tbody></table>
<p>       <br /> 程序示例</p> 
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
int[] a=new int[]{8,1,2,3,7,5,4,6,7,0};
<font color=#CCC>// 打印</font>
System.out.println(Arrays.toString(a));  <font color=#CCC>// toString(a)打印数组</font>
<font color=#CCC>// 排序</font>
Arrays.sort(a,0,5);                      <font color=#CCC>// 只对下标0~5（左闭右开）的元素进行排序</font>
Arrays.sort(a);                          <font color=#CCC>// 对整个数组排序</font>
<font color=#CCC>// 二分查找</font>
<font color=#00F>int</font> r1=Arrays.binarySearch(a,7);         <font color=#CCC>// 得到查找的结果的索引，未找到则返回负数</font>
System.out.println(r1);
<font color=#CCC>// 填充</font>
Arrays.fill(a,1);                        <font color=#CCC>// 将数组元素全部替换成1</font>
Arrays.fill(a,0,5,0);                    <font color=#CCC>// 将下标从0开始到5的元素（左闭右开），填充为0</font>
System.out.println(Arrays.toString(a));  <font color=#CCC>// toString(a)打印数组</font>
<font color=#CCC>// 复制数组</font>
<font color=#00F>int</font>[] b=Arrays.copyOf(a,5);              <font color=#CCC>// 复制数组的前5个元素</font>
<font color=#00F>int</font>[] c=Arrays.copyOfRange(a,3,7);       <font color=#CCC>// 复制下标从3到7的元素</font>
</pre>
<h2><a id="font_color00dddd6Math_font_337"></a><font color="#00dddd"><strong>6、Math类 ----------------------------------------------</strong></font></h2> 
<p>       <br /> 程序示例</p> 
<pre><code class="prism language-java"><span class="token keyword">double</span> a <span class="token operator">&#61;</span> <span class="token number">1.2038456</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> b <span class="token operator">&#61;</span> <span class="token number">1.2038456</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> result1 <span class="token operator">&#61;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 向下取整</span>
<span class="token keyword">double</span> result2 <span class="token operator">&#61;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 向上取整</span>
<span class="token keyword">double</span> result3 <span class="token operator">&#61;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 四舍五入</span>
<span class="token keyword">double</span> result4 <span class="token operator">&#61;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 最大值</span>
<span class="token keyword">double</span> result5 <span class="token operator">&#61;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 最小值</span>
<span class="token keyword">double</span> result6 <span class="token operator">&#61;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 绝对值</span>
<span class="token keyword">double</span> result7 <span class="token operator">&#61;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 幂函数</span>
<span class="token keyword">double</span> result8 <span class="token operator">&#61;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 平方根</span>
</code></pre>
              
				<a href="https://download.csdn.net/download/qq_38716951/10313167">
<em>C++</em>代码<em>转</em><em>java</em>工具
				</a>

			<a href="https://download.csdn.net/download/qq_38716951/10313167"><em>C++</em>代码<em>转</em><em>java</em>工具
<em>C++</em>代码<em>转</em><em>java</em>工具
<em>C++</em>代码<em>转</em><em>java</em>工具
			</a>


				<a href="https://download.csdn.net/download/youyouai2008/9380540"><em>C++</em><em>转</em><em>Java</em>工具
				</a>
	
<p>			<a href="https://download.csdn.net/download/youyouai2008/9380540">
<em>C++</em><em>转</em><em>Java</em>工具，对于研究jni开发很有帮助。</a></p>

<p>C++到Java的转换工具是我们自己公司试用的破解版非试用版, 注意这个工具在 csdn 有个下载需要分数很高的那个而且文件大小不到1M, 那个是试用版, 有1000行代码限制。</p>

		<h2>2</h2>
<p>博主原本的语言是c&#43;&#43;&#xff0c;好不容易上手了&#xff0c;刷算法题也熟练了一些&#xff0c;因为实习的缘故不得不开始接触java。下面总结一些c&#43;&#43;和java的区别&#xff0c;有c&#43;&#43;基础的人可以对照学习java。</p> 
<h3><a id="_1"></a>一、从变量和数据类型上</h3> 
<p>1、数据类型<br /> Java语言提供了八种基本类型&#xff0c;Java没有无符号整数。&#xff08;无符号右移在Java中强制用三个右尖括号表示&#xff09;</p> 
<ul><li>六种数字类型&#xff08;byte,short,int,long,float,duble&#xff09;</li><li>一种字符类型 (char)</li><li>一种布尔型 (boolean)</li></ul> 
<p>java和c&#43;&#43;都支持布尔类型的数据&#xff0c;但是java实现true和false的方式与c&#43;&#43;不同。在c&#43;&#43;中&#xff0c;true是非零值&#xff0c;false是0.而java中&#xff0c;true和false是一个布尔表达式能得到的唯一的两个值&#xff0c;不会出现像c&#43;&#43;一样把非0转为true的情况。</p> 
<p>2、字符串</p> 
<p>Java有内置类型String&#xff0c;而C&#43;&#43;没有。C&#43;&#43;的std::string是可变的&#xff0c;类似于Java的StringBuffer。&#xff08;<a href="https://blog.csdn.net/fannyoona/article/details/106995151">String&#xff0c;StringBuffer&#xff0c;StringBuilder三者异同</a>&#xff09;。java中的String一旦定义了就是个常量&#xff0c;不能被修改。</p><p>比较字符串时&#xff0c;c&#43;&#43;由于重写了“&#61; &#61;” 因此可用于比较&#xff0c;而java中不能用“&#61;&#61;”&#xff0c;要用string的方法<code>.equals()</code></p>
<p>3、数组</p> 
<p>&#xff08;1&#xff09;java定义数组的方式&#xff1a;</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array1<span class="token operator">&#61;</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//常用方式</span>
<span class="token keyword">int</span> array2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//数组维度无需确定</span>
</code></pre> 
<p>相比较&#xff0c;c&#43;&#43;的声明方式为&#xff1a;</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>array1<span class="token operator">&#61;</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> array2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//数组维度必须是确定的</span>
</code></pre> 
<p>&#xff08;2&#xff09;java可以进行数组拷贝&#xff0c;c&#43;&#43;则是用指针或引用的形式实现这样的目的。java可以用如下方式&#xff1a;</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oddNum<span class="token operator">&#61;</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy<span class="token operator">&#61;</span>Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>oddNum<span class="token punctuation">,</span>oddNum<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>4、C&#43;&#43;的整型随机器的位数而变化&#xff0c;但是Java不会。&#xff08;C&#43;&#43;的int在16位机器上16位&#xff0c;32位级以上为32位。long在32位及以下为32位&#xff0c;64位机器上为64位。&#xff09;</p> 
<p>5、Java中不存在指针和引用&#xff08;这点真的很不习惯。。比如写两个数交换的字方法时&#xff0c;c&#43;&#43;可以愉快的用引用传参&#xff09;。Java的引用是功能弱化的指针&#xff0c;只能做“调用所指对象的方法”的操作。</p> 
<p>6、java具有方法重载的能力&#xff0c;但不支持操作符重载</p> 
<p>7、java新增了三个右移位运算符&#34;&gt;&gt;&gt;&#34;&#xff0c;具有与“逻辑”右移位运算符类似的功能&#xff0c;可在最末尾插入0值。“&gt;&gt;&#34;则在移位的同时插入符号位。</p> 
<p>8、类型转换<br /> c&#43;&#43;中有时出现数据类型的隐含转换&#xff0c;这就涉及强制类型转换的问题。比如&#xff0c;c&#43;&#43;中可以将一个浮点数赋予整型变量&#xff0c;去掉小数部分。java不支持c&#43;&#43;中的自动强制类型转换&#xff0c;如果需要转换&#xff0c;必须由程序员进行显式的转换。如&#xff1a;</p> 
<h3><a id="_45"></a>二、循环语句</h3> 
<p>写循环语句时&#xff0c;c&#43;&#43;中可以直接用<code>while(1), while(a),if(num)</code>这种方式来做循环进行或终止的条件&#xff0c;而java中&#xff0c;括号里的表达式只能是布尔类型&#xff0c;如<code>while(a!&#61;10), while(b&gt;1)</code>这种写法。</p><p>java中没有goto语句</p>
<h3><a id="_50"></a>三、类机制</h3> 
<p>和c&#43;&#43;相比&#xff0c;java所有东西必须置入一个类&#xff0c;即使是main函数pubpc static void man&#xff08;String[ ] args&#xff09;也要放在类里面。java是完全面向对象的语言&#xff0c;不再支持c&#43;&#43;所用的过程式的设计方法&#xff0c;所有的函数和变量必须是类的一部分。除了基本数据类型之外&#xff0c;其他的数据对java来说都是对象&#xff0c;包括数组。</p><p>我们新建一个java文件时&#xff0c;这个文件名必须要与文件中定义的类名相同。一个java文件中必须要有至少一个pubpc的类。</p><p>java不存在全局函数或者全局数据&#xff0c;如果想获得全局的功能&#xff0c;可以将static方法和static数据置入一个类里面。而c&#43;&#43;允许将函数和变量定义为全局的。此外&#xff0c;java中取消了c&#43;&#43;结构中的联合&#xff0c;枚举这类东西&#xff0c;一切只有“类”&#xff08;class&#xff09;。</p><p>与c&#43;&#43;相比&#xff0c;java中不存在inpne函数&#xff0c;没有virtual关键字&#xff0c;不提供多重继承机制。java支持构造函数&#xff0c;但是没有c&#43;&#43;中的析构函数&#xff08;java中增加了finapze&#xff08;&#xff09;函数&#xff09;。</p><p>Java中的继承具有与C&#43;&#43;相同的效果&#xff0c;但采用的语法不同。Java用extends关键字标志从一个基础类的继承&#xff0c;并用super关键字指出准备在基础类中调用的方法&#xff0c;它与我们当前所在的方法具有相同的名字&#xff08;然而&#xff0c;Java中的super关键字只允许我们访问父类的方法——亦即分级结构的上一级</p>
<h3><a id="package_59"></a>四、包&#xff08;package&#xff09;</h3> 
<p>更好地组织类&#xff0c;Java 提供了包机制&#xff0c;用于区别类名的命名空间。 Java用包代替了命名空间。由于将所有东西都置入一个类&#xff0c;而且由于采用了一种名为“封装”的机制&#xff0c;它能针对类名进行类似于命名空间分解的操作&#xff0c;所以命名的问题不再进入我们的考虑之列。数据包也会在单独一个库名下收集库的组件。我们只需简单地“import”&#xff08;导入&#xff09;一个包&#xff0c;剩下的工作会由编译器自动完成。包的作用为&#xff1a;</p> 
<p>把功能相似或相关的类或接口组织在同一个包中&#xff0c;方便类的查找和使用。</p><p>如同文件夹一样&#xff0c;包也采用了树形目录的存储方式。同一个包中的类名字是不同的&#xff0c;不同的包中的类的名字是可以相同的&#xff0c;当同时调用两个不同包中相同类名的类时&#xff0c;应该加上包名加以区别。因此&#xff0c;包可以避免名字冲突。</p><p>包也限定了访问权限&#xff0c;拥有包访问权限的类才能访问某个包中的类。</p>
<p>Java 使用包&#xff08;package&#xff09;这种机制是为了防止命名冲突&#xff0c;访问控制&#xff0c;提供搜索和定位类&#xff08;class&#xff09;、接口、枚举&#xff08;enumerations&#xff09;和注释&#xff08;annotation&#xff09;等。</p> 
<p>包语句的语法格式为&#xff1a;</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> pkg1<span class="token punctuation">[</span>&#xff0e;pkg2<span class="token punctuation">[</span>&#xff0e;pkg3…<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>例如,一个Something.java 文件它的内容</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> net<span class="token punctuation">.</span>java<span class="token punctuation">.</span>util<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Something</span><span class="token punctuation">{<!-- --></span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么它的路径应该是 net/java/util/Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存&#xff0c;更方便的被其他 java 程序调用。</p> 
<h3><a id="_82"></a>五、预处理</h3> 
<p>java不再有#define&#xff0c;#include等预处理程序的功能&#xff0c;而c&#43;&#43;语言很重要的一个特点就是它的预处理程序。#define的功能在java中我们可以用定义常数的方式来取代&#xff0c;而#include在java中是不需要的。</p> 
<h3><a id="_85"></a>六、自动内存管理</h3> 
<p>Java程序中所有的对象都是用new操作符建立在内存堆栈上&#xff0c;这个操作符类似于c&#43;&#43;的new操作符。Java自动进行无用内存回收操作&#xff0c;不需要程序员进行删除。而c&#43;&#43;中必须由程序员释放内存资源&#xff0c;增加了程序设计者的负担。Java中当一个对象不被再用到时&#xff0c;无用内存回收器将给它加上标签以示删除。Java里无用内存回收程序是以线程方式在后台运行的&#xff0c;利用空闲时间工作。</p> 
<h3><a id="java_88"></a>七、java接口</h3> 
<p>接口并不是类&#xff0c;编写接口的方式和类很相似&#xff0c;但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p> 
<p>除非实现接口的类是抽象类&#xff0c;否则该类要定义接口中的所有方法。</p> 
<p>接口无法被实例化&#xff0c;但是可以被实现。一个实现接口的类&#xff0c;必须实现接口内所描述的所有方法&#xff0c;否则就必须声明为抽象类。另外&#xff0c;在 Java 中&#xff0c;接口类型可用来声明一个变量&#xff0c;他们可以成为一个空指针&#xff0c;或是被绑定在一个以此接口实现的对象。</p> 
<blockquote> 
 <p>接口与类相似点&#xff1a;</p> 
 <ul><li>一个接口可以有多个方法</li><li>接口文件保存在 .java 结尾的文件中&#xff0c;文件名使用接口名</li><li>接口的字节码文件保存在 .class 结尾的文件中</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中</li></ul> 
</blockquote> 
<blockquote> 
 <p>接口与类的区别&#xff1a;</p> 
 <ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量&#xff0c;除了 static 和 final 变量。</li><li>接口不是被类继承了&#xff0c;而是要被类实现。</li><li>接口支持多继承。</li></ul> 
</blockquote> 
<blockquote> 
 <p>接口特性:</p>

<p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract&#xff08;只能是 public abstract&#xff0c;其他修饰符都会报错&#xff09;。</p>

<p>接口中可以含有变量&#xff0c;但是接口中的变量会被隐式的指定为 public static final 变量&#xff08;并且只能是 public&#xff0c;用 private 修饰会报编译错误&#xff09;。</p>

<p>接口中的方法是不能在接口中实现的&#xff0c;只能由实现接口的类来实现接口中的方法。</p> 
</blockquote> 
<p>接口的声明语法格式如下&#xff1a;</p> 
<pre><code class="prism language-java"><span class="token keyword">interface</span> 接口名称 <span class="token punctuation">[</span><span class="token keyword">extends</span> 其他的接口名<span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 声明变量</span>
        <span class="token comment">// 抽象方法</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">/* 文件名 : NameOfInterface.java */</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token comment">//引入包</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">NameOfInterface</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token comment">//任何类型 final, static 字段</span>
   <span class="token comment">//抽象方法</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>实例&#xff1a;</p> 
<pre><code class="prism language-java"><span class="token comment">/* 文件名 : Animal.java */</span>
<span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">travel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_143"></a>八、数据结构的运用</h3> 
<p>c&#43;&#43;中用STL容器来实现各类如堆栈&#xff0c;队列&#xff0c;数组等的运用。而java中使用collection接口实现的List&#xff0c;Map等。。。这一部分在算法题里应该会经常用到&#xff0c;说来话长。这里只能简单归纳总结一下。</p> 
<p><img src="https://img-blog.csdnimg.cn/20200730105210184.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbm55b29uYQ&#61;&#61;,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p> 
<pre><code class="prism language-java">List的实现类有&#xff1a;ArrayList、Vector、LinkedList&#xff1b;
Set的实现类有&#xff1a;HashSet、LinkedHashSet、TreeSet&#xff1b;
Map的实现类有&#xff1a;Hashtable、HashMap、ArrayMap、LinkedHashMap、TreeMap。
</code></pre> 
<p>1、List</p>

<p>在List集合中允许出现重复的元素&#xff0c;所有元素是以一种线性方式进行存储的&#xff0c;在程序中可以通过索引来访问集合中的制定元素。并且List中元素有序&#xff0c;即&#xff0c;存入和取出顺序一致。</p> 
<p>&#xff08;1&#xff09;ArrayList 就是动态数组&#xff0c;是Array的复杂版本&#xff0c;动态的增加和减少元素.当更多的元素加入到ArrayList中时,其大小将会动态地增长。它的元素可以通过get/set方法直接访问&#xff0c;因为ArrayList本质上是一个数组。</p>

<p>优点: 底层数据结构是数组Array&#xff0c;查询快&#xff0c;增删慢。</p>

<p>缺点: 线程不安全&#xff0c;效率高</p> 
<p>&#xff08;2&#xff09;Vector 是比较早期会用的了&#xff0c;一般现在用得较少&#xff0c;和ArrayList类似, 底层数据结构是数组Array&#xff0c;查询快。增删慢。在于Vector是同步类(synchronized)&#xff0c;线程安全的&#xff0c;因此,开销就比ArrayList要大&#xff0c;效率低一些。</p> 
<p>&#xff08;3&#xff09;LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比。它还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等。</p> 
<p>2、Set</p> 
<p>&#xff08;1&#xff09;HashSet</p> 
<ul><li>HashSet中不能有相同的元素&#xff0c;可以有一个Null元素&#xff0c;存入的元素是无序的。</li><li>HashSet底层数据结构是哈希表&#xff0c;哈希表就是存储唯一系列的表&#xff0c;而哈希值是由对象的hashCode()方法生成。</li></ul> 
<blockquote> 
 <p>&#xff08;确保唯一性。当向HashSet集合中存入一个元素时&#xff0c;HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值&#xff0c;然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说&#xff0c;HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等&#xff0c;并且两个对象的hashCode()方法返回值相等&#xff09;</p> 
</blockquote> 
<ul><li>添加、删除操作时间复杂度都是O(1)。</li><li>非线程安全。</li></ul> 
<p>&#xff08;2&#xff09;LinkedHashSet</p> 
<blockquote> 
 <p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置&#xff0c;底层数据结构由哈希表和链表组成&#xff0c;链表保证了元素的有序即存储和取出一致&#xff0c;哈希表保证了元素的唯一性。这样使得元素看起来像是以插入顺序保存的&#xff0c;也就是说&#xff0c;当遍历该集合时候&#xff0c;LinkedHashSet将会以元素的添加顺序访问集合的元素。</p> 
</blockquote> 
<ul><li>LinkedHashSet中不能有相同元素&#xff0c;可以有一个Null元素&#xff0c;元素严格按照放入的顺序排列</li><li>添加、删除操作时间复杂度都是O(1)</li><li>非线程安全</li></ul> 
<p>&#xff08;3&#xff09;TreeSet</p> 
<blockquote> 
 <p>TreeSet是SortedSet接口的唯一实现类&#xff0c;TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式&#xff0c;自然排序和定制排序&#xff0c;其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。</p> 
</blockquote> 
<ul><li>TreeSet是中不能有相同元素&#xff0c;不可以有Null元素&#xff0c;根据元素的自然顺序进行排序。</li><li>底层的数据结构是红黑树(一种自平衡二叉查找树&#xff0c;保证元素的排序和唯一性)</li><li>添加、删除操作时间复杂度都是O(log(n))</li><li>非线程安全</li></ul> 
<blockquote> 
 <p>总结&#xff1a;三者都保证了元素的唯一性&#xff0c;如果无排序要求可以选用HashSet&#xff1b;如果想取出元素的顺序和放入元素的顺序相同&#xff0c;那么可以选用LinkedHashSet。如果想插入、删除立即排序或者按照一定规则排序可以选用TreeSet。</p> 
</blockquote> 
<p>3、Map</p>

<p><img src="https://img-blog.csdnimg.cn/2020073011095484.png?x-oss-process&#61;image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbm55b29uYQ&#61;&#61;,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>

<p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现&#xff0c;是以键值对的形式存储和操作数据的容器类型。</p> 
<p>&#xff08;1&#xff09;HashMap&#xff08;无序&#xff09;</p> 
<ul><li>HashMap是一个最常用的Map&#xff0c;它根据键的hashCode值存储数据&#xff0c;根据键可以直接获取它的值&#xff0c;具有很快的访问速度。</li><li>HashMap最多只允许一条记录的键为null&#xff0c;不允许多条记录的值为null。</li><li>HashMap是不安全的线程。它不支持线程的同步&#xff0c;即任一时刻可以有多个线程同时写HashMap&#xff0c;可能会导致数据的不一致。&#xff08;如果需要同步&#xff0c;可以用Collections.synchronizedMap(HashMap map)方法使HashMap具有同步的能力&#xff09;</li></ul> 
<blockquote> 
 <p>一般情况下&#xff0c;我们用的最多的是HashMap,HashMap里面存入的键值对在取出的时候是随机的,它根据键的HashCode值存储数据,根据键可以直接获取它的值&#xff0c;具有很快的访问速度。在Map 中插入、删除和定位元素&#xff0c;HashMap 是最好的选择。</p> 
</blockquote> 
<p>&#xff08;2&#xff09;Hashtable</p> 
<ul><li>Hashtable与HashMap类似&#xff0c;不同的是&#xff1a;它不允许记录的键或者值为空&#xff1b;</li><li>是安全的线程支持线程的同步&#xff0c;即任一时刻只有一个线程能写Hashtable&#xff0c;然而&#xff0c;这也导致了Hashtable在写入时会比较慢。</li></ul> 
<p>&#xff08;3&#xff09;LinkedHashMap</p>

<p>LinkedHashMap保存了记录的插入顺序&#xff0c;在用Iteraor遍历LinkedHashMap时&#xff0c;先得到的记录肯定是先插入的。在遍历的时候会比HashMap慢。有HashMap的全部特性。</p> 
<blockquote> 
 <p>LinkedHashMap 是HashMap的一个子类&#xff0c;如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列&#xff0c;像连接池中可以应用。</p> 
</blockquote> 
<p>&#xff08;4&#xff09;TreeMap</p> 
<ul><li>TreeMap能够把它保存的记录根据键排序&#xff0c;默认是按升序排序&#xff0c;也可以指定排序的比较器。当用Iteraor遍历TreeMap时&#xff0c;得到的记录是排过序的。</li><li>TreeMap的键和值都不能为空。</li></ul> 
<blockquote> 
 <p>HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)&#xff0c;建议多使用HashMap&#xff0c;在需要排序的Map时候才用TreeMap。</p>
 
 <p><h3>C++转JAVA的一点感想</h3></p>
<p> </p>
<p>  出于找工作的原因，在导师的建议下，学习了JAVA语言，深感JAVA编程之轻便，写一点感悟，并且简单的对比以下JAVA与C++的一些异同点，以便大家转JAVA的时候更加高效。</p>
<p>  首先最大的不同在于Java没有指针，更准确的说是没有*以及&符号。从我的角度理解，Java声明的对象其实都是一个指针，指向了一个new 的对象或者一个已经存在的对象，所以我们不需要去delete，因为Java的后台会在对象引用计数为0的时候自动为我们清理内存，节约了很多时间和经历。因为Java没有指针，所以每一个Java的类都不需要写析构函数（方法）,这一点可以帮我们解决很多内存管理上的任务，让我们可以把更多的精力放在业务逻辑上。当然，C++11为我们提供了方便的智能指针，也可以起到类似的效果。</p>
<p>    第二点就是Java没有宏定义。刚开始的时候给我带来了很多烦恼，因为经常和windows api打交道，习惯了用宏定义来为代码做标记(__in int k)以及用宏定义来做一些语句或者类型的替换（例如 TCHAR）。而且目前并没有发现相应的替代方案，希望可以在未来找到相应的解决方法吧~</p>
<p>     第三点就是Java的包的概念，包与C++的namespace还是有很大的区别的，因为Java类中的成员变量被声明为default, protected, public均为包内可见，而namespace更多的是起到了避免重名的作用，所以Java在这一方面可以为我们提供更多的可能。</p>
<p>    第四点是Java的泛型不需要template，这一点可让我少打好多字，特别是写二叉树，图遍历这些程序的时候，一坨一坨的方法需要不停的打template<class T>是一个很让人恼火的事。Java为我们节约了很多时间，而且Java方法（函数）的实现和声明都在同一个.java文件中，可以少些很多诸如void BinaryTree<T>:: Output(ostream& out)这种东西，也是很方便的，只是在一开始的时候会觉得很别扭，很乱。</p>
<p>    第五点是Java只有单继承，但是可以继承多个接口，接口的概念与虚基类是有点像的，但是接口的属性必须是静态常量，这一点有点很难理解，但是在方法（函数）的继承与实现上并没有什么区别。接口更像是定义了某种规范，让我们在编程的时候必须实现某些特定的方法，这一点在多线程的Runnable接口中感触比较深（虽然它只有一个run()）。</p>
<p> </p>
<p> </p>
<p>    第六点就是Java的数组是带下标检查的，可以防止我们出现越界的问题。并且可以很方便的初始化带参数的类对象数组，而C++就略显复杂（可以参见我的另一篇关于初始化唔默认构造函数的元素数组的博客）。</p>
<p>    暂时能想到的就这么多，希望即将转Java的你可以提前避免很多因为曾经的习惯带来的语法错误。Java的学习还是比较简单的，跟随慕课网的Java入门课程可以很快入门并且写出很多小程序，至少用Java实现数据结构要比C++更方便一点。当然，C++的那种对内存的控制感是Java无法比拟的，但是语言毕竟只是工具，编程的思想与算法才是精髓，无论选择何种语言，都是表达自己思想的途径而已~</p>
<p> </p>
<p>/2018年9月16日更新</p>
<p>写完这篇博客不久，我就放弃了JAVA的学习。总的来说，我学完了大部分的JAVA语法，可以顺利实现链表，排序，二叉树这些简单的算法和数据结构。学会了闭包，多线程，有很多感悟，因为Java的设计确实很巧妙，很多值得借鉴的思路。但是我觉得，作为一个IT狗，语言仅仅是一个工具，算法才是核心。如果在找工作的时候没有核心竞争力，公司就可以无情的压榨自己的劳动力，以为自己并非无可取代的那一个，或者说，自己随时可以被工资更低，屁事更少的新员工取代。最终我还是回归了C++开发。想写这次更新，主要是因为舍友经常问我一个问题，你还在搞你的C++吗？时至今日，我只能勉强说一句，是的。但是我从来没有研究过C++，甚至在自己的简历上仅仅写了熟练掌握C++。因为我一直在学习的是算法，只有算法的支撑，才能让我所搞的C++有灵魂，能够一直用C++开发程序。所以，希望看到这篇博客的你们，能够早一点避免追求各种新型的编程语言，而是可以潜心研究一下算法、数学这些内功，这样才不至于被别人轻松淘汰掉~</p>
<ul style="width:50%;">	
<li><a href="https://blog.csdn.net/fannyoona/article/details/107678067">C++转Java学习总结</a></li>
<li><a href="https://blog.csdn.net/weixin_43222324/article/details/110448965">C++转Java快速入门</a></li>
<li><a href="https://blog.csdn.net/Open_PI/article/details/79356719">C++转JAVA的一点感想</a></li>
</ul>

</div>




</body>
</html>
