<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>

<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:95.29%;
	line-height:1.6em;
}
P{
	margin-top:0px;
	margin-bottom:0px;
	text-indent:0em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:100%;
	line-height:100%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	margin-left:0em;
	color:blue;
	padding:0px;
	}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
height:28px;
//white-space:nowrap;
//overflow:hidden; 
//text-overflow:ellipsis; 
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
padding-left:2px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
pre{
    margin-left:2em;
	}
a:visited, a:link{
    color:blue;
}
a:visited{
    color:#CC0000;
}a:hover{
    color:green;
	}
pre{
	font-size:100%;
	line-height:100%;
	padding:0px;
	margin-left:0em;
	background-color:RGB(240,240,240);
    color:blue;
	margin-left:0em;
	}
</style>
</head>

<body>



<div id="container">


<h4>Google CPP Style Guide</h4>

<table id="tbrowser">
<tbody>
<col width="10%" />
<col width="12%" />
<col width="43%" />
<col width="35%" />
<tr>

<p><span style="font-size: 18pt"><strong>C++ Coding Style</strong></span></p>

</tr>
<tr>
<td colspan="4">
<p><span>C++很多强大的语言特性导致它的复杂，其复杂性会使得代码更容易出现bug、难于阅读和维护。</span></p>
<p><span>由于，本人有一点点代码洁癖，所以依照Google的C++编程规范<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" target="_blank" rel="noopener">《Google C++ Style Guide》</a>，用来约束自己平时编程，使得代码在有效使用C++语言特性</span><span>的同时易于管理。</span></p>
</td>
</tr>
<tr>
<td width="90">
<p><span><strong>分类</strong></span></p>
</td>
<td>
<p><span><strong>标题</strong></span></p>
</td>
<td>
<p><span><strong>规则</strong></span></p>
</td>
<td>
<p><span><strong>备注（示例）</strong></span></p>
</td>
</tr>
<tr>
<td rowspan="6" valign="top" width="90">
<p><span><strong>头文件</strong></span></p>
<p><span>每个</span><span>.cpp文件都应对应一个</span><span>.h(.hpp</span><span>)文件</span></p>
</td>
<td>
<p><span><strong>#define</strong><strong>保护</strong></span></p>
</td>
<td>
<p><span>1.<span class="cnblogs_code"><span style="color: rgba(0, 0, 255, 1)">#define</span> PROJECT_PATH_FILE_H_</span>防止.h文件被多重包含；</span></p>
</td>
<td>
<p><span>Project sdk中.h文件sdk/src/abc.h，#define如下：</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 0, 1)"><span style="color: rgba(0, 0, 255, 1)">#ifndef</span> SDK_SRC_ABC_H_
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 255, 1)">#define</span> SDK_SRC_ABC_H_
<span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 0, 1)">...
</span><span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 255, 1)">#endif</span> <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> SDK_SRC_ABC_H_</span></pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>前置声明</strong></span></p>
</td>
<td>
<p><span>1. 使用前置声明尽量减少文件中#include的数量；</span></p>
<p><span>2. 使用函数时，采用#include方式；</span></p>
<p><span>3. 使用类模版时，采用#include方式；</span></p>
<p><span>4. 使用普通类时，采用前置声明；</span></p>
<p><span>5. 数据成员为类自身的指针或引用时，采用前置声明；</span></p>
</td>
<td>
<p><span>可以依赖声明，就不要依赖定义；</span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>内联函数</strong></span></p>
</td>
<td>
<p><span>1. 不要内联超过10行的函数；</span></p>
<p><span>2. 析构函数应慎重对待；</span></p>
<p><span>3. 内联包含循环或switch语言的函数将得不偿失；</span></p>
<p><span>4. 虚函数和递归函数即使被声明为内联也不一定是内联函数；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>-inl.h</strong><strong>函数</strong></span></p>
</td>
<td>
<p><span>1. 复杂的内联函数定义，放在后缀名为-inl.h的头文件中；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>函数参数顺序</strong></span></p>
</td>
<td>
<p><span>1. 函数参数顺序：输入参数在前，输出参数在后；</span></p>
</td>
<td>
<p><span>1. 输入参数为传值或常数引用、常指针；</span></p>
<p><span>2. 输出参数为非常数指针、非常数引用；</span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>包含文件的名字和顺序</strong></span></p>
</td>
<td>
<p><span>1. 包含.h文件次序：优先的.h文件、C库、C++库、其他库的.h、项目内的.h；</span></p>
<p><span>2. 项目内.h文件应按照项目源代码目录树结构排列，并且避免使用UNIX目录.（当前目录）和..（父目录）；</span></p>
<p><span>3. 相同目录下.h文件按字母序排列；</span></p>
</td>
<td>
<p><span>1. google-awe-project/src/base/logging.h应这样被包含：</span></p>
<p><span><span class="cnblogs_code">#include “<span style="color: rgba(0, 0, 255, 1)">base</span>/logging.h”;</span></span></p>
<p><span>2. 某foo.cc（或foo.cpp</span><span>）文件中包含.h文件次序：</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> #include “foo/<span style="color: rgba(0, 0, 0, 1)">public</span>/<span style="color: rgba(0, 0, 0, 1)">foo.h” <span style="color: rgba(0, 128, 0, 1)">// 优先.cc或.cpp对应的头文件
</span></span><span style="color: rgba(0, 128, 128, 1)">2</span> #include &lt;sys/types.h&gt;      <span style="color: rgba(0, 128, 128, 1)">// C库</span>
<span style="color: rgba(0, 128, 128, 1)">3</span> #include &lt;hash_map&gt;         <span style="color: rgba(0, 128, 128, 1)">// C++库</span>
<span style="color: rgba(0, 128, 128, 1)">4</span> #include &lt;foo/<span style="color: rgba(0, 0, 0, 1)">public</span>/bar.h&gt; <span style="color: rgba(0, 128, 128, 1)">// 项目内头文件</span></pre>
</div>
</td>
</tr>
<tr>
<td rowspan="5" valign="top" width="90">
<p><span><strong>作用域</strong></span></p>
</td>
<td>
<p><span><strong>作用域</strong></span></p>
</td>
<td>
<p><span>1. 在.cpp文件（不能在.h文件）中，使用不具名的命名空间；</span></p>
<p><span>2. 具名命名空间的名称基于项目或路径名称；</span></p>
<p><span>3. 不要使用using指示符，避免污染命名空间，可以使用using；</span></p>
<p><span>4. 在.cpp文件、.h文件中的函数和类中，可以使用using；</span></p>
<p><span>5. 在.cpp文件、.h文件中的函数和类中，可以使用命名空间别名；</span></p>
<p><span>6. 不要使用inline namespace；</span></p>
</td>
<td>
<p><span>1. 在.cpp文件中的不具名命名空间：</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">namespace</span>
<span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 255, 1)">enum</span> {UNUSED, EOF, ERROR}; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 无缩进</span>
<span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 255, 1)">bool</span> foo() {<span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> EOF;}
</span><span style="color: rgba(0, 128, 128, 1)">5</span> } <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> namespace</span></pre>
</div>
<p><span>2. 具名命名空间：</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">namespace</span><span style="color: rgba(0, 0, 0, 1)"> mynamespace
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> MyClass
</span><span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">5</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)">6</span>     <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> foo();
</span><span style="color: rgba(0, 128, 128, 1)">7</span> <span style="color: rgba(0, 0, 0, 1)">};
</span><span style="color: rgba(0, 128, 128, 1)">8</span> } <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> namespace mynamespace</span></pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>嵌套类</strong></span></p>
</td>
<td>
<p><span>1. 嵌套类不作为接口使用时，不要定义为public；</span></p>
<p><span>2. 嵌套类作为接口的一部分时，置于命名空间中；</span></p>
</td>
<td>
<p><span>非接口嵌套类：</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Foo
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)">4</span>     <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Bar
</span><span style="color: rgba(0, 128, 128, 1)">5</span> <span style="color: rgba(0, 0, 0, 1)">    {
</span><span style="color: rgba(0, 128, 128, 1)">6</span> <span style="color: rgba(0, 0, 0, 1)">    };
</span><span style="color: rgba(0, 128, 128, 1)">7</span> };</pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>非成员函数、静态成员函数、全局函数</strong></span></p>
</td>
<td>
<p><span>1. 使用命名空间中的非成员函数或静态成员函数，尽量不使用全局函数；</span></p>
<p><span>2. 若确定需要定义非成员函数，并且只在.cpp文件中使用它，可使用不具名命名空间或static关联限定其作用域；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>局部变量</strong></span></p>
</td>
<td>
<p><span>1. 将函数变量尽可能置于最小作用域内，在声明变量时将其初始化；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>静态和全局变量</strong></span></p>
</td>
<td>
<p><span>1. 禁止class类型的全局（静态）变量，若一定要使用，可单例模式；</span></p>
<p><span>2. 多线程代码中禁止非常数全局变量，不可使用函数返回值初始化全局变量；</span></p>
<p><span>3. 全局字符串常量，使用C风格字符串，而不要使用STL字符串；</span></p>
<p><span>4. 大多数全局变量应该是类的静态数据成员，或当其只在.cpp文件中使用时，将其定义到不具名命名空间中，或者使用静态关联以限制变量的作用域；</span></p>
<p><span>5. 静态成员变量视作全局变量，不能是class类型；</span></p>
</td>
<td>
<p><span>C风格字符串常量：</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">char</span> kFrogSays[] = “ribbet”;</pre>
</div>
</td>
</tr>
<tr>
<td rowspan="12" valign="top" width="90">
<p><span><strong>类</strong></span></p>
</td>
<td>
<p><span><strong>构造函数职责</strong></span></p>
</td>
<td>
<p><span>1. 构造函数只进行那些没有实际意义的初始化；</span></p>
<p><span>2. 如果对象需要有意义的初始化，可以采用工厂函数或者Init()方法集中初始化；</span></p>
<p><span>3. 构造函数禁止调用虚函数；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>初始化</strong></span></p>
</td>
<td>
<p><span>1. 若类中定义了成员变量，没有提供其他构造函数，需要定义一个默认构造函数；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>显式构造函数</strong></span></p>
</td>
<td>
<p><span>1. 除非必要，单参数构造函数使用C++关键字explicit；</span></p>
</td>
<td>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">explicit</span> Foo(<span style="color: rgba(0, 0, 255, 1)">string</span> name);</pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>拷贝构造函数</strong></span></p>
</td>
<td>
<p><span>1. 仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数，不需要拷贝时应使用DISALLOW_COPY_AND_ASSIGN；</span></p>
</td>
<td>
<p><span>可以考虑在类的private中添加空的拷贝构造函数和赋值操作，并且只有声明，不进行定义；</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)"> 1</span> <span style="color: rgba(0, 0, 255, 1)">#define</span> DISALLOW_COPY_AND_ASSIGN(Type) \
<span style="color: rgba(0, 128, 128, 1)"> 2</span>     Type(<span style="color: rgba(0, 0, 255, 1)">const</span> Type&amp;<span style="color: rgba(0, 0, 0, 1)">);                 \
</span><span style="color: rgba(0, 128, 128, 1)"> 3</span>     <span style="color: rgba(0, 0, 255, 1)">void</span> <span style="color: rgba(0, 0, 255, 1)">operator</span> = (<span style="color: rgba(0, 0, 255, 1)">const</span> Type&amp;<span style="color: rgba(0, 0, 0, 1)">)
</span><span style="color: rgba(0, 128, 128, 1)"> 4</span> 
<span style="color: rgba(0, 128, 128, 1)"> 5</span> <span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)"> Foo
</span><span style="color: rgba(0, 128, 128, 1)"> 6</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)"> 7</span> <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)"> 8</span>     Foo(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> f);
</span><span style="color: rgba(0, 128, 128, 1)"> 9</span>     ~<span style="color: rgba(0, 0, 0, 1)">Foo();
</span><span style="color: rgba(0, 128, 128, 1)">10</span> <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)">:
</span><span style="color: rgba(0, 128, 128, 1)">11</span> <span style="color: rgba(0, 0, 0, 1)">    DISALLOW_COPY_AND_ASSIGN(Foo);
</span><span style="color: rgba(0, 128, 128, 1)">12</span> };</pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>结构体和类</strong></span></p>
</td>
<td>
<p><span>1. 仅当只有数据时使用struct，其它情况使用class；</span></p>
<p><span>2. 对于functor和trait，可以使用struct；</span></p>
<p><span>3. 类和结构体的成员变量使用不同的命名规则（见下面的<strong>命名约定</strong>）；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>继承</strong></span></p>
</td>
<td>
<p><span>1. 所有继承必须为public继承，采用基类对象作为成员的方式替代私有继承；</span></p>
<p><span>2. 不要过多使用实现继承，更多使用组合；</span></p>
<p><span>3. 使析构函数为virtual，如果该类具有虚函数，其析构函数一定为虚函数；</span></p>
<p><span>4. 限定仅在子类访问的成员函数为protected，数据成员应始终为私有；</span></p>
<p><span>5. 重定义派生的虚函数时，在派生类中明确声明其为virtual；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>多继承</strong></span></p>
</td>
<td>
<p><span>1. 只有当最多一个基类中含有实现，其他基类都是以Interface为后缀的纯接口类时才使用多继承；</span></p>
<p><span>2. 纯接口必须以Interface为后缀；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>接口</strong></span></p>
</td>
<td>
<p><span>1. 满足纯接口要求时，类以Interface结尾；</span></p>
<p><span>2. 接口类必须声明虚析构函数，析构函数不能纯虚函数；</span></p>
</td>
<td>
<p><span>满足纯接口类的要求：</span></p>
<p><span>* 只有纯虚函数和静态函数（析构函数除外）；</span></p>
<p><span>* 没有非静态数据成员；</span></p>
<p><span>* 没有定义任何构造函数，若有，须不含参数，且为protected；</span></p>
<p><span>* 如果是子类，只能继承满足以上条件并以Interface为后缀的类；</span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>操作符重载</strong></span></p>
</td>
<td>
<p><span>1. 一般不要重载操作符，如果需要的话，可以定义类似Equal()、CopyFrom()等函数；</span></p>
<p><span>2. STL容器中作为key要重载operator==或operator&lt;，可以在声明容器的时候，创建相等判断和大小比较的仿函数类型；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>访问控制</strong></span></p>
</td>
<td>
<p><span>1. 将类数据成员设为private，并提供相关存取函数；</span></p>
<p><span>2. 存取函数的定义一般内联在头文件中；</span></p>
</td>
<td>
<p><span>定义变量m_foo及其取值函数foo()、赋值函数setFoo()；</span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>声明顺序</strong></span></p>
</td>
<td>
<p><span>1. 类中定义次序：public:、protected:、private:；</span></p>
<p><span>2. 每一块中，声明次序为：typedef和enum、常量（static const数据成员）、构造函数、析构函数、成员函数（含静态成员函数）、数据成员（除static const数据成员）；</span></p>
<p><span>3. 宏DISALLOW_COPY_AND_ASSIGN置于private:块之后，作为类的最后部分；</span></p>
<p><span>4. .cc文件中函数的定义顺序和声明次序一致；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>编写短小函数</strong></span></p>
</td>
<td>
<p><span>1. 如果函数超过40行，可以考虑在不影响程序结构的情况下将其分割；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td rowspan="18" valign="top" width="90">
<p><span><strong>其它</strong><strong>C++</strong><strong>特性</strong></span></p>
</td>
<td>
<p><span><strong>智能指针</strong></span></p>
</td>
<td>
<p><span>1. 任何情况下禁止使用auto_ptr；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>引用参数</strong></span></p>
</td>
<td>
<p><span>1. 所有按引用传递的参数必须为const引用；</span></p>
<p><span>2. 输入参数采用const引用，输出参数采用指针；</span></p>
<p><span>3. 输入参数可以是const指针，但不可以是non-const引用；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>函数重载</strong></span></p>
</td>
<td>
<p><span>1. 仅在输入参数类型不同、功能相同时使用重载函数；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>缺省参数</strong></span></p>
</td>
<td>
<p><span>1. 禁止使用缺省参数；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>变长数组和</strong><strong>alloca</strong></span></p>
</td>
<td>
<p><span>1. 禁止使用变长数组和alloca()；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>友元</strong></span></p>
</td>
<td>
<p><span>1. 可以合理使用友元类及友元函数；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>异常</strong></span></p>
</td>
<td>
<p><span>1. 禁止使用异常；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>运行时类型识别</strong></span></p>
</td>
<td>
<p><span>1. 除单元测试外，禁止使用RTTI；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>类型转换</strong></span></p>
</td>
<td>
<p><span>1. 使用C++风格而不要使用C风格类型转换；</span></p>
<p><span>2. 除单元测试外不要使用dynamic_cast；</span></p>
</td>
<td>
<p><span>使用static_case &lt;&gt; ()等C++的类型转换；</span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>流</strong></span></p>
</td>
<td>
<p><span>1. 除日志接口外，使用printf之类的代替流；</span></p>
</td>
<td>
<p><span>最好选择printf + read/write；</span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>前置自增和自减</strong></span></p>
</td>
<td>
<p><span>1. 对于迭代器和其他模板对象使用前缀形式自增和自减运算符；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>const</strong><strong>使用</strong></span></p>
</td>
<td>
<p><span>1. 在任何可以使用的情况下使用const；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>整型</strong></span></p>
</td>
<td>
<p><span>1. 使用断言声明变量为非负数，不要使用无符号型；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>64</strong><strong>位下的可移植性</strong></span></p>
</td>
<td>
<p><span>1. printf指定的一些类型在32位和64位系统上可移植性不是很好；</span></p>
<p><span>2. sizeof(void *) != sizeof(int)，可以用intptr_t定义指针大小的整数；</span></p>
<p><span>3. 结构体字节对齐；</span></p>
<p><span>4. 创建64位常量时使用LL或ULL作为后缀；</span></p>
</td>
<td>
<p><span><span class="cnblogs_code">int64_t my_value = 0x123456LL;</span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>预处理宏</strong></span></p>
</td>
<td>
<p><span>1. 慎用宏，尽可能以内联函数、枚举和常量代替；</span></p>
<p><span>2. 在.h文件中，除了#define防止头文件重包含外，不要定义宏；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>0</strong><strong>和</strong><strong>NULL</strong></span></p>
</td>
<td>
<p><span>1. 整数用0，实数用0.0，指针用NULL，字符（串）用’\0’；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>sizeof</strong></span></p>
</td>
<td>
<p><span>1. 尽可能用sizeof(varname)代替sizeof(type)；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>Boost</strong><strong>库</strong></span></p>
</td>
<td>
<p><span>1. 只使用Boost中被认可的库：</span></p>
<p><span>Compressed Pair：boost/compressed_pair.hpp；</span></p>
<p><span>Pointer Container：boost/ptr_container，其中不包括ptr_array.hpp和serialization；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td rowspan="9" valign="top" width="90">
<p><span><strong>命名约定</strong></span></p>
<p><span>最重要是一致性</span></p>
</td>
<td>
<p><span><strong>通用命名规则</strong></span></p>
</td>
<td>
<p><span>1. 函数、变量、文件命名应具有描述性，不要过度缩写，类型和变量应是名词，函数名可以用“命令性”动词；</span></p>
<p><span>2. 除非放到项目外也非常明了，否则不要使用缩写；</span></p>
</td>
<td>
<p><span>1.<span class="cnblogs_code"><span style="color: rgba(0, 0, 255, 1)">int</span> num_completed_connections;</span></span></p>
<p><span>2.<span class="cnblogs_code"><span style="color: rgba(0, 0, 255, 1)">int</span> num_dns_connections;</span></span></p>
<p><span>3.<span class="cnblogs_code"><span style="color: rgba(0, 0, 255, 1)">int</span> error_count; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Good.</span></span></span></p>
<p><span> <span class="cnblogs_code"><span style="color: rgba(0, 0, 255, 1)">int</span> error_cnt; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Bad.</span></span><br></span></p>



</td>



</tr>
<tr>
<td>
<p><span><strong>文件命名</strong></span></p>



</td>
<td>
<p><span>1. 文件名要全部小写，可以包含’_’或’-’，按项目约定来；</span></p>
<p><span>2. 源文件以.cc结尾，头文件以.h结尾；</span></p>
<p><span></span></p>



</td>
<td>
<p><span>可接受的文件命名：</span></p>
<p><span>my_useful_class.cc</span></p>
<p><span>my-useful-class.cc</span></p>
<p><span>myusefulclass.cc</span></p>



</td>



</tr>
<tr>
<td>
<p><span><strong>类型命名</strong></span></p>



</td>
<td>
<p><span>1. 类型命名每个单词以大写字母开头，不包含下划线；</span></p>



</td>
<td>
<p><span>1. 类型：类、结构体、类型定义（typedef）、枚举；</span></p>
<p><span>2. 如：MyExcitingClass、UrlTable；</span></p>



</td>



</tr>
<tr>
<td>
<p><span><strong>变量命名</strong></span></p>



</td>
<td>
<p><span>1. 变量名一律小写，单词间以下划线相连，类的成员变量以下划线结尾；</span></p>
<p><span>2. 结构体数据成员可以和普通变量一样，不用像类的成员数据那样以下划线结尾；</span></p>
<p><span>3. 全局变量以g_作为前缀；</span></p>



</td>
<td>
<p><span>1.</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 0, 1)">my_exciting_local_variable
</span><span style="color: rgba(0, 128, 128, 1)">2</span> my_exciting_member_variable_</pre>
</div>
<p><span>2.</span></p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">struct</span><span style="color: rgba(0, 0, 0, 1)"> UrlTablePoperties
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 0, 1)">    sting name;
</span><span style="color: rgba(0, 128, 128, 1)">4</span>     <span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> num_entries;
</span><span style="color: rgba(0, 128, 128, 1)">5</span> };</pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>常量命名</strong></span></p>
</td>
<td>
<p><span>1. 在名称前加k；</span></p>
</td>
<td>
<p><span><span class="cnblogs_code"><span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">int</span> kDayInAWeek = <span style="color: rgba(128, 0, 128, 1)">7</span>;</span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>函数命名</strong></span></p>
</td>
<td>
<p><span>1. 普通函数为大小写混合，存取函数则需要与变量名匹配；</span></p>
<p><span>2. 其它短小的内联函数可以使用小写字母；</span></p>
</td>
<td>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 0, 1)">MyExcitingMethod()
</span><span style="color: rgba(0, 128, 128, 1)">2</span> set_my_exciting_member_variable()</pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>命名空间</strong></span></p>
</td>
<td>
<p><span>1. 命名空间全部为小写；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>枚举命名</strong></span></p>
</td>
<td>
<p><span>1. 枚举值全部大写，单词间以下划线相连；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>宏命名</strong></span></p>
</td>
<td>
<p><span>1. 如果要使用，其命名方式与枚举命名一致；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td rowspan="7" valign="top" width="90">
<p><span><strong>代码注释</strong></span></p>
</td>
<td>
<p><span><strong>注释风格</strong></span></p>
</td>
<td>
<p><span>1. 使用<strong>//</strong>或<strong>/* */</strong>，统一就好；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>文件注释</strong></span></p>
</td>
<td>
<p><span>1. 在每一个文件开头加入版权公告，然后是文件内容描述；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>类注释</strong></span></p>
</td>
<td>
<p><span>1. 类的定义要附着描述类的功能和用法的注释；</span></p>
<p><span>2. 如果类的实例可被多线程访问，使用时务必文档说明；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>函数注释</strong></span></p>
</td>
<td>
<p><span>1. 函数声明处注释描述函数功能，定义处描述函数实现；</span></p>
<p><span>2. 构造/析构函数前无需注释；</span></p>
</td>
<td>
<p><span>1. 函数声明处注释的内容：</span></p>
<p><span>* inputs及outputs；</span></p>
<p><span>* 类成员函数：函数调用期间对象是否需要保持引用参数，是否会释放这些参数；</span></p>
<p><span>* 如果函数分配了空间，需要由调用者释放；</span></p>
<p><span>* 参数是否可以为NULL；</span></p>
<p><span>* 是否存在函数使用的性能隐忧；</span></p>
<p><span>* 如果函数是可重入的，其同步前提是什么；</span></p>
<p><span>2. 函数定义处定义的内容：</span></p>
<p><span>注释说明函数功能和实现要点；</span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>变量注释</strong></span></p>
</td>
<td>
<p><span>1. 通常变量名本身足以很好说明变量用途，特定情况下，需要额外注释说明；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>实现注释</strong></span></p>
</td>
<td>
<p><span>1. 对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释；</span></p>
<p><span>2. 相邻几行都有注释的，可以调整使<strong>//</strong>纵向对齐；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>TODO</strong><strong>注释</strong></span></p>
</td>
<td>
<p><span>1. 对那些临时的、短期的解决方案，或已经够好但并不完美的代码使用TODO注释；</span></p>
</td>
<td>
<p><span><span class="cnblogs_code"><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> TODO(hanyp@126.com): change this.</span></span></span></p>
</td>
</tr>
<tr>
<td rowspan="14" valign="top" width="90">
<p><span><strong>格式</strong></span></p>
</td>
<td>
<p><span><strong>行长度</strong></span></p>
</td>
<td>
<p><span>1. 每一行代码字符数不超过80；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>空格</strong></span></p>
</td>
<td>
<p><span>1. 只使用空格，每次缩进2个字符。设定编译器将Tab转为空格；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>函数声明和定义</strong></span></p>
</td>
<td>
<p><span>1. 函数名、返回类型、参数尽可能在同一行；</span></p>
<p><span>2. 如果函数为const的，const应与最后一个参数位于同一行；</span></p>
<p><span>3. 独立行的参数保持4个空格的缩进；</span></p>
</td>
<td>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 0, 1)">ReturnType ClassName::FunctionName(Type ar_name1, Type par_name2)
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 0, 1)">    DoSomething();
</span><span style="color: rgba(0, 128, 128, 1)">4</span> }</pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>函数调用</strong></span></p>
</td>
<td>
<p><span>1. 同函数声明和定义格式；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>条件语句</strong></span></p>
</td>
<td>
<p><span>1. 不要再圆括号内加空格；</span></p>
</td>
<td>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (condition)
</span><span style="color: rgba(0, 128, 128, 1)">2</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">3</span> <span style="color: rgba(0, 0, 0, 1)">    ...
</span><span style="color: rgba(0, 128, 128, 1)">4</span> <span style="color: rgba(0, 0, 0, 1)">}
</span><span style="color: rgba(0, 128, 128, 1)">5</span> <span style="color: rgba(0, 0, 255, 1)">else</span>
<span style="color: rgba(0, 128, 128, 1)">6</span> <span style="color: rgba(0, 0, 0, 1)">{
</span><span style="color: rgba(0, 128, 128, 1)">7</span> <span style="color: rgba(0, 0, 0, 1)">    ...
</span><span style="color: rgba(0, 128, 128, 1)">8</span> }</pre>
</div>
</td>
</tr>
<tr>
<td>
<p><span><strong>循环和选择语句</strong></span></p>
</td>
<td>
<p><span>1. 类比条件语句；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>指针和引用表达式</strong></span></p>
</td>
<td>
<p><span>1. 句点（.）或箭头（-&gt;）前后不要有空格，指针/地址操作符（*、&amp;）后不要空格；</span></p>
<p><span>1. 在声明指针、引用变量或参数时，（*、&amp;）与类型名紧挨；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>布尔表达式</strong></span></p>
</td>
<td>
<p><span>1. 如果一个布尔表达式超过标准行宽，断行要统一；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>函数返回值</strong></span></p>
</td>
<td>
<p><span>1. return表达式中不要使用圆括号；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>变量及数组初始化</strong></span></p>
</td>
<td>
<p><span>1. 使用()格式；</span></p>
</td>
<td>
<p><span><span class="cnblogs_code"><span style="color: rgba(0, 0, 255, 1)">int</span> x(<span style="color: rgba(128, 0, 128, 1)">3</span>);</span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>预处理指令</strong></span></p>
</td>
<td>
<p><span>1. 预处理指令不需要缩进；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>类格式</strong></span></p>
</td>
<td>
<p><span>1. public、protected、private不需要缩进，函数及变量定义缩进2空格；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>初始化列表</strong></span></p>
</td>
<td>
<p><span>1. 构造函数初始化列表放在同一行或按四格缩进并排几行；</span></p>
<p><span>2. ‘:’前后各空一格；</span></p>
</td>
<td>
<p><span></span></p>
</td>
</tr>
<tr>
<td>
<p><span><strong>命名空间格式</strong></span></p>
</td>
<td>
<p><span>1. 命名空间内容不需要缩进，命名空间不添加额外缩进层次；</span></p>
</td>
<td>
<p><span style="font-size: 16px"></span></p>
</td>
</tr>
</tbody>
</table>

<p style='float:right;'>本页共1038段，38209个字符，46264 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
