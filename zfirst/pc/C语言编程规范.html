<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	width:115%;
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	overflow-x:auto;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>C语言编程规范</h4>


<p><a href="https://www.toutiao.com/article/7115410286529479176" title="">ref</a></p>
<p>今天给大家分享一篇C语言编码规范，可以从源头上规避掉很多bug，希望能对大家有所帮助。</p>
<h3>01 最重要的规则</h3>
<p>编写代码时最重要的一条规则是：检查周围的代码并尝试模仿它。</p>
<p>作为维护人员，如果收到的补丁明显与周围代码的编码风格不同，这是令人沮丧的。这是不尊重人的，就像某人穿着泥泞的鞋子走进一间一尘不染的房子。</p>
<p>因此，无论本文推荐的是什么，如果已经编写了代码并且您正在对其进行修补，请保持其当前的样式一致，即使它不是您最喜欢的样式。</p>
<h3>02 一般性的规则</h3>
<p>这里列出了最明显和最重要的一般规则。在你继续阅读其他章节之前，请仔细检查它们：</p>
<h4>1 使用C99标准</h4>
<h4>2 不使用制表符，而是使用空格</h4>
<h4>3 每个缩进级别使用4个空格</h4>
<h4>4 在关键字和左括号之间使用一个空格</h4>
<h4>5 在函数名和左括号之间不要使用空格</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
int32_t a = sum(4, 3);              <font color=#CCC>/* OK */</font>
<font color=#00F>int</font>32_t a = sum (4, 3);             <font color=#CCC>/* Wrong */</font>
</pre>
<h4>6 不要在变量、函数、宏、类型中使用_或前缀。这是为C语言本身保留的</h4>
<h4>7 对于严格的模块私有函数，使用prv_name前缀</h4>
<h4>8 对于包含下划线_的变量/函数/宏/类型，只能使用小写字母</h4>
<h4>9 左花括号总是与关键字(for, while, do, switch, if，…)在同一行</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
size_t i;
<font color=#00F>for</font> (i = 0; i &lt; 5; ++i) {           <font color=#CCC>/* OK */</font>
}
<font color=#00F>for</font> (i = 0; i &lt; 5; ++i){            <font color=#CCC>/* Wrong */</font>
}
<font color=#00F>for</font> (i = 0; i &lt; 5; ++i)             <font color=#CCC>/* Wrong */</font>
{
}
</pre>
<h4>10 在比较操作符和赋值操作符之前和之后使用单个空格</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
int32_t a;
a = 3 + 4;              <font color=#CCC>/* OK */</font>
<font color=#00F>for</font> (a = 0; a &lt; 5; ++a) <font color=#CCC>/* OK */</font>
a=3+4;                  <font color=#CCC>/* Wrong */</font>
a = 3+4;                <font color=#CCC>/* Wrong */</font>
<font color=#00F>for</font> (a=0;a&lt;5;++a)       <font color=#CCC>/* Wrong */</font>
</pre>
<h4>11 每个逗号后用单空格</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
func_name(5, 4);        <font color=#CCC>/* OK */</font>
func_name(4,3);         <font color=#CCC>/* Wrong */</font>
</pre>
<h4>12 不要初始化静态和全局变量为0(或NULL)，让编译器为您做</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>static</font> int32_t a;       <font color=#CCC>/* OK */</font>
<font color=#00F>static</font> int32_t b = 4;   <font color=#CCC>/* OK */</font>
<font color=#00F>static</font> int32_t a = 0;   <font color=#CCC>/* Wrong */</font>
<font color=#00F>void</font> my_func(<font color=#00F>void</font>) {
    <font color=#00F>static </font>int32_t* ptr;<font color=#CCC>/* OK */</font>
    <font color=#00F>static </font><font color=#00F>char </font>abc = 0;<font color=#CCC>/* Wrong */</font>
}
</pre>
<h4>13 在同一行中声明所有相同类型的局部变量</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>void</font> my_func(<font color=#00F>void</font>) {
    <font color=#00F>char </font>a;             <font color=#CCC>/* OK */</font>
    <font color=#00F>char </font>b;             <font color=#CCC>/* Wrong, variable with char type already exists */</font>
    <font color=#00F>char </font>a, b;          <font color=#CCC>/* OK */</font>
}
</pre>
<h4>14 按顺序声明局部变量</h4>
<p>i. 自定义结构和枚举</p>
<p>  ii. 整数类型，更宽的无符号类型优先</p>
<p>  iii. 单/双浮点</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>int</font> my_func(<font color=#00F>void</font>) {
    <font color=#CCC>/* 1 */</font>
    my_struct_t my;     <font color=#CCC>/* First custom structures */</font>
    my_struct_ptr_t* p; <font color=#CCC>/* Pointers too */</font>
    <font color=#CCC>/* 2 */</font>
    uint32_t a;
    int32_t b;
    uint16_t c;
    int16_t g;
    <font color=#00F>char </font>h;
    <font color=#CCC>/* ... */</font>
    <font color=#CCC>/* 3 */</font>
    <font color=#00F>double </font>d;
    <font color=#00F>float </font>f;
}
</pre>
<h4>15 总是在块的开头声明局部变量，在第一个可执行语句之前</h4>
<h4>16 在for循环中声明计数器变量</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>for</font> (size_t i = 0; i &lt; 10; ++i)
<font color=#CCC>/* OK, if you need counter variable later */</font>
size_t i;
<font color=#00F>for</font> (i = 0; i &lt; 10; ++i) {
    <font color=#00F>if </font>(...) {
        break;
    }
}
<font color=#00F>if</font> (i * 10) {
}
<font color=#CCC>/* Wrong */</font>
size_t i;
<font color=#00F>for</font> (i = 0; i &lt; 10; ++i) ...
</pre>
<h4>17 避免在声明中使用函数调用来赋值变量，除了单个变量</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>void</font> a(<font color=#00F>void</font>) {
    <font color=#CCC>/* Avoid function calls when declaring variable */</font>
    int32_t a, b = sum(1, 2);
    <font color=#CCC>/* Use this */</font>
    int32_t a, b;
    b = sum(1, 2);
    <font color=#CCC>/* This is ok */</font>
    uint8_t a = 3, b = 4;
}
</pre>
<h4>18 除了char、float或double之外，始终使用stdint.h标准库中声明的类型</h4>
<p>例如，8位的uint8_t等。</p>
<h4>19 不要使用stdbool.h库。分别使用1或0表示真或假</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
uint8_t status;
status = 0;
<font color=#CCC>/* Wrong */</font>
<font color=#C00>#include</font> &lt;stdbool.h>
<font color=#00F>bool</font> status = true;
</pre>
<h4>20 永远不要与真实相比较</h4>
<p>例如，使用if(check_func()){…}替换if (check_func() == 1)</p>
<h4>21 总是将指针与空值进行比较</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
void* ptr;
<font color=#CCC>/* ... */</font>
<font color=#CCC>/* OK, compare against NULL */</font>
<font color=#00F>if</font> (ptr * NULL || ptr != NULL) {
}
<font color=#CCC>/* Wrong */</font>
<font color=#00F>if</font> (ptr || !ptr) {
}
</pre>
<h4>22 总是使用前增量(和递减)，而不是后增量(和递减)</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
int32_t a = 0;
...
a++;            <font color=#CCC>/* Wrong */</font>
++a;            <font color=#CCC>/* OK */</font>
<font color=#00F>for</font> (size_t j = 0; j &lt; 10; ++j) {}  <font color=#CCC>/* OK */</font>
</pre>
<h4>23 总是使用size_t作为长度或大小变量</h4>
<h4>24 如果函数不应该修改指针所指向的内存，则总是使用const作为指针</h4>
<h4>25 如果不应该修改函数的形参或变量，则总是使用const</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* When d could be modified, data pointed to by d could not be modified */</font>
<font color=#00F>void</font>
my_func(<font color=#00F>const</font> void* d) {
}
<font color=#CCC>/* When d and data pointed to by d both could not be modified */</font>
<font color=#00F>void</font>
my_func(<font color=#00F>const</font> void* <font color=#00F>const </font>d) {
}
<font color=#CCC>/* Not required, it is advised */</font>
<font color=#00F>void</font>
my_func(<font color=#00F>const</font> size_t len) {
}
<font color=#CCC>/* When d should not be modified inside function, only data pointed to by d could be modified */</font>
<font color=#00F>void</font>
my_func(<font color=#00F>void</font>* <font color=#00F>const </font>d) {
}
</pre>
<h4>26 当函数可以接受任何类型的指针时，总是使用void *，不要使用uint8_t *。函数在实现时必须注意正确的类型转换</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/*
 * To send data, function should not modify memory pointed to by `data` variable
 * thus `const` keyword is important
 *
 * To send generic data (or to write them to file)
 * any type may be passed for data,
 * thus use `void *`
 */</font>
<font color=#CCC>/* OK example */</font>
<font color=#00F>void</font> send_data(<font color=#00F>const</font> void* data, size_t len) { <font color=#CCC>/* OK */</font>
    <font color=#CCC>/* Do not cast `void *` or `const void *` */</font>
    <font color=#00F>const </font>uint8_t* d = data;<font color=#CCC>/* Function handles proper type for internal usage */</font>
}
<font color=#00F>void</font> send_data(<font color=#00F>const</font> void* data, <font color=#00F>int </font>len) {    <font color=#CCC>/* Wrong, not not use int */</font>
}
</pre>
<h4>27 总是使用括号和sizeof操作符</h4>
<h4>28 不要使用变长数组。</h4>
<p>使用动态内存分配代替标准C malloc和自由函数，或者如果库/项目提供了自定义内存分配，使用它的实现看看LwMEM，一个自定义内存管理库。</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#C00>#include</font> &lt;stdlib.h>
<font color=#00F>void</font> my_func(size_t size) {
    int32_t* arr;
    arr = malloc(<font color=#00F>sizeof</font>(*arr) * n); <font color=#CCC>/* OK, Allocate memory */</font>
    arr = malloc(<font color=#00F>sizeof</font> *arr * n);  <font color=#CCC>/* Wrong, brackets for sizeof operator are missing */</font>
    <font color=#00F>if </font>(arr * NULL) {
        <font color=#CCC>/* FAIL, no memory */</font>
    }
    free(arr);  <font color=#CCC>/* Free memory after usage */</font>
}
<font color=#CCC>/* Wrong */</font>
<font color=#00F>void</font>
my_func(size_t size) {
    int32_t arr[size];  <font color=#CCC>/* Wrong, do not use VLA */</font>
}
</pre>
<h4>29 总是将variable与0进行比较，除非它被视为布尔类型</h4>
<h4>30 永远不要将布尔处理的变量与0或1进行比较。用NOT(!)代替</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
size_t length = 5;  <font color=#CCC>/* Counter variable */</font>
uint8_t is_ok = 0;  <font color=#CCC>/* Boolean-treated variable */</font>
<font color=#00F>if</font> (length)         <font color=#CCC>/* Wrong, length is not treated as boolean */</font>
<font color=#00F>if</font> (length > 0)     <font color=#CCC>/* OK, length is treated as counter variable containing multi values, not only 0 or 1 */</font>
<font color=#00F>if</font> (length == 0)    <font color=#CCC>/* OK, length is treated as counter variable containing multi values, not only 0 or 1 */</font>
<font color=#00F>if</font> (is_ok)          <font color=#CCC>/* OK, variable is treated as boolean */</font>
<font color=#00F>if</font> (!is_ok)         <font color=#CCC>/* OK, -||- */</font>
<font color=#00F>if</font> (is_ok == 1)     <font color=#CCC>/* Wrong, never compare boolean variable against 1! */</font>
<font color=#00F>if</font> (is_ok == 0)     <font color=#CCC>/* Wrong, use ! for negative check */</font>
</pre>
<h4>31 对于注释，总是使用/* comment */，即使是单行注释</h4>
<h4>32 在头文件中总是包含带有extern关键字的c++检查</h4>
<h4>33 每个函数都必须包含doxygen-enabled注释，即使函数是静态的</h4>
<h4>34 使用英文名称/文本的函数，变量，注释</h4>
<h4>35 变量使用小写字母</h4>
<h4>36 如果变量包含多个名称，请使用下划线。force_redraw。不要使用forceRedraw</h4>
<h4>37 对于C标准库的包含文件，请始终使用<和>。</h4>
<p>例如，# include < stdlib.h ></p>
<h4>38 对于自定义库，请始终使用""。</h4>
<p>例如，# include“my_library.h”</p>
<h4>39 当转换为指针类型时，总是将星号与类型对齐，</h4>
<p>例如。uint8_t* t = (uint8_t*)var_width_diff_type</p>
<h4>40 始终尊重项目或库中已经使用的代码风格</h4>
<h3>03 注释相关的规则</h3>
<h4>3.1 不允许以//开头的注释。总是使用/* comment */，即使是单行注释</h4>
<h4>3.2 对于多行注释，每行使用空格+星号</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/*
 * This is multi-line comments,
 * written in 2 lines (ok)
 */</font>
<font color=#CCC>/**
 * Wrong, use double-asterisk only for doxygen documentation
 */</font>
<font color=#CCC>/*
 * Single line comment without space before asterisk (wrong)
 */</font>
<font color=#CCC>/*
 * Single line comment in multi-line configuration (wrong)
 */</font>
<font color=#CCC>/* Single line comment (ok) */</font>
</pre>
<h4>3.3 注释时使用12个缩进(12 * 4个空格)偏移量</h4>
<p>如果语句大于12个缩进，将注释4-空格对齐(下面的例子)到下一个可用缩进。</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>void</font> my_func(<font color=#00F>void</font>) {
    <font color=#00F>char </font>a, b;
    a = call_func_returning_char_a(a);          <font color=#CCC>/* This is comment with 12*4 spaces indent from beginning of line */</font>
    b = call_func_returning_char_a_but_func_name_is_very_long(a);   <font color=#CCC>/* This is comment, aligned to 4-spaces indent */</font>
}
</pre>
<h3>04 函数定义的规则</h3>
<h4>4.1 每个可以从模块外部访问的函数都必须包含函数原型(或声明)</h4>
<h4>4.2 函数名必须小写，可以用下划线_分隔。（这个原则好像因人而异）</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>void</font> my_func(<font color=#00F>void</font>);
<font color=#00F>void</font> myfunc(<font color=#00F>void</font>);
<font color=#CCC>/* Wrong */</font>
<font color=#00F>void</font> MYFunc(<font color=#00F>void</font>);
<font color=#00F>void</font> myFunc();
</pre>
<h4>4.3 当函数返回指针时，将星号对齐到返回类型</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>const</font> char* my_func(<font color=#00F>void</font>);
my_struct_t* my_func(<font color=#00F>int</font>32_t a, int32_t b);
<font color=#CCC>/* Wrong */</font>
<font color=#00F>const</font> <font color=#00F>char </font>*my_func(<font color=#00F>void</font>);
my_struct_t * my_func(<font color=#00F>void</font>);
</pre>
<h4>4.4 对齐所有的功能原型(使用相同/相似的功能)以提高可读性</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK, function names aligned */</font>
<font color=#00F>void</font>        set(<font color=#00F>int</font>32_t a);
my_type_t   get(<font color=#00F>void</font>);
my_ptr_t*   get_ptr(<font color=#00F>void</font>);
<font color=#CCC>/* Wrong */</font>
<font color=#00F>void</font> set(<font color=#00F>int</font>32_t a);
<font color=#00F>const</font> <font color=#00F>char </font>* get(<font color=#00F>void</font>);
</pre>
<h4>4.5 函数实现必须在单独的行中包含返回类型和可选的其他关键字</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>int</font>32_t
foo(<font color=#00F>void</font>) {
    <font color=#00F>return </font>0;
}
<font color=#CCC>/* OK */</font>
<font color=#00F>static</font> <font color=#00F>const </font>char*
get_string(<font color=#00F>void</font>) {
    <font color=#00F>return </font>"Hello world!\r\n";
}
<font color=#CCC>/* Wrong */</font>
<font color=#00F>int</font>32_t foo(<font color=#00F>void</font>) {
    <font color=#00F>return </font>0;
}
</pre>
<h3>05 变量相关的规则</h3>
<h4>5.1 使变量名全部小写，下划线_字符可选</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>int</font>32_t a;
<font color=#00F>int</font>32_t my_var;
<font color=#00F>int</font>32_t myvar;
<font color=#CCC>/* Wrong */</font>
<font color=#00F>int</font>32_t A;
<font color=#00F>int</font>32_t myVar;
<font color=#00F>int</font>32_t MYVar;
</pre>
<h4>5.2 按类型将局部变量分组在一起</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>void</font> foo(<font color=#00F>void</font>) {
    int32_t a, b;   <font color=#CCC>/* OK */</font>
    <font color=#00F>char </font>a;
    <font color=#00F>char </font>b;         <font color=#CCC>/* Wrong, char type already exists */</font>
}
</pre>
<h4>5.3 不要在第一个可执行语句之后声明变量</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>void</font> foo(<font color=#00F>void</font>) {
    int32_t a;
    a = bar();
    int32_t b;      <font color=#CCC>/* Wrong, there is already executable statement */</font>
}
</pre>
<h4>5.4 你可以在下一个缩进级别中声明新的变量</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
int32_t a, b;
a = foo();
<font color=#00F>if</font> (a) {
    int32_t c, d;   <font color=#CCC>/* OK, c and d are in if-statement scope */</font>
    c = foo();
    int32_t e;      <font color=#CCC>/* Wrong, there was already executable statement inside block */</font>
}
</pre>
<h4>5.5 用星号声明指针变量与类型对齐</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>char</font>* a;
<font color=#CCC>/* Wrong */</font>
<font color=#00F>char</font> *a;
<font color=#00F>char</font> * a;
</pre>
<h4>5.6 当声明多个指针变量时，可以使用星号对变量名进行声明</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>char</font> *p, *n;
</pre>
<h3>06 结构、枚举类型定义</h3>
<h4>6.1 结构名或枚举名必须小写，单词之间有下划线_字符</h4>
<h4>6.2 结构或枚举可以包含typedef关键字</h4>
<h4>6.3 所有结构成员都必须小写</h4>
<h4>6.4 所有枚举成员必须是大写的</h4>
<h4>6.5 结构、枚举必须遵循doxygen文档语法</h4>
<h4>6.6 在声明结构体时，它可以使用以下三种不同的选项之一:</h4>
<p>6.6.1 当结构体仅用名称声明时，它的名称后不能包含_t后缀。</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>struct</font> <font color=#00F>struct</font>_name {
    char* a;
    <font color=#00F>char </font>b;
};
</pre>
<p>6.6.2 当只使用typedef声明结构时，它的名称后面必须包含_t后缀。</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>typedef</font> <font color=#00F>struct </font>{
    char* a;
    <font color=#00F>char </font>b;
} struct_name_t;
</pre>
<p>6.6.3 当结构用name和typedef声明时，它不能包含t作为基本名称，它必须在它的名称后面包含t后缀作为typedef部分。</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>typedef</font> <font color=#00F>struct </font>struct_name {
    char* a;
    <font color=#00F>char </font>b;
    <font color=#00F>char </font>c;
} struct_name_t;
</pre>
<p>错误声明的例子及其建议的纠正：</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* a and b must be separated to 2 lines */</font>
<font color=#CCC>/* Name of structure with typedef must include _t suffix */</font>
<font color=#00F>typedef</font> <font color=#00F>struct </font>{
    int32_t a, b;
} a;
<font color=#CCC>/* Corrected version */</font>
<font color=#00F>typedef</font> <font color=#00F>struct </font>{
    int32_t a;
    int32_t b;
} a_t;
<font color=#CCC>/* Wrong name, it must not include _t suffix */</font>
<font color=#00F>struct</font> name_t {
    int32_t a;
    int32_t b;
};
<font color=#CCC>/* Wrong parameters, must be all uppercase */</font>
<font color=#00F>typedef</font> <font color=#00F>enum </font>{
    MY_ENUM_TESTA,
    my_enum_testb,
} my_enum_t;
</pre>
<h4>6.7 在声明时初始化结构时，使用C99初始化风格</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
a_t a = {
    .a = 4,
    .b = 5,
};
<font color=#CCC>/* Wrong */</font>
a_t a = {1, 2};
</pre>
<h4>6.8 当为函数句柄引入new typedef时，使用_fn后缀</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* Function accepts 2 parameters and returns uint8_t */</font>
<font color=#CCC>/* Name of typedef has `_fn` suffix */</font>
<font color=#00F>typedef</font> uint8_t (*my_func_typedef_fn)(uint8_t p1, <font color=#00F>const </font>char* p2);
</pre>
<h3>07 复合语句规则</h3>
<h4>7.1 每个复合语句必须包括左花括号和右花括号，即使它只包含1个嵌套语句</h4>
<h4>7.2 每个复合语句必须包含单个缩进;嵌套语句时，每个嵌套包含1个缩进大小</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>if</font> (c) {
    do_a();
} <font color=#00F>else </font>{
    do_b();
}
<font color=#CCC>/* Wrong */</font>
<font color=#00F>if</font> (c)
    do_a();
<font color=#00F>else</font>
    do_b();
<font color=#CCC>/* Wrong */</font>
<font color=#00F>if</font> (c) do_a();
<font color=#00F>else</font> do_b();
</pre>
<h4>7.2 在if或if-else-if语句的情况下，else必须与第一条语句的右括号在同一行</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>if</font> (a) {
} <font color=#00F>else </font>if (b) {
} <font color=#00F>else </font>{
}
<font color=#CCC>/* Wrong */</font>
<font color=#00F>if</font> (a) {
}
(<font color=#00F>else</font> {
}
<font color=#CCC>/* Wrong */</font>
<font color=#00F>if</font> (a) {
}
<font color=#00F>else</font>
{
}
</pre>
<h4>7.3 在do-while语句的情况下，while部分必须与do部分的右括号在同一行</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
(<font color=#00F>do</font> {
    int32_t a;
    a = do_a();
    do_b(a);
} <font color=#00F>while </font>(check());
<font color=#CCC>/* Wrong */</font>
<font color=#00F>do</font>
{
<font color=#CCC>/* ... */</font>
} <font color=#00F>while </font>(check());
<font color=#CCC>/* Wrong */</font>
(<font color=#00F>do</font> {
<font color=#CCC>/* ... */</font>
}
<font color=#00F>while</font> (check());
</pre>
<h4>7.4 每一个开括号都需要缩进</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>if</font> (a) {
    do_a();
} <font color=#00F>else </font>{
    do_b();
    <font color=#00F>if</font> (c) {
        do_c();
    }
}
</pre>
<p>不要做没有花括号的复合语句，即使是单个语句。下面的例子展示了一些不好的做法</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>if</font> (a) do_b();
<font color=#00F>else</font> do_c();
<font color=#00F>if</font> (a) do_a(); <font color=#00F>else </font>do_b();
</pre>
<h4>7.5 空while循环、do-while循环或for循环必须包含花括号</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>while</font> (is_register_bit_set()) {}
<font color=#CCC>/* Wrong */</font>
<font color=#00F>while</font> (is_register_bit_set());
<font color=#00F>while</font> (is_register_bit_set()) { }
<font color=#00F>while</font> (is_register_bit_set()) {
}
</pre>
<h4>7.6 如果while(或for、do-while等)为空(嵌入式编程中也可能是这种情况)，请使用空的单行括号</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* Wait for bit to be set in embedded hardware unit
uint32_t* addr = HW_PERIPH_REGISTER_ADDR;
</font><font color=#CCC>/* Wait bit 13 to be ready */</font>
<font color=#00F>while</font> (*addr & (1 &lt;&lt; 13)) {}        <font color=#CCC>/* OK, empty loop contains no spaces inside curly brackets */</font>
<font color=#00F>while</font> (*addr & (1 &lt;&lt; 13)) { }       <font color=#CCC>/* Wrong */</font>
<font color=#00F>while</font> (*addr & (1 &lt;&lt; 13)) {         <font color=#CCC>/* Wrong */</font>
}
<font color=#00F>while</font> (*addr & (1 &lt;&lt; 13));          <font color=#CCC>/* Wrong, curly brackets are missing. Can lead to compiler warnings or unintentional bugs */</font>
</pre>
<h4>7.7 尽量避免在循环块内递增变量</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* Not recommended */</font>
<font color=#00F>int</font>32_t a = 0;
<font color=#00F>while</font> (a &lt; 10) {
    .
    ..
    ...
    ++a;
}
<font color=#CCC>/* Better */</font>
<font color=#00F>for</font> (size_t a = 0; a &lt; 10; ++a) {
}
<font color=#CCC>/* Better, if inc may not happen in every cycle */</font>
<font color=#00F>for</font> (size_t a = 0; a &lt; 10; ) {
    <font color=#00F>if </font>(...) {
        ++a;
    }
}
</pre>
<h3>08 分支语句规则</h3>
<h4>8.1 为每个case语句添加单个缩进</h4>
<h4>8.2 使用额外的单缩进break语句在每个case或default</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK, every case has single indent */</font>
<font color=#CCC>/* OK, every break has additional indent */</font>
<font color=#00F>switch</font> (check()) {
    <font color=#00F>case </font>0:
        do_a();
        break;
    <font color=#00F>case </font>1:
        do_b();
        break;
    default:
        break;
}
<font color=#CCC>/* Wrong, case indent missing */</font>
<font color=#00F>switch</font> (check()) {
<font color=#00F>case</font> 0:
    do_a();
    break;
<font color=#00F>case</font> 1:
    do_b();
    break;
<font color=#00F>default</font>:
    break;
}
<font color=#CCC>/* Wrong */</font>
<font color=#00F>switch</font> (check()) {
    <font color=#00F>case </font>0:
        do_a();
    break;      <font color=#CCC>/* Wrong, break must have indent as it is under case */</font>
    <font color=#00F>case </font>1:
    do_b();     <font color=#CCC>/* Wrong, indent under case is missing */</font>
    break;
    default:
        break;
}
</pre>
<h4>8.3 总是包含default语句</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#00F>switch</font> (var) {
    <font color=#00F>case </font>0:
        do_job();
        break;
    default: break;
}
<font color=#CCC>/* Wrong, default is missing */</font>
<font color=#00F>switch</font> (var) {
    <font color=#00F>case </font>0:
        do_job();
        break;
}
</pre>
<h4>8.4 如果需要局部变量，则使用花括号并在里面放入break语句。将左花括号放在case语句的同一行</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>switch</font> (a) {
    <font color=#CCC>/* OK */</font>
    <font color=#00F>case </font>0: {
        int32_t a, b;
        <font color=#00F>char </font>c;
        a = 5;
        <font color=#CCC>/* ... */</font>
        break;
    }
    <font color=#CCC>/* Wrong */</font>
    <font color=#00F>case </font>1:
    {
        int32_t a;
        break;
    }
    <font color=#CCC>/* Wrong, break shall be inside */</font>
    <font color=#00F>case </font>2: {
        int32_t a;
    }
    break;
}
</pre>
<h3>09 宏和预处理指令</h3>
<h4>9.1 总是使用宏而不是文字常量，特别是对于数字</h4>
<h4>9.2 所有的宏必须是全大写的，并带有下划线_字符(可选)，除非它们被明确标记为function，将来可能会被常规函数语法替换</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#C00>#define</font> MY_MACRO(x)         ((x) * (x))
<font color=#CCC>/* Wrong */</font>
<font color=#C00>#define</font> square(x)           ((x) * (x))
</pre>
<h4>9.3 总是用圆括号保护输入参数</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#C00>#define</font> MIN(x, y)           ((x) &lt; (y) ? (x) : (y))
<font color=#CCC>/* Wrong */</font>
<font color=#C00>#define</font> MIN(x, y)           x &lt; y ? x : y
</pre>
<h4>9.4 总是用括号保护最终的宏计算</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* Wrong */</font>
<font color=#C00>#define</font> MIN(x, y)           (x) &lt; (y) ? (x) : (y)
<font color=#C00>#define</font> SUM(x, y)           (x) + (y)
<font color=#CCC>/* Imagine result of this equation using wrong SUM implementation */</font>
<font color=#00F>int</font>32_t x = 5 * SUM(3, 4);  <font color=#CCC>/* Expected result is 5 * 7 = 35 */</font>
<font color=#00F>int</font>32_t x = 5 * (3) + (4);  <font color=#CCC>/* It is evaluated to this, final result = 19 which is not what we expect */</font>
<font color=#CCC>/* Correct implementation */</font>
<font color=#C00>#define</font> MIN(x, y)           ((x) &lt; (y) ? (x) : (y))
<font color=#C00>#define</font> SUM(x, y)           ((x) + (y))
</pre>
<h4>9.5 当宏使用多个语句时，使用do-while(0)语句保护它</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#00F>typedef</font> <font color=#00F>struct </font>{
    int32_t px, py;
} point_t;
point_t p;                  <font color=#CCC>/* Define new point */</font>
<font color=#CCC>/* Wrong implementation */</font>
<font color=#CCC>/* Define macro to set point */</font>
<font color=#C00>#define</font> SET_POINT(p, x, y)  (p)->px = (x); (p)->py = (y)    <font color=#CCC>/* 2 statements. Last one should not implement semicolon */</font>
SET_POINT(&p, 3, 4);        <font color=#CCC>/* Set point to position 3, 4. This evaluates to... */</font>
(&p)->px = (3); (&p)->py = (4); <font color=#CCC>/* ... to this. In this example this is not a problem. */</font>
<font color=#CCC>/* Consider this ugly code, however it is valid by C standard (not recommended) */</font>
<font color=#00F>if</font> (a)                      <font color=#CCC>/* If a is true */</font>
    <font color=#00F>if </font>(b)                  <font color=#CCC>/* If b is true */</font>
        SET_POINT(&p, 3, 4);<font color=#CCC>/* Set point to x = 3, y = 4 */</font>
    else
        SET_POINT(&p, 5, 6);<font color=#CCC>/* Set point to x = 5, y = 6 */</font>
<font color=#CCC>/* Evaluates to code below. Do you see the problem? */</font>
<font color=#00F>if</font> (a)
    <font color=#00F>if </font>(b)
        (&p)->px = (3); (&p)->py = (4);
    else
        (&p)->px = (5); (&p)->py = (6);
<font color=#CCC>/* Or if we rewrite it a little */</font>
<font color=#00F>if</font> (a)
    <font color=#00F>if </font>(b)
        (&p)->px = (3);
        (&p)->py = (4);
    else
        (&p)->px = (5);
        (&p)->py = (6);
<font color=#CCC>/*
 * Ask yourself a question: To which `if` statement `else` keyword belongs?
 *
 * Based on first part of code, answer is straight-forward. To inner `if` statement when we check `b` condition
 * Actual answer: Compilation error as `else` belongs nowhere
 */</font>
<font color=#CCC>/* Better and correct implementation of macro */</font>
<font color=#C00>#define</font> SET_POINT(p, x, y)  <font color=#00F>do </font>{ (p)->px = (x); (p)->py = (y); } <font color=#00F>while </font>(0)    <font color=#CCC>/* 2 statements. No semicolon after while loop */</font>
<font color=#CCC>/* Or even better */</font>
<font color=#C00>#define</font> SET_POINT(p, x, y)  <font color=#00F>do </font>{    \   <font color=#CCC>/* Backslash indicates statement continues in new line */</font>
    (p)->px = (x);                  \
    (p)->py = (y);                  \
} <font color=#00F>while </font>(0)                             <font color=#CCC>/* 2 statements. No semicolon after while loop */</font>
<font color=#CCC>/* Now original code evaluates to */</font>
<font color=#00F>if</font> (a)
    <font color=#00F>if </font>(b)
        <font color=#00F>do </font>{ (&p)->px = (3); (&p)->py = (4); } <font color=#00F>while </font>(0);
    else
        <font color=#00F>do </font>{ (&p)->px = (5); (&p)->py = (6); } <font color=#00F>while </font>(0);
<font color=#CCC>/* Every part of `if` or `else` contains only `1` inner statement (do-while), hence this is valid evaluation */</font>
<font color=#CCC>/* To make code perfect, use brackets for every if-ifelse-else statements */</font>
<font color=#00F>if</font> (a) {                    <font color=#CCC>/* If a is true */</font>
    <font color=#00F>if </font>(b) {                <font color=#CCC>/* If b is true */</font>
        SET_POINT(&p, 3, 4);<font color=#CCC>/* Set point to x = 3, y = 4 */</font>
    } <font color=#00F>else </font>{
        SET_POINT(&p, 5, 6);<font color=#CCC>/* Set point to x = 5, y = 6 */</font>
    }
}
</pre>
<h4>9.5 不缩进子语句内#if语句</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* OK */</font>
<font color=#C00>#if</font> defined(XYZ)
<font color=#C00>#if</font> defined(ABC)
<font color=#CCC>/* do when ABC defined */</font>
<font color=#C00>#endif</font> <font color=#CCC>/* defined(ABC) */</font>
<font color=#C00>#else</font> <font color=#CCC>/* defined(XYZ) */</font>
<font color=#CCC>/* Do when XYZ not defined */</font>
<font color=#C00>#endif</font> <font color=#CCC>/* !defined(XYZ) */</font>
<font color=#CCC>/* Wrong */</font>
<font color=#C00>#if</font> defined(XYZ)
   <font color=#C00> #if</font> defined(ABC)
        <font color=#CCC>/* do when ABC defined */</font>
   <font color=#C00> #endif</font> <font color=#CCC>/* defined(ABC) */</font>
<font color=#C00>#else</font> <font color=#CCC>/* defined(XYZ) */</font>
    <font color=#CCC>/* Do when XYZ not defined */</font>
<font color=#C00>#endif</font> <font color=#CCC>/* !defined(XYZ) */</font>
</pre>
<h3>10 文档</h3>
<h4>10.1 文档化的代码允许doxygen解析和通用的html/pdf/latex输出，因此正确地执行是非常重要的。</h4>
<h4>10.2 对变量、函数和结构/枚举使用doxygen支持的文档样式</h4>
<h4>10.3 经常使用\作为doxygen，不要使用@</h4>
<h4>10.4 始终使用5x4空格(5个制表符)作为文本行开始的偏移量</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/**
 * \brief           Holds pointer to first entry in linked list
 *                  Beginning of this text is 5 tabs (20 spaces) from beginning of line
 */</font>
<font color=#00F>static</font>
type_t* list;
</pre>
<h4>10.5 每个结构/枚举成员都必须包含文档</h4>
<h4>10.6 注释的开头使用12x4空格偏移量</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/**
 * \brief           This is point struct
 * \note            This structure is used to calculate all point
 *                      related stuff
 */</font>
<font color=#00F>typedef</font> <font color=#00F>struct </font>{
    int32_t x;                                  <font color=#CCC>/*!&lt; Point X coordinate */</font>
    int32_t y;                                  <font color=#CCC>/*!&lt; Point Y coordinate */</font>
    int32_t size;                               <font color=#CCC>/*!&lt; Point size.
                                                    Since comment is very big,
                                                    you may go to next line */</font>
} point_t;
<font color=#CCC>/**
 * \brief           Point color enumeration
 */</font>
<font color=#00F>typedef</font> <font color=#00F>enum </font>{
    COLOR_RED,                                  <font color=#CCC>/*!&lt; Red color. This comment has 12x4
                                                    spaces offset from beginning of line */</font>
    COLOR_GREEN,                                <font color=#CCC>/*!&lt; Green color */</font>
    COLOR_BLUE,                                 <font color=#CCC>/*!&lt; Blue color */</font>
} point_color_t;
</pre>
<h4>10.7 函数的文档必须在函数实现中编写(通常是源文件)</h4>
<h4>10.8 函数必须包括简要和所有参数文档</h4>
<h4>10.9 如果每个参数分别为in或out输入和输出，则必须注意</h4>
<h4>10.10 如果函数返回某个值，则必须包含返回形参。这不适用于void函数</h4>
<h4>10.11 函数可以包含其他doxygen关键字，如note或warning</h4>
<h4>10.12 在参数名和描述之间使用冒号:</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/**
 * \brief           Sum `2` numbers
 * \param[in]       a: First number
 * \param[in]       b: Second number
 * \return          Sum of input values
 */</font>
<font color=#00F>int</font>32_t
sum(<font color=#00F>int</font>32_t a, int32_t b) {
    <font color=#00F>return </font>a + b;
}
<font color=#CCC>/**
 * \brief           Sum `2` numbers and write it to pointer
 * \note            This function does not return value, it stores it to pointer instead
 * \param[in]       a: First number
 * \param[in]       b: Second number
 * \param[out]      result: Output variable used to save result
 */</font>
<font color=#00F>void</font>
<font color=#00F>void</font>_sum(<font color=#00F>int</font>32_t a, int32_t b, int32_t* result) {
    *result = a + b;
}
</pre>
<h4>10.13 如果函数返回枚举的成员，则使用ref关键字指定哪个成员</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/**
 * \brief           My enumeration
 */</font>
<font color=#00F>typedef</font> <font color=#00F>enum </font>{
    MY_ERR,                                     <font color=#CCC>/*!&lt; Error value */</font>
    MY_OK                                       <font color=#CCC>/*!&lt; OK value */</font>
} my_enum_t;
<font color=#CCC>/**
 * \brief           Check some value
 * \return          \ref MY_OK on success, member of \ref my_enum_t otherwise
 */</font>
my_enum_t
check_value(<font color=#00F>void</font>) {
    <font color=#00F>return </font>MY_OK;
}
</pre>
<h4>10.14 对常量或数字使用符号(' NULL ' => NULL)</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/**
 * \brief           Get data from input array
 * \param[in]       in: Input data
 * \return          Pointer to output data on success, `NULL` otherwise
 */</font>
<font color=#00F>const</font> <font color=#00F>void </font>*
get_data(<font color=#00F>const</font> void* in) {
    <font color=#00F>return </font>in;
}
</pre>
<h4>10.15 宏的文档必须包括hideinitializer doxygen命令</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/**
 * \brief           Get minimal value between `x` and `y`
 * \param[in]       x: First value
 * \param[in]       y: Second value
 * \return          Minimal value between `x` and `y`
 * \hideinitializer
 */</font>
<font color=#C00>#define</font> MIN(x, y)       ((x) &lt; (y) ? (x) : (y))
</pre>
<h3>11 头/源文件</h3>
<h4>11.1 在文件末尾留下一个空行</h4>
<h4>11.2 每个文件都必须包括文件的doxygen注释和后跟空行的简要描述(使用doxygen时)</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/**
 * \file            template.h
 * \brief           Template include file
 */</font>
                    <font color=#CCC>/* Here is empty line */</font>
</pre>
<h4>11.3 每个文件(头文件或源文件)必须包含许可证(开始注释包括单个星号，因为doxygen必须忽略这个)</h4>
<h4>11.4 使用与项目、库已经使用的相同的许可证</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/**
 * \file            template.h
 * \brief           Template include file
 */</font>
<font color=#CCC>/*
 * Copyright (c) year FirstName LASTNAME
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * This file is part of library_name.
 *
 * Author:          FirstName LASTNAME &lt;optional_email@example.com>
 */</font>
</pre>
<h4>11.5 头文件必须包含保护符#ifndef</h4>
<h4>11.6 头文件必须包含c++检查</h4>
<h4>11.7 在c++检查之外包含外部头文件</h4>
<h4>11.8 首先用STL C文件包含外部头文件，然后是应用程序自定义文件</h4>
<h4>11.9 头文件必须包含其他所有头文件，以便正确编译，但不能包含更多头文件(如果需要，.c应该包含其余的头文件)</h4>
<h4>11.10头文件必须只公开模块公共变量/类型/函数</h4>
<h4>11.11 在头文件中使用extern作为全局模块变量，稍后在源文件中定义它们</h4>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* file.h ... */</font>
<font color=#C00>#ifndef</font> ...
<font color=#00F>extern</font> int32_t my_variable; <font color=#CCC>/* This is global variable declaration in header */</font>
<font color=#C00>#endif</font>
<font color=#CCC>/* file.c ... */</font>
<font color=#00F>int</font>32_t my_variable;        <font color=#CCC>/* Actually defined in source */</font>
</pre>
<h4>11.12 不要把.c文件包含在另一个.c文件中</h4>
<h4>11.13 .c文件应该首先包含相应的.h文件，然后是其他文件，除非另有明确的必要</h4>
<h4>11.14 在头文件中不包含模块私有声明</h4>
<p>头文件示例(示例中没有license)</p>
<p></p>
<pre style="line-height:130%; background-color:#F6F6F6; font-size:120%; padding:8px; margin-left:2em; color:black; ">
<font color=#CCC>/* License comes here */</font>
<font color=#C00>#ifndef</font> TEMPLATE_HDR_H
<font color=#C00>#define</font> TEMPLATE_HDR_H
<font color=#CCC>/* Include headers */</font>
<font color=#C00>#ifdef</font> __cplusplus
<font color=#00F>extern</font> "C" {
<font color=#C00>#endif</font> <font color=#CCC>/* __cplusplus */</font>
<font color=#CCC>/* File content here */</font>
<font color=#C00>#ifdef</font> __cplusplus
}
<font color=#C00>#endif</font> <font color=#CCC>/* __cplusplus */</font>
<font color=#C00>#endif</font> <font color=#CCC>/* TEMPLATE_HDR_H */</font>
</pre>
<p>END</p>
<p><a href="www.toutiao.com/i6949933402917306893" title="">原文链接：</a></p>
<p>www.toutiao.com/i6949933402917306893</p>
<p><a href="https://mp.weixin.qq.com/s/RR5udZvJUIAzG860Hxcnqg" title="">文章链接：</a></p>
<p>https://mp.weixin.qq.com/s/RR5udZvJUIAzG860Hxcnqg</p>


<p style='float:right;'>本页共979段，42240个字符，48511 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
