<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>CPP标准库</h3>


<p>C&#43;&#43;标准库的内容分为10类&#xff0c;分别是&#xff08;建议在阅读中&#xff0c;将你已经用过或听说过的头文件划出来&#xff09;&#xff1a;</p>
<p>C1. 标准库中与语言支持功能相关的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><thead><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr></thead><tbody><tr><td> <p>&lt;cstddef&gt;</p> </td><td> <p>定义宏NULL和offsetof&#xff0c;以及其他标准类型size_t和ptrdiff_t。与对应的标准C头文件的区别是&#xff0c;NULL是C&#43;&#43;空指针常量的补充定义&#xff0c;宏offsetof接受结构或者联合类型参数&#xff0c;只要他们没有成员指针类型的非静态成员即可。</p> </td></tr><tr><td> <p>&lt;limits&gt;</p> </td><td> <p>提供与基本数据类型相关的定义。例如&#xff0c;对于每个数值数据类型&#xff0c;它定义了可以表示出来的最大值和最小值以及二进制数字的位数。</p> </td></tr><tr><td> <p>&lt;climits&gt;</p> </td><td> <p>提供与基本整数数据类型相关的C样式定义。这些信息的C&#43;&#43;样式定义在&lt;limits&gt;中</p> </td></tr><tr><td> <p>&lt;cfloat&gt;</p> </td><td> <p>提供与基本浮点型数据类型相关的C样式定义。这些信息的C&#43;&#43;样式定义在&lt;limits&gt;中</p> </td></tr><tr><td> <p>&lt;cstdlib&gt;</p> </td><td> <p>提供支持程序启动和终止的宏和函数。这个头文件还声明了许多其他杂项函数&#xff0c;例如搜索和排序函数&#xff0c;从字符串转换为数值等函数。它与对应的标准C头文件stdlib.h不同&#xff0c;定义了abort(void)。abort()函数还有额外的功能&#xff0c;它不为静态或自动对象调用析构函数&#xff0c;也不调用传给atexit()函数的函数。它还定义了exit()函数的额外功能&#xff0c;可以释放静态对象&#xff0c;以注册的逆序调用用atexit()注册的函数。清除并关闭所有打开的C流&#xff0c;把控制权返回给主机环境。</p> </td></tr><tr><td> <p>&lt;new&gt;</p> </td><td> <p>支持动态内存分配</p> </td></tr><tr><td> <p>&lt;typeinfo&gt;</p> </td><td> <p>支持变量在运行期间的类型标识</p> </td></tr><tr><td> <p>&lt;exception&gt;</p> </td><td> <p>支持异常处理&#xff0c;这是处理程序中可能发生的错误的一种方式</p> </td></tr><tr><td> <p>&lt;cstdarg&gt;</p> </td><td> <p>支持接受数量可变的参数的函数。即在调用函数时&#xff0c;可以给函数传送数量不等的数据项。它定义了宏va_arg、va_end、va_start以及va_list类型</p> </td></tr><tr><td> <p>&lt;csetjmp&gt;</p> </td><td> <p>为C样式的非本地跳跃提供函数。这些函数在C&#43;&#43;中不常用</p> </td></tr><tr><td> <p>&lt;csignal&gt;</p> </td><td> <p>为中断处理提供C样式支持</p> </td></tr></tbody></table>
<p>C2. 支持流输入/输出的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr><tr><td> <p>&lt;iostream&gt;</p> </td><td> <p>支持标准流cin、cout、cerr和clog的输入和输出&#xff0c;它还支持多字节字符标准流wcin、wcout、wcerr和wclog。</p> </td></tr><tr><td> <p>&lt;iomanip&gt;</p> </td><td> <p>提供操纵程序&#xff0c;允许改变流的状态&#xff0c;从而改变输出的格式。</p> </td></tr><tr><td> <p>&lt;ios&gt;</p> </td><td> <p>定义iostream的基类</p> </td></tr><tr><td> <p>&lt;istream&gt;</p> </td><td> <p>为管理输出流缓存区的输入定义模板类</p> </td></tr><tr><td> <p>&lt;ostream&gt;</p> </td><td> <p>为管理输出流缓存区的输出定义模板类</p> </td></tr><tr><td> <p>&lt;sstream&gt;</p> </td><td> <p>支持字符串的流输入输出</p> </td></tr><tr><td> <p>&lt;fstream&gt;</p> </td><td> <p>支持文件的流输入输出</p> </td></tr><tr><td> <p>&lt;iosfwd&gt;</p> </td><td> <p>为输入输出对象提供向前的声明</p> </td></tr><tr><td> <p>&lt;streambuf&gt;</p> </td><td> <p>支持流输入和输出的缓存</p> </td></tr><tr><td> <p>&lt;cstdio&gt;</p> </td><td> <p>为标准流提供C样式的输入和输出</p> </td></tr><tr><td> <p>&lt;cwchar&gt;</p> </td><td> <p>支持多字节字符的C样式输入输出</p> </td></tr></tbody></table>
<p>C3. 与诊断功能相关的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr><tr><td> <p>&lt;stdexcept&gt;</p> </td><td> <p>定义标准异常。异常是处理错误的方式</p> </td></tr><tr><td> <p>&lt;cassert&gt;</p> </td><td> <p>定义断言宏&#xff0c;用于检查运行期间的情形</p> </td></tr><tr><td> <p>&lt;cerrno&gt;</p> </td><td> <p>支持C样式的错误信息</p> </td></tr></tbody></table>
<p>C4. 定义工具函数的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr><tr><td> <p>&lt;utility&gt;</p> </td><td> <p>定义重载的关系运算符&#xff0c;简化关系运算符的写入&#xff0c;它还定义了pair类型&#xff0c;该类型是一种模板类型&#xff0c;可以存储一对值。这些功能在库的其他地方使用</p> </td></tr><tr><td> <p>&lt;functional&gt;</p> </td><td> <p>定义了许多函数对象类型和支持函数对象的功能&#xff0c;函数对象是支持operator()()函数调用运算符的任意对象</p> </td></tr><tr><td> <p>&lt;memory&gt;</p> </td><td> <p>给容器、管理内存的函数和auto_ptr模板类定义标准内存分配器</p> </td></tr><tr><td> <p>&lt;ctime&gt;</p> </td><td> <p>支持系统时钟函数</p> </td></tr></tbody></table>
<p>C5. 支持字符串处理的头文件</p>
<table width="669" border="1" cellpadding="0" cellspacing="0"><thead><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr></thead><tbody><tr><td> <p>&lt;string&gt;</p> </td><td> <p>为字符串类型提供支持和定义&#xff0c;包括单字节字符串(由char组成)的string和多字节字符串(由wchar_t组成)</p> </td></tr><tr><td> <p>&lt;cctype&gt;</p> </td><td> <p>单字节字符类别</p> </td></tr><tr><td> <p>&lt;cwctype&gt;</p> </td><td> <p>多字节字符类别</p> </td></tr><tr><td> <p>&lt;cstring&gt;</p> </td><td> <p>为处理非空字节序列和内存块提供函数。这不同于对应的标准C库头文件&#xff0c;几个C样式字符串的一般C库函数被返回值为const和非const的函数对替代了</p> </td></tr><tr><td> <p>&lt;cwchar&gt;</p> </td><td> <p>为处理、执行I/O和转换多字节字符序列提供函数&#xff0c;这不同于对应的标准C库头文件&#xff0c;几个多字节C样式字符串操作的一般C库函数被返回值为const和非const的函数对替代了。</p> </td></tr><tr><td> <p>&lt;cstdlib&gt;</p> </td><td> <p>为把单字节字符串转换为数值、在多字节字符和多字节字符串之间转换提供函数</p> </td></tr></tbody></table>
<p>C6. 定义容器类的模板的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr><tr><td> <p>&lt;vector&gt;</p> </td><td> <p>定义vector序列模板&#xff0c;这是一个大小可以重新设置的数组类型&#xff0c;比普通数组更安全、更灵活</p> </td></tr><tr><td> <p>&lt;list&gt;</p> </td><td> <p>定义list序列模板&#xff0c;这是一个序列的链表&#xff0c;常常在任意位置插入和删除元素</p> </td></tr><tr><td> <p>&lt;deque&gt;</p> </td><td> <p>定义deque序列模板&#xff0c;支持在开始和结尾的高效插入和删除操作</p> </td></tr><tr><td> <p>&lt;queue&gt;</p> </td><td> <p>为队列(先进先出)数据结构定义序列适配器queue和priority_queue</p> </td></tr><tr><td> <p>&lt;stack&gt;</p> </td><td> <p>为堆栈(后进先出)数据结构定义序列适配器stack</p> </td></tr><tr><td> <p>&lt;map&gt;</p> </td><td> <p>map是一个关联容器类型&#xff0c;允许根据键值是唯一的&#xff0c;且按照升序存储。multimap类似于map&#xff0c;但键不是唯一的。</p> </td></tr><tr><td> <p>&lt;set&gt;</p> </td><td> <p>set是一个关联容器类型&#xff0c;用于以升序方式存储唯一值。multiset类似于set&#xff0c;但是值不必是唯一的。</p> </td></tr><tr><td> <p>&lt;bitset&gt;</p> </td><td> <p>为固定长度的位序列定义bitset模板&#xff0c;它可以看作固定长度的紧凑型bool数组</p> </td></tr></tbody></table>
<p>C7. 支持迭代器的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr><tr><td> <p>&lt;iterator&gt;</p> </td><td> <p>给迭代器提供定义和支持</p> </td></tr></tbody></table>
<p>C8. 有关算法的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr><tr><td> <p>&lt;algorithm&gt;</p> </td><td> <p>提供一组基于算法的函数&#xff0c;包括置换、排序、合并和搜索</p> </td></tr><tr><td> <p>&lt;cstdlib&gt;</p> </td><td> <p>声明C标准库函数bsearch()和qsort()&#xff0c;进行搜索和排序</p> </td></tr><tr><td> <p>&lt;ciso646&gt;</p> </td><td> <p>允许在代码中使用and代替&amp;&amp;</p> </td></tr></tbody></table>
<p>C9. 有关数值操作的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr><tr><td> <p>&lt;complex&gt;</p> </td><td> <p>支持复杂数值的定义和操作</p> </td></tr><tr><td> <p>&lt;valarray&gt;</p> </td><td> <p>支持数值矢量的操作</p> </td></tr><tr><td> <p>&lt;numeric&gt;</p> </td><td> <p>在数值序列上定义一组一般数学操作&#xff0c;例如accumulate和inner_product</p> </td></tr><tr><td> <p>&lt;cmath&gt;</p> </td><td> <p>这是C数学库&#xff0c;其中还附加了重载函数&#xff0c;以支持C&#43;&#43;约定</p> </td></tr><tr><td> <p>&lt;cstdlib&gt;</p> </td><td> <p>提供的函数可以提取整数的绝对值&#xff0c;对整数进行取余数操作</p> </td></tr></tbody></table>
<p>C10. 有关本地化的头文件</p>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center">头文件</p> </td><td> <p align="center">描述</p> </td></tr><tr><td> <p>&lt;locale&gt;</p> </td><td> <p>提供的本地化包括字符类别、排序序列以及货币和日期表示。</p> </td></tr><tr><td> <p>&lt;clocale&gt;</p> </td><td> <p>对本地化提供C样式支持</p> </td></tr></tbody></table>
<p>C&#43;&#43;标准库的所有头文件都没有扩展名。C&#43;&#43;标准库以&lt;cname&gt;形式的标准头文件提供。在 &lt;cname&gt;形式标准的头文件中&#xff0c;与宏相关的名称在全局作用域中定义&#xff0c;其他名称在std命名空间中声明。在C&#43;&#43;中还可以使用name.h形式的标准C库头文件名。</p>
<p><br /> </p>

<p><br /> </p> 
<p>　　二、标准模板库STL简介<a href="#_ftn1" name="_ftnref1" title="">[1]</a> </p> 
<p>　　STL&#xff08;Standard Template Library&#xff0c;标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C&#43;&#43;中&#xff0c;但在被引入C&#43;&#43;之前该技术就已经存在了很长的一段时间。</p> 
<p>　　STL的代码从广义上讲分为三类&#xff1a;algorithm&#xff08;算法&#xff09;、container&#xff08;容器&#xff09;和iterator&#xff08;迭代器&#xff09;&#xff0c;几乎所有的代码都采用了模板类和模版函数的方式&#xff0c;这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C&#43;&#43;标准中&#xff0c;STL被组织为下面的13个头文件&#xff1a;&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt;和&lt;utility&gt;。</p> 
<p>　　1、算法</p> 
<p>　　函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说&#xff0c;一个求方根的函数&#xff0c;在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C&#43;&#43;通过模板的机制允许推迟对某些类型的选择&#xff0c;直到真正想使用模板或者说对模板进行特化的时候&#xff0c;STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——可以将所有的类型划分为少数的几类&#xff0c;然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。</p> 
<p>　　STL提供了大约100个实现算法的模版函数&#xff0c;比如算法for_each将为指定序列中的每一个元素调用指定的函数&#xff0c;stable_sort以你所指定的规则对序列进行稳定性排序等等。这样一来&#xff0c;只要熟悉了STL之后&#xff0c;许多代码可以被大大的化简&#xff0c;只需要通过调用一两个算法模板&#xff0c;就可以完成所需要的功能并大大地提升效率。</p> 
<p>　　算法部分主要由头文件&lt;algorithm&gt;&#xff0c;&lt;numeric&gt;和&lt;functional&gt;组成。&lt;algorithm&gt;是所有STL头文件中最大的一个&#xff08;尽管它很好理解&#xff09;&#xff0c;它是由一大堆模版函数组成的&#xff0c;可以认为每个函数在很大程度上都是独立的&#xff0c;其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。&lt;numeric&gt;体积很小&#xff0c;只包括几个在序列上面进行简单数学运算的模板函数&#xff0c;包括加法和乘法在序列上的一些操作。&lt;functional&gt;中则定义了一些模板类&#xff0c;用以声明函数对象。</p> 
<p>　　2、容器</p> 
<p>　　在实际的开发过程中&#xff0c;数据结构本身的重要性不会逊于操作于数据结构的算法的重要性&#xff0c;当程序中存在着对时间要求很高的部分时&#xff0c;数据结构的选择就显得更加重要。</p> 
<p>　　经典的数据结构数量有限&#xff0c;但是我们常常重复着一些为了实现向量、链表等结构而编写的代码&#xff0c;这些代码都十分相似&#xff0c;只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便&#xff0c;它允许我们重复利用已有的实现构造自己的特定类型下的数据结构&#xff0c;通过设置一些模版类&#xff0c;STL容器对最常用的数据结构提供了支持&#xff0c;这些模板的参数允许我们指定容器中元素的数据类型&#xff0c;可以将我们许多重复而乏味的工作简化。</p> 
<p>　　容器部分主要由头文件&lt;vector&gt;,&lt;list&gt;,&lt;deque&gt;,&lt;set&gt;,&lt;map&gt;,&lt;stack&gt;和&lt;queue&gt;组成。对于常用的一些容器和容器适配器&#xff08;可以看作由其它容器实现的容器&#xff09;&#xff0c;可以通过下表总结一下它们和相应头文件的对应关系。</p> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <p align="center"><span style="color:black">数据结构</span></p> </td><td> <p align="center"><span style="color:black">描述</span></p> </td><td> <p align="center"><span style="color:black">实现头文件</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">向量</span><span style="color:black">(vector)</span></p> </td><td> <p align="left"><span style="color:black">连续存储的元素</span></p> </td><td> <p align="left"><span style="color:black">&lt;vector&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">列表</span><span style="color:black">(list)</span></p> </td><td> <p align="left"><span style="color:black">由节点组成的双向链表&#xff0c;每个结点包含着一个元素</span></p> </td><td> <p align="left"><span style="color:black">&lt;list&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">双队列</span><span style="color:black">(deque)</span></p> </td><td> <p align="left"><span style="color:black">连续存储的指向不同元素的指针所组成的数组</span></p> </td><td> <p align="left"><span style="color:black">&lt;deque&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">集合</span><span style="color:black">(set)</span></p> </td><td> <p align="left"><span style="color:black">由节点组成的红黑树&#xff0c;每个节点都包含着一个元素&#xff0c;节点之间以某种作用于元素对的谓词排列&#xff0c;没有两个不同的元素能够拥有相同的次序</span></p> </td><td> <p align="left"><span style="color:black">&lt;set&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">多重集合</span><span style="color:black">(multiset)</span></p> </td><td> <p align="left"><span style="color:black">允许存在两个次序相等的元素的集合</span></p> </td><td> <p align="left"><span style="color:black">&lt;set&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">栈</span><span style="color:black">(stack)</span></p> </td><td> <p align="left"><span style="color:black">后进先出的值的排列</span></p> </td><td> <p align="left"><span style="color:black">&lt;stack&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">队列</span><span style="color:black">(queue)</span></p> </td><td> <p align="left"><span style="color:black">先进先出的执的排列</span></p> </td><td> <p align="left"><span style="color:black">&lt;queue&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">优先队列</span><span style="color:black">(priority_queue)</span></p> </td><td> <p align="left"><span style="color:black">元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列</span></p> </td><td> <p align="left"><span style="color:black">&lt;queue&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">映射</span><span style="color:black">(map)</span></p> </td><td> <p align="left"><span style="color:black">由</span><span style="color:black">{<!-- --></span><span style="color:black">键&#xff0c;值</span><span style="color:black">}</span><span style="color:black">对组成的集合&#xff0c;以某种作用于键对上的谓词排列</span></p> </td><td> <p align="left"><span style="color:black">&lt;map&gt;</span></p> </td></tr><tr><td> <p align="left"><span style="color:black">多重映射</span><span style="color:black">(multimap)</span></p> </td><td> <p align="left"><span style="color:black">允许键对有相等的次序的映射</span></p> </td><td> <p align="left"><span style="color:black">&lt;map&gt;</span></p> </td></tr></tbody></table> 
<p>　　3、迭代器</p> 
<p>　　迭代器从作用上来说是最基本的部分&#xff0c;可是理解起来比前两者都要费力一些。软件设计有一个基本原则&#xff0c;所有的问题都可以通过引进一个间接层来简化&#xff0c;这种简化在STL中就是用迭代器来完成的。概括来说&#xff0c;迭代器在STL中用来将算法和容器联系起来&#xff0c;起着一种黏和剂的作用。几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的&#xff0c;每一个容器都定义了其本身所专有的迭代器&#xff0c;用以存取容器中的元素。</p> 
<p>　　迭代器部分主要由头文件&lt;utility&gt;,&lt;iterator&gt;和&lt;memory&gt;组成。&lt;utility&gt;是一个很小的头文件&#xff0c;它包括了贯穿使用在STL中的几个模板的声明&#xff0c;&lt;iterator&gt;中提供了迭代器使用的许多方法&#xff0c;而对于&lt;memory&gt;的描述则十分的困难&#xff0c;它以不同寻常的方式为容器中的元素分配存储空间&#xff0c;同时也为某些算法执行期间产生的临时对象提供机制,&lt;memory&gt;中的主要部分是模板类allocator&#xff0c;它负责产生所有容器中的默认分配器。</p> 
<p><br /> </p> 
<p>　　三、后记</p> 
<p>　　对于STL的使用&#xff0c;也普遍存在着两种观点。第一种认为STL的最大作用在于充当经典的数据结构和算法教材&#xff0c;因为它的源代码涉及了许多具体实现方面的问题。第二种则认为STL的初衷乃是为了简化设计&#xff0c;避免重复劳动&#xff0c;提高编程效率&#xff0c;因此应该是“应用至上”的&#xff0c;对于源代码则不必深究。对于初学者而言&#xff0c;通过分析源代码&#xff0c;提高对其应用的理解其意义也不同凡响。</p> 　　曾经想着设计几个上机题目&#xff0c;让同学们体会一下利用STL编程。写出一个适合初学者的&#xff0c;规模又不能太大&#xff0c;还要有足够引导的题目&#xff0c;实在是一件非常费时费力的事&#xff0c;加上有其他事还得应急&#xff0c;就将此帐欠下&#xff0c;日后再说。要给同学们提的建议是&#xff0c;不少C&#43;&#43;的经典教材对STL都有非常好的讲解&#xff0c;可以选一本去读。在读书时&#xff0c;要开始学着挑着读&#xff0c;跳着读&#xff0c;不必从头到尾&#xff0c;逐页去读。在这个阶段&#xff0c;可以首先学习迭代器utility、在C&#43;&#43;编程中建议替代数组的vector&#xff0c;以及实现双向链表的list。vector和list与本周任务1和任务2似乎有些相关。再者&#xff0c;发扬我们一贯特别能实践的精神&#xff0c;及时找些题目或者自编题目进行实践。 



</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
