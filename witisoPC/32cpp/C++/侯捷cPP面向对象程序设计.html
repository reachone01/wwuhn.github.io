<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>侯捷cPP面向对象程序设计</h3>

<p>基于对象：Object Based 面对的是单一class的设计。</p>
<p>面向对象：Object Oriented 面对的是多重classes的设计，涉及到类和类之间的关系。</p>
<p>课程中设计到两种不同类设计:没有指针（成员变量）的类和带指针（成员变量）的类设计。</p>
<p>头文件一般采用h结尾，源文件一般采用cpp，但是也不一定！（如stl很多没有后缀名）</p>
<p>头文件采用防御式声明，采用 #ifndef *** #define *** #endif，避免多次引用。</p>
<p>注意声明文件的内容顺序，一般是前置声明、类声明、类定义。（疑问，采用源文件进行类定义，与采用头文件进行类定义有哪些区别）</p>
<p>有的函数在类声明时在类的内部直接定义（直接内联），内联只是一种编译提示，是否真的内联取决于函数复杂程度和编译器实现。</p>
<p>构造函数的默认参数和初始化列表的使用，初始化列表很重要，和复制不同！能提高程序的初始化性能。</p>
<p>构造函数可以有多个重载。</p>
<p>如果将构造函数放在private区域，则该类不能在外部构造对象，一般配合设计模式使用，采用工厂模式来构造类，禁止直接构造类的时候使用。例如：定义一个类的静态函数getInstance，该函数返回一个静态的对象。</p>
<p>常量成员函数的意义很重要，一般不改变成员变量的函数都声明为常量函数，在函数声明后面添加 const。方便常量对象直接调用。</p>
<p>明白参数传递中传值和传引用的意义，传引用与传地址效率一样。在类对象的参数传递中尽可能采用传引用的方式，对于不修改类对象的参数传递尽可能采用常量引用。</p>
<p>返回值同样重视传值和传引用，此时注意局部变量考虑到其生命周期，在传引用时要尤其注意，不然会出现野指针。</p>
<p>对于友元函数，可以直接访问友元的私有成员变量。相同class的各个对象之间互为友元。</p>
<p>关于操作符重载，用于实现带有符号语义的函数，注意其语法要求。</p>
<p>对于返回引用的情况，参考对序列化输出和连加连减等操作。</p>
<p>明白操作符重载什么时候需要成员函数，什么时候需要非成员函数。</p>
<p>带指针（变量）的类设计</p>
<p>拷贝构造函数、拷贝函数和析构函数</p>
<p>三大函数。带指针的类设计一定要重视这三大函数，主要是涉及到危险的指针赋值操作。</p>
<p>堆和栈</p>
<p>栈对象（变量）在离开作用域时销毁，调用对象的析构函数。</p>
<p>静态栈对象，离开作用于还存在，在整个程序结束的时候析构。</p>
<p>全局对象的生命周期，比main函数早存在，在整个生命周期结束之后才结束。</p>
<p>堆对象（变量）控制权交给程序员，自己创建（new），自己负责销毁（delete），所以一定要注意指针的赋值（拷贝）操作，容易产生问题，在学习c++11的智能指针后尽可能多使用智能指针。</p>
<p>堆对象的生成，使用new，先分配堆空间，再调用构造函数。 </p>
<p>new的动作分解：首先分配足够的内存空间，然后将内存进行转型操作，然后调用对象的构造函数 </p>
<p>void* mem = operator new(sizeof(class)); </p>
<p>pc = static_cast<class*>(mem); </p>
<p>pc->class::class(*);</p>
<p>堆对象的释放，使用delete，先调用析构函数，然后再释放堆内存。 </p>
<p>class::~class(pointer); operatr delete(pointer)</p>
<p>在String的设计中，在析构函数中调用delete释放字符串。</p>
<p>候老师的重点内容，在new复数类（上一课例子），在调试模式下会多得到32个字节，中间是类的大小（两个double），后面还有四个字节，加上一头一尾的小cookie中，一共是8+（32+4）+（4+4）=52个，在vc下分配内存是16的倍数，为64个。为什么？在回收的时候顺利的回收。在relese模式下没有头尾的添加，但是有cookie，8+（4+4）=16。注意小cookie中的地址记录大小和最后一个位比特来表示是借出还是回收。字符串类（String，成员变量只有一个char指针，4比特），在调试模式下4+（32+4）+（4+4）=48，在relese模式下位4+（4+4）=12，变成16的倍数是16。</p>
<p>如果分配的是数组：array new对应array delete。class *p = new class[3];(8X3)+（32+4）+（4X2）+4,最后的加4是VC的做法，用一个整数来记录数组的长度，结果是72，调整到16的倍数为80，其余的模式以此类推。正确的搭配模式下调用array delete时，看到cookie，知道要删除的空间的大小，不会引起内存泄漏，但是会根据记录数组的区域，3次调用析构函数。如果array new不用array delete的话，只会调用一次析构函数，这样剩下的指针所指对象不会调用析构函数。感悟：透彻明了！</p>
<p>字符串String类的实现细节。</p>
<p>头文件中添加防卫式定义。</p>
<p>字符串里面的类属性，放数组不好因为事先不知道大小，一般放一个指针，大小根据放的内容动态分配；32位平台上一个指针4个byte。</p>
<p>big three 函数：拷贝构造函数(优先考虑传入引用，不修改变量的值，所以添加const)，拷贝复制函数作为成员函数，在返回时传出引用。析构函数，释放开辟的堆内存。</p>
<p>注意String的获取成员变量m_data指针，返回const修辞的char指针。</p>
<p>拷贝赋值函数注意首先判断是否是自我赋值。</p>
<p>if(this==&str)return *this;</p>
<p>类模板函数模板</p>
<p>静态static</p>
<p>类里面的可以包含static函数和static成员变量</p>
<p>每个类对象包含各自的成员变量，一个成员函数要被多个对象调用，需要this指针。</p>
<p>对象中静态static成员不变量属于类，只存在一份。（多个对象共用）</p>
<p>类的静态函数没有this指针，所以不能访问对象里面的类成员，只能是处理静态数据。</p>
<p>静态类成员数据，一定要在类的外面设初值或者叫定义。 注意定义方法 type class::member = ...</p>
<p>调用static函数的方式有两种，一是通过对象调用，第二种是通过类来调用。</p>
<p>模板技术</p>
<p>template<typename T> class name{};</p>
<p>编译器会根据不同的参数，生成不同的代码，所以使用类模板可能造成代码的膨胀。</p>
<p>了解模板函数的意义和作用处理。</p>
<p>c++中的算法大量使用模板。</p>
<p>命名空间</p>
<p>为避免命名冲突，使用命名空间。（比较简单）</p>
<p>命名空间可以分多段定义。</p>
<p>using namespace *；全开</p>
<p>using ::;指定打开</p>
<p> </p>
<p>组合与继承探讨类与类之间的关系</p>
<p>复合 Composition （has-a）</p>
<p>（自己的理解）一个类包含（有）另一个类的对象。注意UML类图，采用实心菱形，箭头指向包含的对象，菱形指向包含别人对象的类。</p>
<p>适配器模式，一个类调用另外类已有的函数（接口），用来满足新类对接口和名称的要求。</p>
<p>从内存的角度来解释复合，层层包含。</p>
<p>构造函数之间的关系，container拥有component，外部的构造函数先调用内部的默认构造函数，即构造由内而外。container：：container(...):compoent（）{……}</p>
<p>外部的析构函数先执行自己，再调用内部的析构函数，析构由外而内。container：：~container(...):{……^compoent();}</p>
<p>委托关系（Delegation）按引用的复合</p>
<p>一个类包含一个类的指针，UML类图使用空心的菱形代替复合中的实心菱形。Pimpl</p>
<p>用指针相连，生命周期就不一致。</p>
<p>例子中采用委托实现字符串的引用计数。copy on write</p>
<p>继承 （is-a）</p>
<p>一个类从另一个类继承部分属性和方法。</p>
<p>uml类图，空心三角形指向父类。</p>
<p>使用继承，传达一种信息，子类是一种（父类）</p>
<p>继承跟虚函数搭配最有价值–重载。</p>
<p>从内存的角度来看，子类的对象中有父类的成分。</p>
<p>构造由内而外，derived的构造函数首先调用base的默认构造函数。Derived::Derived(...):Base(){....};</p>
<p>析构由外而内，derived的析构函数先执行自己，然后才调用base的析构函数。Derived::~Derived(...){...~Base();};</p>
<p>父类的析构函数必须是虚函数，否则会出现不可预期的情况。</p>
<p>非虚函数，你不希望继承的类重新定义（覆盖override）它。</p>
<p>虚函数，你希望继承类重新定义（覆盖）它，而且你对它已经有默认定义。</p>
<p>纯虚函数，你希望继承类一定要重新定义它。virtual …… = 0；</p>
<p>子类对象调用父类的函数，父类的函数中采用虚函数，再调用子类重载的函数。父类中将关键动作延缓到子类中来实现，这种函数的做法叫做Template method，在框架中大量使用。</p>
<p>继承加复合关系下的构造和析构</p>
<p>子类从父类继承，子类还包含一个类的对象，构造函数先调用父类构造还是复合的对象？</p>
<p>父类包含一个复合对象，子类继承。应该先调用复合构造，父类构造和子类构造。</p>
<p>学习文件资源管理类中使用的 Composite 委托加继承的设计方法。</p>
<p>portotype 设计模式。现在创建未来的类。一个类包含一个静态对象，自身的对象，自己创造了自己。</p>
<p>静态成员变量一定记住在类的外面进行定义。</p>
<p> </p>
<p>转换函数 conversion function</p>
<p>从一种类型转换成另外一种类型，相互转换。</p>
<p>定义转换函数：函数不可以有参数，没有返回参数。operator 转换类型() const {return 类型}</p>
<p>转换函数注意合理性。</p>
<p>non-explicit-one-argument actor</p>
<p>（一个实参就够了）非explicit的带一个实参的构造函数。从一个实参构建一个对象。可以把别的东西转换成对象。</p>
<p>转换函数和non-explicit-one-argument actor在一起的时候，会造成二义性，编译器会报错。</p>
<p>explicit-one-argument ctor 明确的一参数构造函数，不要不同类型的转换。explicit大部分用在构造函数的前面。</p>
<p>pointer-like classes 关于智能指针</p>
<p>像指针的类，比指针再多一些东西。</p>
<p>智能指针shared_ptr</p>
<p>封装了一个真正的指针，指针所允许的动作该类都支持。*和->的操作。T& operator*()const { return *px; } T* operator->()const { return px; }</p>
<p>一个符号作用在对象上就消耗掉了，->符号除外，得到的指针对象继续用箭头符号。</p>
<p>关于标准库STL的迭代器。另外一种类似于指针的类。</p>
<p>reference operator*()const { return (*node).data; }//reference 相当于T&</p>
<p>pointer operator->() const { return &(operator*());} //pointer 相当于T*</p>
<p>function-like classes 仿函数</p>
<p>函数的特点，函数名称，小括号()-函数调用操作符，可以接受一个小括号作为操作符，那么就可以成为function-like。</p>
<p>const T& operator()(const T& x) const {return x;}</p>
<p>一定会重载 （）操作。</p>
<p>标准库中，仿函数都会去继承奇特的base classes.</p>
<p>namespace 经验谈</p>
<p>尽可能使用命名空间，防止变量名和函数名的冲突。</p>
<p>class模板</p>
<p>template<typename T> ……T抽象变量类型。</p>
<p>function模板</p>
<p>template<typename T>函数定义</p>
<p>成员模板 member template</p>
<p>在模板类中存在一个新的模板，外面的模板是一个允许变化的东西，如果外部变化项确定，里面的变量又可以变化。</p>
<p>把两个继承类构成的pair放进一个有两个基类的pair中是可行的。反之不可以。</p>
<p>父类的指针可以指向子类的对象。up-cast。</p>
<p>智能指针模板为了实现up-cast，必须使用成员模板。</p>
<p>模板特化 specialization</p>
<p>泛化，在用的时候进行类型化。</p>
<p>设计模板之后，想绑定某种类型，就叫做特例化。指定了特定类型后编译器会根据参数选择相关代码。</p>
<p>partial specialization 偏特化</p>
<p>个数上的偏。模板有多个模板参数，对部分参数进行特例化</p>
<p>范围上的偏。从任意类型，特例化到指针这一种类型。</p>
<p>template temeplate parameter 模板模板参数</p>
<p>template<typename T, template<typename T> class Container> class XCls{private: Container<T> c;……}</p>
<p>XCls<string, list> mylst1; 错误</p>
<p>template<typename T> using Lst=list<T, allocator<T>>>; XCls<string, Lst> mylst2; 正确</p>
<p>关于c++标准库</p>
<p>数据结构容器和算法。</p>
<p>多使用标准库，写小例子测试标准库。</p>
<p>测试是否支持c++11,cout&lt;&lt;__cplausplus &lt;&lt;endl;</p>
<p>三个主题（标准库中的新语法）</p>
<p>数量不定的模板参数</p>
<p>auto关键字。auto自动确定变量类型。</p>
<p>ranged-base for for（decl: coll）{statement}，注意传值和传引用。for（auto& elem： vec）{elem*=3;}</p>
<p>对象模型关于vptr和vtbl</p>
<p>虚指针和虚表，一个类的对象内存占用什么样的内存？当一个类有虚函数的时候，对象里面就会多一个指针。一个虚函数和一万个虚函数是一样的。</p>
<p>继承会把成员变量继承也会把函数继承下来。</p>
<p>一般的函数和虚函数区别。</p>
<p>虚拟表中存放的都是指针，虚函数指针。</p>
<p>编译器看见调用虚函数时，采用动态绑定。通过虚指针，查看虚表，再看调用的是哪一个函数。（普通函数调用采用动态绑定）(* p->vptr[n])(p);编译器会找到n的位置编号。</p>
<p>静态绑定 call cll……</p>
<p>动态绑定，条件1、通过指针调用；2、指针是向上转型 up case；3、调用的是虚拟函数。（多态）</p>
<p>关于this</p>
<p>模板方法，this指针的使用场景。会把当前对象当做this指针传到方法里面。一个父类的方法A里面调用了一个虚函数，这个虚函数在子类中重载，这样当子类调用父类的方法A时，会通过父类的A函数，调用子类重载过的虚函数。</p>
<p>所有的成员函数都隐藏了一个this参数。</p>
<p>关于 Dynamic Binding</p>
<p>非指针调用不会产生动态绑定。</p>
<p>通过指针找到虚指针，找到虚表，找到相应的函数地址。</p>
<p>关于const</p>
<p>当成员函数的const和non-const版本同事存在是，const object只会（只能）调用const版本，non-const object只会（只能）调用non-const版本。</p>
<p>const object 调用const 成员函数可行，但是non-const成员函数不可行。</p>
<p>non-const object 可以调用 const 成员函数，non-const 成员函数。</p>
<p>non-const 成员函数可以调用const 成员函数，反之则不行。</p>
<p>关于New 和 Delete</p>
<p>new 先分配 memory，再调用ctor。</p>
<p>delete 先调用dtor，再释放memory。</p>
<p>array new，一定要搭配 array delete。</p>
<p>重载 new 和 delete 全局函数（编译器调用）</p>
<p>重载全局 ::new ::new[] ::delete ::delete[]</p>
<p>inline void* operator new(size_t_size){……分配内存}</p>
<p>inline void operatpr delete(void* ptr){……释放内存}</p>
<p>上面的重载函数不能放在namespace中，是全局的函数，影响是非常大的。</p>
<p>重载成员函数 new 和 delete</p>
<p>成员函数 void* operator new（size_t）;</p>
<p>成员函数 void operator delete（void*， size_t）;</p>
<p>成员函数 void* operator new[]（size_t）;</p>
<p>成员函数 void operator delete[]（void*， size_t）;</p>
<p>调用函数时添加了::，调用全局的函数，绕过类所定义的new和 delete版本。</p>
<p>关于new 和new[]参数的大小。有虚函数的对象对多一个指针的大小4。</p>
<p>对象数组[]，对多一个4字节的区域，记录数据的大小是多少。</p>
<p>我们可以重载类成员的operator new()，写出多个版本，前提是每个版本的声明都必须有独特的参数列，其中第一个参数必须是size_t，其余参数以new 所指定的placement arguments为初值。出现于new(……)小括号内的便是所谓placement arguments。</p>
<p>我们也可以重载类成员operator delete()，写出多个版本，但是绝对不会被delete调用。只有当new所调用的ctor抛出异常，才会调用这些重载的函数operator delete()。它们只能这样被调用，主要用来归还还未完全创造成功的object所占用的memory。即使operatordelete(……)未能一一对应operator new(……)。也不会出现任何报错。</p>
<p>标准库中String使用 new(extra)扩展</p>
<p>string采用new（extra）进行自己的内存分配，用于实现特定内存结构中引用计数的处理。</p>
<p>引用 reference</p>
<p>int x = 0; int& r = x; sizeof(r) == sizeof(x); &x = &r;</p>
<p>object和其引用的大小相同，地址也相同（全都是假象），java里面的变量都是引用。</p>
<p>编译器实现都是使用指针来实现引用，但是在使用时可以从逻辑上把引用当做原值来使用。</p>
<p>声明引用的时候一定要有初值。设置完以后不能再变化。指针可以变化。</p>
<p>引用的地址和原始类型的地址相同</p>
<p>引用通常不用再变量的声明，引用主要用于参数类型（传参数）和返回类型（返回参数）的描述。</p>
<p>const是不是函数签名的一部分？是</p>
<p>析构和构造函数</p>
<p>继承关系下的构造和析构</p>
<p>继承类的构造函数首先调用父类的默认构造函数再执行自己。</p>
<p>继承类的析构函数先执行自己再执行父类的析构函数。</p>
<p>复合关系下的构造和析构</p>
<p>拥有者的构造函数先调用组件的默认构造函数，然后再执行自己。</p>
<p>拥有者析构函数先执行自己，然后才地哦啊用组件的析构函数。</p>
<p>继承加复合关系下的构造和析构</p>
<p>继承类的构造函数先执行基类的默认构造函数，然后调用组件的默认构造函数，然后再执行自己。Derived::Derived(……):Base(), Component(){};</p>
<p>继承类的析构函数首先执行自己，然后调用组件的析构函数，然后调用基类的析构函数。Derived::~Derived(……){……~Component(), ~BAse()}</p>


<p style='float:right;'>本页共201段，9302个字符，19027 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
