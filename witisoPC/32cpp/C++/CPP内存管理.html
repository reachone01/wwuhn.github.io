<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
    (browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
    (browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
    (browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
    (browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
    (browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
    (browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
    (browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
    "other browser";
    var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
    var obj=document.getElementById("goTopBtn"); 
    var obj2=document.getElementById("shangy"); 
    var obj3=document.getElementById("xiay");
    var obj4=document.getElementById("goBottom");  
    
    function getScrollTop(){  
        if(browser4=="ch"){
            //chrome
            //chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
            return document.documentElement.scrollTop; 
        }else{
            //IE、firefox
            return document.documentElement.scrollTop;  
        }  
    }
    function setScrollTop(value){ 
        if(browser4=="ch"){ 
            //chrome
            document.documentElement.scrollTop=value; 
        }else{  
            //IE、firefox
            document.documentElement.scrollTop=value;  
        } 
    }     
    window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
    getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
    document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
    document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
    }  
    obj.onclick=function(){  
        var goTop=setInterval(scrollMove,10);  
        function scrollMove(){  
                setScrollTop(getScrollTop()/1.1);  
                if(getScrollTop()<1)clearInterval(goTop);  
        }  
    }  
}  
function downn(){
    if(browser4=="ch"){
        //chrome
        window.scrollBy(0,document.body.clientHeight);
    }else{
        //IE、firefox
        window.scrollBy(0,document.documentElement.clientHeight*1000); 
    }
}
</script>
<script>
function changePage(){ 
    var page = document.getElementById("container");
    page.style.background="black";
    page.style.color="white";
    page.style.fontSize="22px";
    page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
    font-size:18px;
    text-decoration:none;
}
a:link{
    text-decoration:none;
    }
#container{
    font-size:1.2em;
    margin:auto;
    font-family:"宋体";
    width:65.29%;
    line-height:1.6em;
}
P{
    margin-top:16px;
    margin-bottom:16px;
    text-indent:2em;
}
.uls{
    color:#CC6666;
    font-weight:bold;
}
.uls>ol{
    list-style:none;
    font-weight:normal;
    list-style:lower-latin;
    color:#000000;
    line-height:1.3em;
}
h3{
    font-size:1.1em;
    font-weight:bold;
    text-indent:0em;
    color:#990000;
}
h4{
    font-size:1.0em;
    font-weight:bold;
    text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
    width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
    right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
    opacity=.3;
    font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
    bottom:240px;
}
#ftsize2{
    bottom:214px;
}
#ftsize3{
    bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
    background-color:#ccc;
    border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
    text-decoration: none;
    color:white;
}
img{
    margin-right:2em;
    text-indent:2em;
    border:0;
}
.picsay{
    color:#930;
    font-size:90%;
    line-height:110%;
    margin-top:-12px;
    padding:0;
}
.remark{
    color:#930;
    font-size:90%;
    line-height:140%;
    margin-top:-12px;
    text-indent:0em;
    padding:0;
}
.ref{
    color:#930;
    font-size:95%;
    line-height:150%;
    margin-top:-12px;
    text-indent:2em;
    padding:0;
}
pre{
    font-size:120%;
    line-height:130%;
    padding:0;
    //background-color:#f6f6f6;
    //background-color:#fff5ee;
    //background-color:#ffe;
    background-color:#eee;
    padding:8px;
    }
.code0, .code2, .code4{
    font-size:95%;
    line-height:110%;
    margin-top:-12px;
    padding:0;
    //background-color:#D9D1CA;
    //background-color:#f6f6f6;
    //background-color:#fff5ee;
    background-color:#ffe;
}
.code0{
    color:red;
    text-indent:0em;
}
.code2{
    color:#930;
    text-indent:2em;
}
.code4{
    color:blue;
    text-indent:4em;
}
sub,sup{
    font-size:80%;
    color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>CPP内存管理</h4>


<p>[导语]</p>
<p>内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。本期专题将从内存管理、内存泄漏、内存回收这三个方面来探讨C++内存管理问题。</p>
<h3>1 内存管理</h3>
<p>伟大的Bill Gates 曾经失言：</p>
<p>640K ought to be enough for everybody — Bill Gates 1981</p>
<p>程序员们经常编写内存管理程序，往往提心吊胆。如果不想触雷，唯一的解决办法就是发现所有潜伏的地雷并且排除它们，躲是躲不了的。本文的内容比一般教科书的要深入得多，读者需细心阅读，做到真正地通晓内存管理。</p>
<h4>1.1 C++内存管理详解</h4>
<h4>1.1.1 内存分配方式</h4>
<h4>1.1.1.1 分配方式简介</h4>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<p>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p>
<p>全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p>
<p>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<h4>1.1.1.2 明确区分堆与栈</h4>
<p>在bbs上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</p>
<p>首先，我们举一个例子：</p>
<p></p>
<pre>
void f() { int* p=new int[5]; }
</pre>
<p>这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p>
<p></p>
<pre>
00401028 push 14h
0040102A call operator new (00401060)
0040102F add esp,4
00401032 mov dword ptr [ebp-8],eax
00401035 mov eax,dword ptr [ebp-8]
00401038 mov dword ptr [ebp-4],eax
</pre>
<p></p>
<p>这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。</p>
<h4>1.1.1.3 堆和栈究竟有什么区别？</h4>
<p>好了，我们回到我们的主题：堆和栈究竟有什么区别？</p>
<p>主要的区别由以下几点：</p>
<p>1、管理方式不同；</p>
<p>2、空间大小不同；</p>
<p>3、能否产生碎片不同；</p>
<p>4、生长方向不同；</p>
<p>5、分配方式不同；</p>
<p>6、分配效率不同；</p>
<p><strong>管理方式</strong>：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>
<p><strong>空间大小</strong>：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：</p>
<p>打开工程，依次操作菜单如下：Project->Setting->Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。</p>
<p>注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p>
<p><strong>碎片问题</strong>：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p>
<p><strong>生长方向</strong>：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p>
<p><strong>分配方式</strong>：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p><strong>分配效率</strong>：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行（及寄存器存储），这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
<p>从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p>
<p>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<p>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）</p>
<h4>1.1.2 控制C++的内存分配</h4>
<p>在嵌入式系统中使用C++的一个常见问题是内存分配，即对new 和 delete 操作符的失控。</p>
<p>具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。</p>
<p>这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。</p>
<p>作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。</p>
<p>但当你必须要使用new 和delete时，你不得不控制C++中的内存分配。你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new 和delete。</p>
<p>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。</p>
<h4>1.1.2.1 重载全局的new和delete操作符</h4>
<p>可以很容易地重载new 和 delete 操作符，如下所示:</p>
<pre>
void * operator new(size_t size)
{
    void *p = malloc(size);
    return (p);
}
void operator delete(void *p);
{
    free(p);
}
</pre>
<p>这段代码可以代替默认的操作符来满足内存分配的请求。出于解释C++的目的，我们也可以直接调用malloc() 和free()。</p>
<p>也可以对单个类的new 和 delete 操作符重载。这是你能灵活的控制对象的内存分配。</p>
<p></p>
<pre>
class TestClass {
public:
    void * operator new(size_t size);
    void operator delete(void *p);
    // .. other members here ...
};
void *TestClass::operator new(size_t size)
{
    void *p = malloc(size); // Replace this with alternative allocator
    return (p);
}
void TestClass::operator delete(void *p)
{
    free(p); // Replace this with alternative de-allocator
}
</pre>
<p></p>
<p>所有TestClass 对象的内存分配都采用这段代码。更进一步，任何从TestClass 继承的类也都采用这一方式，除非它自己也重载了new 和 delete 操作符。通过重载new 和 delete 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p>
<h4>1.1.2.2 为单个的类重载 new[ ]和delete[ ]</h4>
<p>必须小心对象数组的分配。你可能希望调用到被你重载过的new 和 delete 操作符，但并不如此。内存的请求被定向到全局的new[ ]和delete[ ] 操作符，而这些内存来自于系统堆。</p>
<p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[ ] 和 delete[ ]操作符。</p>
<p></p>
<pre>
class TestClass {
public:
    void * operator new[ ](size_t size);
    void operator delete[ ](void *p);
    // .. other members here ..
};
void *TestClass::operator new[ ](size_t size)
{
    void *p = malloc(size);
    return (p);
}
void TestClass::operator delete[ ](void *p)
{
    free(p);
}
int main(void)
{
    TestClass *p = new TestClass[10];
    // ... etc ...
    delete[ ] p;
}
</pre>
<p></p>
<p>但是注意：对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</p>
<h4>1.1.3 常见的内存错误及其对策</h4>
<p>发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：</p>
<p><strong>* 内存分配未成功，却使用了它。</strong></p>
<p>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</p>
<p><strong>* 内存分配虽然成功，但是尚未初始化就引用它。</strong></p>
<p>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p>
<p><strong>* 内存分配成功并且已经初始化，但操作越过了内存的边界。</strong></p>
<p>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p>
<p><strong>* 忘记了释放内存，造成内存泄露。</strong></p>
<p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。</p>
<p>动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</p>
<p><strong>* 释放了内存却继续使用它。</strong></p>
<p></p>
<p>有三种情况：</p>
<p>（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</p>
<p>（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</p>
<p>（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</p>
<p>【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。</p>
<p>【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</p>
<p>【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。</p>
<p>【规则4】动态内存的申请与释放必须配对，防止内存泄漏。</p>
<p>【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</p>
<h4>1.1.4 指针与数组的对比</h4>
<p>C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。</p>
<p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。</p>
<p>指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。</p>
<p>下面以字符串为例比较指针与数组的特性。</p>
<h4>1.1.4.1 修改内容</h4>
<p>下面示例中，字符数组a的容量是6个字符，其内容为hello。a的内容可以改变，如a[0]= ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。</p>
<p></p>
<pre>
char a[] = “hello”;
a[0] = ‘X’;
cout &lt;&lt; a &lt;&lt; endl;
char *p = “world”; // 注意p指向常量字符串
p[0] = ‘X’; // 编译器不能发现该错误
cout &lt;&lt; p &lt;&lt; endl;
</pre>
<h4>1.1.4.2 内容复制与比较</h4>
<p>不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。</p>
<p>语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。</p>
<p></p>
<pre>
// 数组…
char a[] = "hello";
char b[10];
strcpy(b, a); // 不能用 b = a;
if(strcmp(b, a) == 0) // 不能用 if (b == a)
    …
// 指针…
int len = strlen(a);
char *p = (char *)malloc(sizeof(char)*(len+1));
strcpy(p,a); // 不要用 p = a;
if(strcmp(p, a) == 0) // 不要用 if (p == a)
    …
</pre>
<h4>1.1.4.3 计算内存容量</h4>
<p>用运算符sizeof可以计算出数组的容量（字节数）。如下示例中，sizeof(a)的值是12（注意别忘了’’）。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p>
<p></p>
<pre>
char a[] = "hello world";
char *p = a;
cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12字节
cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4字节
</pre>
<p></p>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。</p>
<p></p>
<pre>
void Func(char a[100])
{
cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节
}
</pre>
<h4>1.1.5 指针参数是如何传递内存的？</h4>
<p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。如下示例中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？</p>
<p></p>
<pre>
void GetMemory(char *p, int num)
{
  p = (char *)malloc(sizeof(char) * num);
}
void Test(void)
{
  char *str = NULL;
  GetMemory(str, 100);  // str 仍然为 NULL
  strcpy(str, "hello"); // 运行错误
}
</pre>
<p>毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。</p>
<p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例：</p>
<p></p>
<pre>
void GetMemory2(char **p, int num)
{
  *p = (char *)malloc(sizeof(char) * num);
}
void Test2(void)
{
  char *str = NULL;
  GetMemory2(&str, 100); // 注意参数是 &str，而不是str
  strcpy(str, "hello");
  cout&lt;&lt; str &lt;&lt; endl;
  free(str);
}
</pre>
<p>由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：</p>
<p></p>
<pre>
char *GetMemory3(int num)
{
  char *p = (char *)malloc(sizeof(char) * num);
  return p;
}
void Test3(void)
{
  char *str = NULL;
  str = GetMemory3(100);
  strcpy(str, "hello");
  cout&lt;&lt; str &lt;&lt; endl;
  free(str);
}
</pre>
<p>用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例：</p>
<p></p>
<pre>
char *GetString(void)
{
  char p[] = "hello world";
  return p; // 编译器将提出警告
}
void Test4(void)
{
  char *str = NULL;
  str = GetString(); // str 的内容是垃圾
  cout&lt;&lt; str &lt;&lt; endl;
}
</pre>
<p>用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。</p>
<p>如果把上述示例改写成如下示例，会怎么样？</p>
<p></p>
<pre>
char *GetString2(void)
{
  char *p = "hello world";
  return p;
}
void Test5(void)
{
  char *str = NULL;
  str = GetString2();
  cout&lt;&lt; str &lt;&lt; endl;
}
</pre>
<p>函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。</p>
<h4>1.1.6 杜绝“野指针”</h4>
<p>“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有两种：</p>
<p>（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如</p>
<p></p>
<pre>
char *p = NULL;
char *str = (char *) malloc(100);
</pre>
<p>（2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。</p>
<p>（3）指针操作超越了变量的作用域范围。这种情况让人防不胜防，示例程序如下：</p>
<p></p>
<pre>
class A
{
public:
    void Func(void){ cout &lt;&lt; “Func of class A” &lt;&lt; endl; }
};
void Test(void)
{
    A *p;
    {
        A a;
        p = &a; // 注意 a 的生命期
      }
    p->Func(); // p是“野指针”
}
</pre>
<p>函数Test在执行语句p->Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p>
<h4>1.1.7 有了malloc/free为什么还要new/delete？</h4>
<p>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。</p>
<p>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。</p>
<p>因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。我们先看一看malloc/free和new/delete如何实现对象的动态内存管理，见示例：</p>
<p></p>
<pre>
class Obj
{
public :
    Obj(void){ cout &lt;&lt; “Initialization” &lt;&lt; endl; }
    ~Obj(void){ cout &lt;&lt; “Destroy” &lt;&lt; endl; }
    void Initialize(void){ cout &lt;&lt; “Initialization” &lt;&lt; endl; }
    void Destroy(void){ cout &lt;&lt; “Destroy” &lt;&lt; endl; }
};
void UseMallocFree(void)
{
    Obj *a = (obj *)malloc(sizeof(obj)); // 申请动态内存
    a->Initialize(); // 初始化
    //…
    a->Destroy(); // 清除工作
    free(a); // 释放内存
}
void UseNewDelete(void)
{
    Obj *a = new Obj; // 申请动态内存并且初始化
    //…
    delete a; // 清除并且释放内存
}
</pre>
<p>类Obj的函数Initialize模拟了构造函数的功能，函数Destroy模拟了析构函数的功能。函数UseMallocFree中，由于malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成初始化与清除工作。函数UseNewDelete则简单得多。</p>
<p>所以我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。</p>
<p>既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。</p>
<p>如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。</p>
<h4>1.1.8 内存耗尽怎么办？</h4>
<p>如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。</p>
<p>（1）判断指针是否为NULL，如果是则马上用return语句终止本函数。例如：</p>
<p></p>
<pre>
void Func(void)
{
    A *a = new A;
    if(a == NULL)
    {
        return;
    }
    …
}
</pre>
<p>（2）判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。例如：</p>
<p></p>
<pre>
void Func(void)
{
A *a = new A;
if(a == NULL)
{
cout &lt;&lt; “Memory Exhausted” &lt;&lt; endl;
exit(1);
}
…
}
</pre>
<p>（3）为new和malloc设置异常处理函数。例如Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。详细内容请参考C++使用手册。</p>
<p>上述（1）（2）方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式（1）就显得力不从心（释放内存很麻烦），应该用方式（2）来处理。</p>
<p>很多人不忍心用exit(1)，问：“不编写出错处理程序，让操作系统自己解决行不行？”</p>
<p>不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用exit(1) 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。</p>
<p>有一个很重要的现象要告诉大家。对于32位以上的应用程序而言，无论怎样使用malloc与new，几乎不可能导致“内存耗尽”。我在Windows 98下用Visual C++编写了测试程序，见示例7。这个程序会无休止地运行下去，根本不会终止。因为32位操作系统支持“虚存”，内存用完了，自动用硬盘空间顶替。我只听到硬盘嘎吱嘎吱地响，Window 98已经累得对键盘、鼠标毫无反应。</p>
<p>我可以得出这么一个结论：对于32位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把Unix和Windows程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。</p>
<p>我不想误导读者，必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。</p>
<p></p>
<pre>
void main(void)
{
float *p = NULL;
while(TRUE)
{
p = new float[1000000];
cout &lt;&lt; “eat memory” &lt;&lt; endl;
if(p==NULL)
exit(1);
}
}
</pre>
<h4>1.1.9 malloc/free的使用要点</h4>
<p>函数malloc的原型如下：</p>
<p></p>
<pre>
void * malloc(size_t size);
</pre>
<p>用malloc申请一块长度为length的整数类型的内存，程序如下：</p>
<p></p>
<pre>
int *p = (int *) malloc(sizeof(int) * length);
</pre>
<p>我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。</p>
<p>* malloc返回值的类型是void *，所以在调用malloc时要显式地进行类型转换，将void * 转换成所需要的指针类型。</p>
<p>* malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住int, float等数据类型的变量的确切字节数。例如int变量在16位系统下是2个字节，在32位下是4个字节；而float变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试：</p>
<p></p>
<pre>
cout &lt;&lt; sizeof(char) &lt;&lt; endl;
cout &lt;&lt; sizeof(int) &lt;&lt; endl;
cout &lt;&lt; sizeof(unsigned int) &lt;&lt; endl;
cout &lt;&lt; sizeof(long) &lt;&lt; endl;
cout &lt;&lt; sizeof(unsigned long) &lt;&lt; endl;
cout &lt;&lt; sizeof(float) &lt;&lt; endl;
cout &lt;&lt; sizeof(double) &lt;&lt; endl;
cout &lt;&lt; sizeof(void *) &lt;&lt; endl;
</pre>
<p>在malloc的“()”中使用sizeof运算符是良好的风格，但要当心有时我们会昏了头，写出 p = malloc(sizeof(p))这样的程序来。</p>
<p>函数free的原型如下：</p>
<p></p>
<pre>
void free( void * memblock );
</pre>
<p>为什么free函数不象malloc函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。</p>
<p>1.1.10 new/delete的使用要点</p>
<p>运算符new使用起来要比函数malloc简单得多，例如：</p>
<p></p>
<pre>
int *p1 = (int *)malloc(sizeof(int) * length);
int *p2 = new int[length];
</pre>
<p>这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。例如</p>
<p></p>
<pre>
class Obj
{
public :
Obj(void);  // 无参数的构造函数
Obj(int x); // 带一个参数的构造函数
…
}
void Test(void)
{
Obj *a = new Obj;
Obj *b = new Obj(1); // 初值为1
…
delete a;
delete b;
}
</pre>
<p>如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：</p>
<p></p>
<pre>
Obj *objects = new Obj[100]; // 创建100个动态对象
</pre>
<p>不能写成：</p>
<p></p>
<pre>
Obj *objects = new Obj[100](1);// 创建100个动态对象的同时赋初值1
</pre>
<p>在用delete释放对象数组时，留意不要丢了符号‘[]’。例如：</p>
<p></p>
<pre>
delete []objects; // 正确的用法
delete objects;   // 错误的用法
</pre>
<p>后者有可能引起程序崩溃和内存泄漏。</p>
<h4>1.2 C++中的健壮指针和资源管理</h4>
<p>我最喜欢的对资源的定义是："任何在你的程序中获得并在此后释放的东西?quot;内存是一个相当明显的资源的例子。它需要用new来获得，用delete来释放。同时也有许多其它类型的资源文件句柄、重要的片断、Windows中的GDI资源，等等。将资源的概念推广到程序中创建、释放的所有对象也是十分方便的，无论对象是在堆中分配的还是在栈中或者是在全局作用于内生命的。</p>
<p>对于给定的资源的拥有着，是负责释放资源的一个对象或者是一段代码。所有权分立为两种级别——自动的和显式的（automatic and explicit），如果一个对象的释放是由语言本身的机制来保证的，这个对象的就是被自动地所有。例如，一个嵌入在其他对象中的对象，他的清除需要其他对象来在清除的时候保证。外面的对象被看作嵌入类的所有者。类似地，每个在栈上创建的对象（作为自动变量）的释放（破坏）是在控制流离开了对象被定义的作用域的时候保证的。这种情况下，作用于被看作是对象的所有者。注意所有的自动所有权都是和语言的其他机制相容的，包括异常。无论是如何退出作用域的——正常流程控制退出、一个break语句、一个return、一个goto、或者是一个throw——自动资源都可以被清除。</p>
<p>到目前为止，一切都很好！问题是在引入指针、句柄和抽象的时候产生的。如果通过一个指针访问一个对象的话，比如对象在堆中分配，C++不自动地关注它的释放。程序员必须明确的用适当的程序方法来释放这些资源。比如说，如果一个对象是通过调用new来创建的，它需要用delete来回收。一个文件是用CreateFile(Win32 API)打开的，它需要用CloseHandle来关闭。用EnterCritialSection进入的临界区（Critical Section）需要LeaveCriticalSection退出，等等。一个"裸"指针，文件句柄，或者临界区状态没有所有者来确保它们的最终释放。基本的资源管理的前提就是确保每个资源都有他们的所有者。</p>
<h4>1.2.1 第一条规则（RAII）</h4>
<p>一个指针，一个句柄，一个临界区状态只有在我们将它们封装入对象的时候才会拥有所有者。这就是我们的第一规则：在构造函数中分配资源，在析构函数中释放资源。</p>
<p>当你按照规则将所有资源封装的时候，你可以保证你的程序中没有任何的资源泄露。这点在当封装对象（Encapsulating Object）在栈中建立或者嵌入在其他的对象中的时候非常明显。但是对那些动态申请的对象呢？不要急！任何动态申请的东西都被看作一种资源，并且要按照上面提到的方法进行封装。这一对象封装对象的链不得不在某个地方终止。它最终终止在最高级的所有者，自动的或者是静态的。这些分别是对离开作用域或者程序时释放资源的保证。</p>
<p>下面是资源封装的一个经典例子。在一个多线程的应用程序中，线程之间共享对象的问题是通过用这样一个对象联系临界区来解决的。每一个需要访问共享资源的客户需要获得临界区。例如，这可能是Win32下临界区的实现方法。</p>
<p></p>
<pre>
class CritSect
{
friend class Lock;
public:
CritSect () { InitializeCriticalSection (&_critSection); }
~CritSect () { DeleteCriticalSection (&_critSection); }
private:
void Acquire ()
{
EnterCriticalSection (&_critSection);
}
void Release ()
{
LeaveCriticalSection (&_critSection);
}
private:
CRITICAL_SECTION _critSection;
};
</pre>
<p>这里聪明的部分是我们确保每一个进入临界区的客户最后都可以离开。"进入"临界区的状态是一种资源，并应当被封装。封装器通常被称作一个锁（lock）。</p>
<p></p>
<pre>
class Lock
{
public:
Lock (CritSect& critSect) : _critSect (critSect)
{
_critSect.Acquire ();
}
~Lock ()
{
_critSect.Release ();
}
private
CritSect & _critSect;
};
</pre>
<p>锁一般的用法如下：</p>
<p></p>
<pre>
void Shared::Act () throw (char *)
{
Lock lock (_critSect);
// perform action —— may throw
// automatic destructor of lock
}
</pre>
<p></p>
<p>注意无论发生什么，临界区都会借助于语言的机制保证释放。</p>
<p>还有一件需要记住的事情——每一种资源都需要被分别封装。这是因为资源分配是一个非常容易出错的操作，是要资源是有限提供的。我们会假设一个失败的资源分配会导致一个异常——事实上，这会经常的发生。所以如果你想试图用一个石头打两只鸟的话，或者在一个构造函数中申请两种形式的资源，你可能就会陷入麻烦。只要想想在一种资源分配成功但另一种失败抛出异常时会发生什么。因为构造函数还没有全部完成，析构函数不可能被调用，第一种资源就会发生泄露。</p>
<p>这种情况可以非常简单的避免。无论何时你有一个需要两种以上资源的类时，写两个小的封装器将它们嵌入你的类中。每一个嵌入的构造都可以保证删除，即使包装类没有构造完成。</p>
<h4>1.2.2 Smart Pointers</h4>
<p>我们至今还没有讨论最常见类型的资源——用操作符new分配，此后用指针访问的一个对象。我们需要为每个对象分别定义一个封装类吗？（事实上，C++标准模板库已经有了一个模板类，叫做auto_ptr，其作用就是提供这种封装。我们一会儿在回到auto_ptr。）让我们从一个极其简单、呆板但安全的东西开始。看下面的Smart Pointer模板类，它十分坚固，甚至无法实现。</p>
<p></p>
<pre>
template &lt;class T>
class SmartPointer
{
public:
~SmartPointer () { delete _p; }
T * operator->() { return _p; }
T const * operator->() const { return _p; }
protected:
SmartPointer (): _p (0) {}
explicit SmartPointer (T* p): _p (p) {}
T * _p;
};
</pre>
<p>为什么要把SmartPointer的构造函数设计为protected呢？如果我需要遵守第一条规则，那么我就必须这样做。资源——在这里是class T的一个对象——必须在封装器的构造函数中分配。但是我不能只简单的调用new T，因为我不知道T的构造函数的参数。因为，在原则上，每一个T都有一个不同的构造函数；我需要为他定义个另外一个封装器。模板的用处会很大，为每一个新的类，我可以通过继承SmartPointer定义一个新的封装器，并且提供一个特定的构造函数。</p>
<p></p>
<pre>
class SmartItem: public SmartPointer&lt;Item>
{
public:
explicit SmartItem (int i)
: SmartPointer&lt;Item> (new Item (i)) {}
};
</pre>
<p></p>
<p>为每一个类提供一个Smart Pointer真的值得吗？说实话——不！他很有教学的价值，但是一旦你学会如何遵循第一规则的话，你就可以放松规则并使用一些高级的技术。这一技术是让SmartPointer的构造函数成为public，但是只是是用它来做资源转换（Resource Transfer）我的意思是用new操作符的结果直接作为SmartPointer的构造函数的参数，像这样：</p>
<p></p>
<pre>
SmartPointer&lt;Item> item (new Item (i));
</pre>
<p></p>
<p>这个方法明显更需要自控性，不只是你，而且包括你的程序小组的每个成员。他们都必须发誓出了作资源转换外不把构造函数用在人以其他用途。幸运的是，这条规矩很容易得以加强。只需要在源文件中查找所有的new即可。</p>
<h4>1.2.3 Resource Transfer</h4>
<p>到目前为止，我们所讨论的一直是生命周期在一个单独的作用域内的资源。现在我们要解决一个困难的问题——如何在不同的作用域间安全的传递资源。这一问题在当你处理容器的时候会变得十分明显。你可以动态的创建一串对象，将它们存放至一个容器中，然后将它们取出，并且在最终安排它们。为了能够让这安全的工作——没有泄露——对象需要改变其所有者。</p>
<p>这个问题的一个非常显而易见的解决方法是使用Smart Pointer，无论是在加入容器前还是还找到它们以后。这是他如何运作的，你加入Release方法到Smart Pointer中：</p>
<p></p>
<pre>
template &lt;class T>
T * SmartPointer&lt;T>::Release ()
{
    T * pTmp = _p;
    _p = 0;
    return pTmp;
}
</pre>
<p></p>
<p>注意在Release调用以后，Smart Pointer就不再是对象的所有者了——它内部的指针指向空。现在，调用了Release都必须是一个负责的人并且迅速隐藏返回的指针到新的所有者对象中。在我们的例子中，容器调用了Release，比如这个Stack的例子：</p>
<p></p>
<pre>
void Stack::Push (SmartPointer &lt;Item> & item) throw (char *)
{
    if (_top == maxStack)
        throw "Stack overflow";
    _arr [_top++] = item.Release ();
};
</pre>
<p></p>
<p>同样的，你也可以再你的代码中用加强Release的可靠性。</p>
<p>相应的Pop方法要做些什么呢？他应该释放了资源并祈祷调用它的是一个负责的人而且立即作一个资源传递它到一个Smart Pointer？这听起来并不好。</p>
<h4>1.2.4 Strong Pointers</h4>
<p>资源管理在内容索引（Windows NT Server上的一部分，现在是Windows 2000）上工作，并且，我对这十分满意。然后我开始想……这一方法是在这样一个完整的系统中形成的，如果可以把它内建入语言的本身岂不是一件非常好？我提出了强指针（Strong Pointer）和弱指针(Weak Pointer)。一个Strong Pointer会在许多地方和我们这个SmartPointer相似--它在超出它的作用域后会清除他所指向的对象。资源传递会以强指针赋值的形式进行。也可以有Weak Pointer存在，它们用来访问对象而不需要所有对象--比如可赋值的引用。</p>
<p>任何指针都必须声明为Strong或者Weak，并且语言应该来关注类型转换的规定。例如，你不可以将Weak Pointer传递到一个需要Strong Pointer的地方，但是相反却可以。Push方法可以接受一个Strong Pointer并且将它转移到Stack中的Strong Pointer的序列中。Pop方法将会返回一个Strong Pointer。把Strong Pointer的引入语言将会使垃圾回收成为历史。</p>
<p>这里还有一个小问题--修改C++标准几乎和竞选美国总统一样容易。当我将我的注意告诉给Bjarne Stroutrup的时候，他看我的眼神好像是我刚刚要向他借一千美元一样。</p>
<p>然后我突然想到一个念头。我可以自己实现Strong Pointers。毕竟，它们都很想Smart Pointers。给它们一个拷贝构造函数并重载赋值操作符并不是一个大问题。事实上，这正是标准库中的auto_ptr有的。重要的是对这些操作给出一个资源转移的语法，但是这也不是很难。</p>
<p></p>
<pre>
template &lt;class T>
SmartPointer&lt;T>::SmartPointer (SmartPointer&lt;T> & ptr)
{
    _p = ptr.Release ();
}
template &lt;class T>
void SmartPointer&lt;T>::operator = (SmartPointer&lt;T> & ptr)
{
    if (_p != ptr._p)
    {
        delete _p;
        _p = ptr.Release ();
    }
}
</pre>
<p></p>
<p>使这整个想法迅速成功的原因之一是我可以以值方式传递这种封装指针！我有了我的蛋糕，并且也可以吃了。看这个Stack的新的实现：</p>
<p></p>
<pre>
class Stack
{
    enum { maxStack = 3 };
public:
    Stack ()
        : _top (0)
    {}
    void Push (SmartPointer&lt;Item> & item) throw (char *)
    {
        if (_top >= maxStack)
            throw "Stack overflow";
        _arr [_top++] = item;
    }
    SmartPointer&lt;Item> Pop ()
    {
        if (_top == 0)
            return SmartPointer&lt;Item> ();
        return _arr [--_top];
    }
    private
        int _top;
        SmartPointer&lt;Item> _arr [maxStack];
};
</pre>
<p></p>
<p>Pop方法强制客户将其返回值赋给一个Strong Pointer,SmartPointer<Item>。任何试图将他对一个普通指针的赋值都会产生一个编译期错误，因为类型不匹配。此外，因为Pop以值方式返回一个Strong Pointer(在Pop的声明时SmartPointer<Item>后面没有&符号)，编译器在return时自动进行了一个资源转换。他调用了operator =来从数组中提取一个Item,拷贝构造函数将他传递给调用者。调用者最后拥有了指向Pop赋值的Strong Pointer指向的一个Item。</p>
<p>我马上意识到我已经在某些东西之上了。我开始用了新的方法重写原来的代码。</p>
<h4>1.2.5 Parser</h4>
<p>我过去有一个老的算术操作分析器，是用老的资源管理的技术写的。分析器的作用是在分析树中生成节点，节点是动态分配的。例如分析器的Expression方法生成一个表达式节点。我没有时间用Strong Pointer去重写这个分析器。我令Expression、Term和Factor方法以传值的方式将Strong Pointer返回到Node中。看下面的Expression方法的实现：</p>
<p></p>
<pre>
SmartPointer&lt;Node> Parser::Expression()
{
    // Parse a term
    SmartPointer&lt;Node> pNode = Term ();
    EToken token = _scanner.Token();
    if ( token == tPlus || token == tMinus )
    {
        // Expr := Term { ('+' | '-') Term }
        SmartPointer&lt;MultiNode> pMultiNode = new SumNode (pNode);
        do
        {
            _scanner.Accept();
            SmartPointer&lt;Node> pRight = Term ();
            pMultiNode->AddChild (pRight, (token == tPlus));
            token = _scanner.Token();
        } while (token == tPlus || token == tMinus);
        pNode = up_cast&lt;Node, MultiNode> (pMultiNode);
    }
    // otherwise Expr := Term
    return pNode; // by value!
}
</pre>
<p></p>
<p>最开始，Term方法被调用。他传值返回一个指向Node的Strong Pointer并且立刻把它保存到我们自己的Strong Pointer,pNode中。如果下一个符号不是加号或者减号，我们就简单的把这个SmartPointer以值返回，这样就释放了Node的所有权。另外一方面，如果下一个符号是加号或者减号，我们创建一个新的SumMode并且立刻（直接传递）将它储存到MultiNode的一个Strong Pointer中。这里，SumNode是从MultiMode中继承而来的，而MulitNode是从Node继承而来的。原来的Node的所有权转给了SumNode。</p>
<p>只要是他们在被加号和减号分开的时候，我们就不断的创建terms，我们将这些term转移到我们的MultiNode中，同时MultiNode得到了所有权。最后，我们将指向MultiNode的Strong Pointer向上映射为指向Mode的Strong Pointer，并且将他返回调用着。</p>
<p>我们需要对Strong Pointers进行显式的向上映射，即使指针是被隐式的封装。例如，一个MultiNode是一个Node，但是相同的is-a关系在SmartPointer<MultiNode>和SmartPointer<Node>之间并不存在，因为它们是分离的类（模板实例）并不存在继承关系。up-cast模板是像下面这样定义的：</p>
<p></p>
<pre>
template&lt;class To, class From>
inline SmartPointer&lt;To> up_cast (SmartPointer&lt;From> & from)
{
    return SmartPointer&lt;To> (from.Release ());
}
</pre>
<p></p>
<p>如果你的编译器支持新加入标准的成员模板（member template）的话，你可以为SmartPointer<T>定义一个新的构造函数用来从接受一个class U。</p>
<p></p>
<pre>
template &lt;class T>
template &lt;class U> SmartPointer&lt;T>::SmartPointer (SPrt&lt;U> & uptr)
: _p (uptr.Release ())
{}
</pre>
<p></p>
<p>这里的这个花招是模板在U不是T的子类的时候就不会编译成功（换句话说，只在U is-a T的时候才会编译）。这是因为uptr的缘故。Release()方法返回一个指向U的指针，并被赋值为_p，一个指向T的指针。所以如果U不是一个T的话，赋值会导致一个编译时刻错误。</p>
<p></p>
<pre>
std::auto_ptr
</pre>
<p></p>
<p>后来我意识到在STL中的auto_ptr模板，就是我的Strong Pointer。在那时候还有许多的实现差异（auto_ptr的Release方法并不将内部的指针清零--你的编译器的库很可能用的就是这种陈旧的实现），但是最后在标准被广泛接受之前都被解决了。</p>
<p>1.2.6 Transfer Semantics</p>
<p>目前为止，我们一直在讨论在C++程序中资源管理的方法。宗旨是将资源封装到一些轻量级的类中，并由类负责它们的释放。特别的是，所有用new操作符分配的资源都会被储存并传递进Strong Pointer（标准库中的auto_ptr）的内部。</p>
<p>这里的关键词是传递（passing）。一个容器可以通过传值返回一个Strong Pointer来安全的释放资源。容器的客户只能够通过提供一个相应的Strong Pointer来保存这个资源。任何一个将结果赋给一个"裸"指针的做法都立即会被编译器发现。</p>
<p></p>
<pre>
auto_ptr&lt;Item> item = stack.Pop (); // ok
Item * p = stack.Pop (); // Error! Type mismatch.
</pre>
<p></p>
<p>以传值方式被传递的对象有value semantics 或者称为 copy semantics。Strong Pointers是以值方式传递的--但是我们能说它们有copy semantics吗？不是这样的！它们所指向的对象肯定没有被拷贝过。事实上，传递过后，源auto_ptr不在访问原有的对象，并且目标auto_ptr成为了对象的唯一拥有者（但是往往auto_ptr的旧的实现即使在释放后仍然保持着对对象的所有权）。自然而然的我们可以将这种新的行为称作Transfer Semantics。</p>
<p>拷贝构造函数（copy construcor）和赋值操作符定义了auto_ptr的Transfer Semantics，它们用了非const的auto_ptr引用作为它们的参数。</p>
<p></p>
<pre>
auto_ptr (auto_ptr&lt;T> & ptr);
auto_ptr & operator = (auto_ptr&lt;T> & ptr);
</pre>
<p></p>
<p>这是因为它们确实改变了他们的源--剥夺了对资源的所有权。</p>
<p>通过定义相应的拷贝构造函数和重载赋值操作符，你可以将Transfer Semantics加入到许多对象中。例如，许多Windows中的资源，比如动态建立的菜单或者位图，可以用有Transfer Semantics的类来封装。</p>
<p>1.2.7 Strong Vectors</p>
<p>标准库只在auto_ptr中支持资源管理。甚至连最简单的容器也不支持ownership semantics。你可能想将auto_ptr和标准容器组合到一起可能会管用，但是并不是这样的。例如，你可能会这样做，但是会发现你不能够用标准的方法来进行索引。</p>
<p></p>
<pre>
vector&lt; auto_ptr&lt;Item> > autoVector;
</pre>
<p>这种建造不会编译成功；</p>
<p></p>
<pre>
Item * item = autoVector [0]; 
</pre>
<p>另一方面，这会导致一个从autoVect到auto_ptr的所有权转换：</p>
<p></p>
<pre>
auto_ptr&lt;Item> item = autoVector [0];
</pre>
<p>我们没有选择，只能够构造我们自己的Strong Vector。最小的接口应该如下：</p>
<p></p>
<pre>
template &lt;class T>
class auto_vector
{
public:
    explicit auto_vector (size_t capacity = 0);
    T const * operator [] (size_t i) const;
    T * operator [] (size_t i);
    void assign (size_t i, auto_ptr&lt;T> & p);
    void assign_direct (size_t i, T * p);
    void push_back (auto_ptr&lt;T> & p);
    auto_ptr&lt;T> pop_back ();
};
</pre>
<p></p>
<p>你也许会发现一个非常防御性的设计态度。我决定不提供一个对vector的左值索引的访问，取而代之，如果你想设定(set)一个值的话，你必须用assign或者assign_direct方法。我的观点是，资源管理不应该被忽视，同时，也不应该在所有的地方滥用。在我的经验里，一个strong vector经常被许多push_back方法充斥着。</p>
<p>Strong vector最好用一个动态的Strong Pointers的数组来实现：</p>
<p></p>
<pre>
template &lt;class T>
class auto_vector
{
    private
        void grow (size_t reqCapacity);
    auto_ptr&lt;T> *_arr;
    size_t _capacity;
    size_t _end;
};
</pre>
<p></p>
<p>grow方法申请了一个很大的auto_ptr<T>的数组，将所有的东西从老的书组类转移出来，在其中交换，并且删除原来的数组。</p>
<p>auto_vector的其他实现都是十分直接的，因为所有资源管理的复杂度都在auto_ptr中。例如，assign方法简单的利用了重载的赋值操作符来删除原有的对象并转移资源到新的对象：</p>
<p></p>
<pre>
void assign (size_t i, auto_ptr&lt;T> & p)
{
    _arr [i] = p;
}
</pre>
<p></p>
<p>我已经讨论了push_back和pop_back方法。push_back方法传值返回一个auto_ptr，因为它将所有权从auto_vector转换到auto_ptr中。</p>
<p>对auto_vector的索引访问是借助auto_ptr的get方法来实现的，get简单的返回一个内部指针。</p>
<p></p>
<pre>
T * operator [] (size_t i)
{
    return _arr [i].get ();
}
</pre>
<p></p>
<p>没有容器可以没有iterator。我们需要一个iterator让auto_vector看起来更像一个普通的指针向量。特别是，当我们废弃iterator的时候，我们需要的是一个指针而不是auto_ptr。我们不希望一个auto_vector的iterator在无意中进行资源转换。</p>
<p></p>
<pre>
template&lt;class T>
class auto_iterator: public
iterator&lt;random_access_iterator_tag, T *>
{
public:
    auto_iterator () : _pp (0) {}
    auto_iterator (auto_ptr&lt;T> * pp) : _pp (pp) {}
    bool operator != (auto_iterator&lt;T> const & it) const
    { return it._pp != _pp; }
    auto_iterator const & operator++ (int) { return _pp++; }
    auto_iterator operator++ () { return ++_pp; }
    T * operator * () { return _pp->get (); }
    private
        auto_ptr&lt;T> * _pp;
};
</pre>
<p></p>
<p>我们给auto_vect提供了标准的begin和end方法来找回iterator：</p>
<p></p>
<pre>
class auto_vector
{
public:
    typedef auto_iterator&lt;T> iterator;
    iterator begin () { return _arr; }
    iterator end () { return _arr + _end; }
};
</pre>
<p></p>
<p>你也许会问我们是否要利用资源管理重新实现每一个标准的容器？幸运的是，不;事实是strong vector解决了大部分所有权的需求。当你把你的对象都安全的放置到一个strong vector中，你可以用所有其它的容器来重新安排（weak）pointer。</p>
<p>设想，例如，你需要对一些动态分配的对象排序的时候。你将它们的指针保存到一个strong vector中。然后你用一个标准的vector来保存从strong vector中获得的weak指针。你可以用标准的算法对这个vector进行排序。这种中介vector叫做permutation vector。相似的，你也可以用标准的maps, priority queues, heaps, hash tables等等。</p>
<h4>1.2.8 Code Inspection</h4>
<p>如果你严格遵照资源管理的条款，你就不会再资源泄露或者两次删除的地方遇到麻烦。你也降低了访问野指针的几率。同样的，遵循原有的规则，用delete删除用new申请的德指针，不要两次删除一个指针。你也不会遇到麻烦。但是，那个是更好的注意呢？</p>
<p>这两个方法有一个很大的不同点。就是和寻找传统方法的bug相比，找到违反资源管理的规定要容易的多。后者仅需要一个代码检测或者一个运行测试，而前者则在代码中隐藏得很深，并需要很深的检查。</p>
<p>设想你要做一段传统的代码的内存泄露检查。第一件事，你要做的就是grep所有在代码中出现的new，你需要找出被分配空间地指针都作了什么。你需要确定导致删除这个指针的所有的执行路径。你需要检查break语句，过程返回，异常。原有的指针可能赋给另一个指针，你对这个指针也要做相同的事。</p>
<p>相比之下，对于一段用资源管理技术实现的代码。你也用grep检查所有的new，但是这次你只需要检查邻近的调用：</p>
<p>● 这是一个直接的Strong Pointer转换，还是我们在一个构造函数的函数体中？</p>
<p>● 调用的返回知是否立即保存到对象中，构造函数中是否有可以产生异常的代码。？</p>
<p>● 如果这样的话析构函数中时候有delete</p>
<p>下一步，你需要用grep查找所有的release方法，并实施相同的检查。</p>
<p>不同点是需要检查、理解单个执行路径和只需要做一些本地的检验。这难道不是提醒你非结构化的和结构化的程序设计的不同吗？原理上，你可以认为你可以应付goto，并且跟踪所有的可能分支。另一方面，你可以将你的怀疑本地化为一段代码。本地化在两种情况下都是关键所在。</p>
<p>在资源管理中的错误模式也比较容易调试。最常见的bug是试图访问一个释放过的strong pointer。这将导致一个错误，并且很容易跟踪。</p>
<h4>1.2.9 共享的所有权</h4>
<p>为每一个程序中的资源都找出或者指定一个所有者是一件很容易的事情吗？答案是出乎意料的，是！如果你发现了一些问题，这可能说明你的设计上存在问题。还有另一种情况就是共享所有权是最好的甚至是唯一的选择。</p>
<p>共享的责任分配给被共享的对象和它的客户（client）。一个共享资源必须为它的所有者保持一个引用计数。另一方面，所有者再释放资源的时候必须通报共享对象。最后一个释放资源的需要在最后负责free的工作。</p>
<p>最简单的共享的实现是共享对象继承引用计数的类RefCounted：</p>
<p></p>
<pre>
class RefCounted
{
public:
    RefCounted () : _count (1) {}
    int GetRefCount () const { return _count; }
    void IncRefCount () { _count++; }
    int DecRefCount () { return --_count; }
private
    int _count;
};
</pre>
<p></p>
<p>按照资源管理，一个引用计数是一种资源。如果你遵守它，你需要释放它。当你意识到这一事实的时候，剩下的就变得简单了。简单的遵循规则--再构造函数中获得引用计数，在析构函数中释放。甚至有一个RefCounted的smart pointer等价物：</p>
<p></p>
<pre>
template &lt;class T>
class RefPtr
{
public:
    RefPtr (T * p) : _p (p) {}
    RefPtr (RefPtr&lt;T> & p)
    {
        _p = p._p;
        _p->IncRefCount ();
    }
    ~RefPtr ()
    {
        if (_p->DecRefCount () == 0)
            delete _p;
    }
    private
        T * _p;
};
</pre>
<p></p>
<p>注意模板中的T不比成为RefCounted的后代，但是它必须有IncRefCount和DecRefCount的方法。当然，一个便于使用的RefPtr需要有一个重载的指针访问操作符。在RefPtr中加入转换语义学（transfer semantics）是读者的工作。</p>
<p>1.2.10 所有权网络</p>
<p>链表是资源管理分析中的一个很有意思的例子。如果你选择表成为链(link)的所有者的话，你会陷入实现递归的所有权。每一个link都是它的继承者的所有者，并且，相应的，余下的链表的所有者。下面是用smart pointer实现的一个表单元：</p>
<p></p>
<pre>
class Link
{
    // ...
private:
    auto_ptr&lt;Link> _next;
};
</pre>
<p>最好的方法是，将连接控制封装到一个弄构进行资源转换的类中。</p>
<p>对于双链表呢？安全的做法是指明一个方向，如forward:</p>
<pre>
class DoubleLink
{
    // ...
private
    DoubleLink *_prev;
    auto_ptr&lt;DoubleLink> _next;
};
</pre>
<p></p>
<p>注意不要创建环形链表。</p>
<p>这给我们带来了另外一个有趣的问题--资源管理可以处理环形的所有权吗？它可以，用一个mark-and-sweep的算法。这里是实现这种方法的一个例子：</p>
<p></p>
<pre>
template&lt;class T>
class CyclPtr
{
public:
    CyclPtr (T * p)
        :_p (p), _isBeingDeleted (false)
    {}
    ~CyclPtr ()
    {
        _isBeingDeleted = true;
        if (!_p->IsBeingDeleted ())
            delete _p;
    }
    void Set (T * p)
    {
        _p = p;
    }
    bool IsBeingDeleted () const { return _isBeingDeleted; }
    private
        T * _p;
    bool _isBeingDeleted;
};
</pre>
<p></p>
<p>注意我们需要用class T来实现方法IsBeingDeleted，就像从CyclPtr继承。对特殊的所有权网络普通化是十分直接的。</p>
<p>将原有代码转换为资源管理代码</p>
<p>如果你是一个经验丰富的程序员，你一定会知道找资源的bug是一件浪费时间的痛苦的经历。我不必说服你和你的团队花费一点时间来熟悉资源管理是十分值得的。你可以立即开始用这个方法，无论你是在开始一个新项目或者是在一个项目的中期。转换不必立即全部完成。下面是步骤。</p>
<p>首先，在你的工程中建立基本的Strong Pointer。然后通过查找代码中的new来开始封装裸指针。</p>
<p>最先封装的是在过程中定义的临时指针。简单的将它们替换为auto_ptr并且删除相应的delete。如果一个指针在过程中没有被删除而是被返回，用auto_ptr替换并在返回前调用release方法。在你做第二次传递的时候，你需要处理对release的调用。注意，即使是在这点，你的代码也可能更加"精力充沛"--你会移出代码中潜在的资源泄漏问题。</p>
<p>下面是指向资源的裸指针。确保它们被独立的封装到auto_ptr中，或者在构造函数中分配在析构函数中释放。如果你有传递所有权的行为的话，需要调用release方法。如果你有容器所有对象，用Strong Pointers重新实现它们。</p>
<p>接下来，找到所有对release的方法调用并且尽力清除所有，如果一个release调用返回一个指针，将它修改传值返回一个auto_ptr。</p>
<p>重复着一过程，直到最后所有new和release的调用都在构造函数或者资源转换的时候发生。这样，你在你的代码中处理了资源泄漏的问题。对其他资源进行相似的操作。</p>
<p>你会发现资源管理清除了许多错误和异常处理带来的复杂性。不仅仅你的代码会变得精力充沛，它也会变得简单并容易维护。</p>
<h3>2 内存泄漏</h3>
<h4>2.1 C++中动态内存分配引发问题的解决方案</h4>
<p>假设我们要开发一个String类，它可以方便地处理字符串数据。我们可以在类中声明一个数组，考虑到有时候字符串极长，我们可以把数组大小设为200，但一般的情况下又不需要这么多的空间，这样是浪费了内存。对了，我们可以使用new操作符，这样是十分灵活的，但在类中就会出现许多意想不到的问题，本文就是针对这一现象而写的。现在，我们先来开发一个String类，但它是一个不完善的类。的确，我们要刻意地使它出现各种各样的问题，这样才好对症下药。好了，我们开始吧！</p>
<p></p>
<pre>
/* String.h */
#ifndef STRING_H_
#define STRING_H_
class String
{
private:
    char * str;     // 存储数据
    int len;         // 字符串长度
public:
    String(const char * s); // 构造函数
    String();         // 默认构造函数
    ~String();         // 析构函数
    friend ostream & operator＜＜(ostream & os,const String& st);
};
#endif

/*String.cpp*/
#include ＜iostream＞
#include ＜cstring＞
#include "String.h"
using namespace std;

String::String(const char * s) // 拷贝数据
{
    len = strlen(s);
    str = new char[len + 1];
    strcpy(str, s);
}

String::String()
{
    len =0;
    str = new char[len+1];
    str[0]='{post.content}';
}

String::~String()
{
    cout＜＜"这个字符串将被删除："＜＜str＜＜'/n';//为了方便观察结果，特留此行代码。
    delete [] str;
}

ostream & operator＜＜(ostream & os, const String & st)
{
    os ＜＜ st.str;
    return os;
}

/*test_right.cpp*/
#include ＜iostream＞
#include ＜stdlib.h＞
#include "String.h"
using namespace std;

int main()
{
    String temp("天极网");
    cout＜＜temp＜＜'/n';
    system("PAUSE");
    return 0;
}
</pre>
<p>运行结果：</p>
<p></p>
<p>天极网</p>
<p>大家可以看到，以上程序十分正确，而且也是十分有用的。可是，我们不能被表面现象所迷惑！下面，请大家用test_String.cpp文件替换test_right.cpp文件进行编译，看看结果。有的编译器可能就是根本不能进行编译！</p>
<p>test_String.cpp:</p>
<p></p>
<pre>
#include ＜iostream＞
#include ＜stdlib.h＞
#include "String.h"
using namespace std;

void show_right(const String&);
void show_String(const String);//注意，参数非引用，而是按值传递。
int main()
{
    String test1("第一个范例。");
    String test2("第二个范例。");
    String test3("第三个范例。");
    String test4("第四个范例。");
    cout＜＜"下面分别输入三个范例：/n";
    cout＜＜test1＜＜endl;
    cout＜＜test2＜＜endl;
    cout＜＜test3＜＜endl;
    String* String1=new String(test1);
    cout＜＜*String1＜＜endl;
    delete String1;
    cout＜＜test1＜＜endl; //在Dev-cpp上没有任何反应。
    cout＜＜"使用正确的函数："＜＜endl;
    show_right(test2);
    cout＜＜test2＜＜endl;
    cout＜＜"使用错误的函数："＜＜endl;
    show_String(test2);
    cout＜＜test2＜＜endl; //这一段代码出现严重的错误！
    String String2(test3);
    cout＜＜"String2: "＜＜String2＜＜endl;
    String String3;
    String3=test4;
    cout＜＜"String3: "＜＜String3＜＜endl;
    cout＜＜"下面，程序结束，析构函数将被调用。"＜＜endl;
    return 0;
}
void show_right(const String& a)
{
    cout＜＜a＜＜endl;
}
void show_String(const String a)
{
    cout＜＜a＜＜endl;
}
</pre>
<p>运行结果：</p>
<p></p>

<pre>
下面分别输入三个范例：
第一个范例。
第二个范例。
第三个范例。
第一个范例。
这个字符串将被删除：第一个范例。
使用正确的函数：

第二个范例。
第二个范例。
使用错误的函数：
第二个范例。
这个字符串将被删除：第二个范例。
这个字符串将被删除：?=
?=
String2: 第三个范例。
String3: 第四个范例。
下面，程序结束，析构函数将被调用。
这个字符串将被删除：第四个范例。
这个字符串将被删除：第三个范例。
这个字符串将被删除：?=
这个字符串将被删除：x =
这个字符串将被删除：?=
这个字符串将被删除：
</pre>

<p></p>
<p>现在，请大家自己试试运行结果，或许会更加惨不忍睹呢！下面，我为大家一一分析原因。</p>
<p>首先，大家要知道，C＋＋类有以下这些极为重要的函数：</p>
<p>一：复制构造函数。</p>
<p>二：赋值函数。</p>
<p>我们先来讲复制构造函数。什么是复制构造函数呢？比如，我们可以写下这样的代码：String test1(test2);这是进行初始化。我们知道，初始化对象要用构造函数。可这儿呢？按理说，应该有声明为这样的构造函数：String(const String &);可是，我们并没有定义这个构造函数呀？答案是，C＋＋提供了默认的复制构造函数，问题也就出在这儿。</p>
<p>（1）：什么时候会调用复制构造函数呢？（以String类为例。）</p>
<p>在我们提供这样的代码：String test1(test2)时，它会被调用；当函数的参数列表为按值传递，也就是没有用引用和指针作为类型时，如：void show_String(const String)，它会被调用。其实，还有一些情况，但在这儿就不列举了。</p>
<p>（2）：它是什么样的函数。</p>
<p>它的作用就是把两个类进行复制。拿String类为例，C＋＋提供的默认复制构造函数是这样的：</p>
<p></p>
<pre>
String(const String& a)
{
    str=a.str;
    len=a.len;
}
</pre>
<p>在平时，这样并不会有任何的问题出现，但我们用了new操作符，涉及到了动态内存分配，我们就不得不谈谈浅复制和深复制了。以上的函数就是实行的浅复制，它只是复制了指针，而并没有复制指针指向的数据，可谓一点儿用也没有。打个比方吧！就像一个朋友让你把一个程序通过网络发给他，而你大大咧咧地把快捷方式发给了他，有什么用处呢？我们来具体谈谈：</p>
<p>假如，A对象中存储了这样的字符串：“C＋＋”。它的地址为2000。现在，我们把A对象赋给B对象：String B=A。现在，A和B对象的str指针均指向2000地址。看似可以使用，但如果B对象的析构函数被调用时，则地址2000处的字符串“C＋＋”已经被从内存中抹去，而A对象仍然指向地址2000。这时，如果我们写下这样的代码：cout＜＜A＜＜endl;或是等待程序结束，A对象的析构函数被调用时，A对象的数据能否显示出来呢？只会是乱码。而且，程序还会这样做：连续对地址2000处使用两次delete操作符，这样的后果是十分严重的！</p>
<p>本例中，有这样的代码：</p>
<p></p>
<pre>
String* String1=new String(test1);
cout＜＜*String1＜＜endl;
delete String1;
</pre>
<p>假设test1中str指向的地址为2000,而String中str指针同样指向地址2000，我们删除了2000处的数据，而test1对象呢？已经被破坏了。大家从运行结果上可以看到，我们使用cout＜＜test1时，一点反应也没有。而在test1的析构函数被调用时，显示是这样：“这个字符串将被删除：”。</p>
<p>再看看这段代码：</p>
<p></p>
<pre>
cout＜＜"使用错误的函数："＜＜endl;
show_String(test2);
cout＜＜test2＜＜endl;//这一段代码出现严重的错误！
</pre>
<p>show_String函数的参数列表void show_String(const String a)是按值传递的，所以，我们相当于执行了这样的代码：String a=test2;函数执行完毕，由于生存周期的缘故，对象a被析构函数删除，我们马上就可以看到错误的显示结果了：这个字符串将被删除：?=。当然，test2也被破坏了。解决的办法很简单，当然是手工定义一个复制构造函数喽！人力可以胜天！</p>
<p></p>
<pre>
String::String(const String& a)
{
    len=a.len;
    str=new char(len+1);
    strcpy(str,a.str);
}
</pre>
<p>我们执行的是深复制。这个函数的功能是这样的：假设对象A中的str指针指向地址2000，内容为“I am a C++ Boy!”。我们执行代码String B=A时，我们先开辟出一块内存，假设为3000。我们用strcpy函数将地址2000的内容拷贝到地址3000中，再将对象B的str指针指向地址3000。这样，就互不干扰了。</p>
<p>大家把这个函数加入程序中，问题就解决了大半，但还没有完全解决，问题在赋值函数上。我们的程序中有这样的段代码：</p>
<p></p>
<pre>
String String3;
String3=test4;
</pre>
<p>经过我前面的讲解，大家应该也会对这段代码进行寻根摸底：凭什么可以这样做：String3=test4？？？原因是，C＋＋为了用户的方便，提供的这样的一个操作符重载函数：operator=。所以，我们可以这样做。大家应该猜得到，它同样是执行了浅复制，出了同样的毛病。比如，执行了这段代码后，析构函数开始大展神威^_^。由于这些变量是后进先出的，所以最后的String3变量先被删除：这个字符串将被删除：第四个范例。很正常。最后，删除到test4的时候，问题来了：这个字符串将被删除：?=。原因我不用赘述了，只是这个赋值函数怎么写，还有一点儿学问呢！大家请看：</p>
<p>平时，我们可以写这样的代码：x=y=z。（均为整型变量。）而在类对象中，我们同样要这样，因为这很方便。而对象A=B=C就是A.operator=(B.operator=(c))。而这个operator=函数的参数列表应该是：const String& a，所以，大家不难推出，要实现这样的功能，返回值也要是String&，这样才能实现A＝B＝C。我们先来写写看：</p>
<p></p>
<pre>
String& String::operator=(const String& a)
{
    delete [] str;//先删除自身的数据
    len=a.len;
    str=new char[len+1];
    strcpy(str,a.str);//此三行为进行拷贝
    return *this;//返回自身的引用
}
</pre>
<p>是不是这样就行了呢？我们假如写出了这种代码：A=A，那么大家看看，岂不是把A对象的数据给删除了吗？这样可谓引发一系列的错误。所以，我们还要检查是否为自身赋值。只比较两对象的数据是不行了，因为两个对象的数据很有可能相同。我们应该比较地址。以下是完好的赋值函数：</p>
<p></p>
<pre>
String& String::operator=(const String& a)
{
    if(this==&a)
        return *this;
    delete [] str;
    len=a.len;
    str=new char[len+1];
    strcpy(str,a.str);
    return *this;
}
</pre>
<p>把这些代码加入程序，问题就完全解决，下面是运行结果：</p>
<p></p>

<pre>
下面分别输入三个范例：
第一个范例
第二个范例
第三个范例
第一个范例
这个字符串将被删除：第一个范例。
第一个范例
使用正确的函数：
第二个范例。
第二个范例。
使用错误的函数：
第二个范例。
这个字符串将被删除：第二个范例。
第二个范例。
String2: 第三个范例。
String3: 第四个范例。
下面，程序结束，析构函数将被调用。
这个字符串将被删除：第四个范例。
这个字符串将被删除：第三个范例。
这个字符串将被删除：第四个范例。
这个字符串将被删除：第三个范例。
这个字符串将被删除：第二个范例。
这个字符串将被删除：第一个范例。
</pre>

<h4>2.2 如何对付内存泄漏？</h4>
<p>写出那些不会导致任何内存泄漏的代码。很明显，当你的代码中到处充满了new 操作、delete操作和指针运算的话，你将会在某个地方搞晕了头，导致内存泄漏，指针引用错误，以及诸如此类的问题。这和你如何小心地对待内存分配工作其实完全没有关系：代码的复杂性最终总是会超过你能够付出的时间和努力。于是随后产生了一些成功的技巧，它们依赖于将内存分配（allocations）与重新分配（deallocation）工作隐藏在易于管理的类型之后。标准容器（standard containers）是一个优秀的例子。它们不是通过你而是自己为元素管理内存，从而避免了产生糟糕的结果。想象一下，没有string和vector的帮助，写出这个：</p>
<p></p>

<pre>
#include&lt;vector>
#include&lt;string>
#include&lt;iostream>
#include&lt;algorithm>
using namespace std;
int main() // small program messing around with strings
{
    cout &lt;&lt; "enter some whitespace-separated words:/n";
    vector&lt;string> v;
    string s;
    while (cin&gt;&gt;s) 
        v.push_back(s);
    sort(v.begin(),v.end());
    string cat;
    typedef vector&lt;string>::const_iterator Iter;
    for (Iter p = v.begin(); p!=v.end(); ++p) 
        cat += *p+"+";
    cout &lt;&lt; cat &lt;&lt; '/n';
}
</pre>
<p>你有多少机会在第一次就得到正确的结果？你又怎么知道你没有导致内存泄漏呢？</p>
<p>注意，没有出现显式的内存管理，宏，造型，溢出检查，显式的长度限制，以及指针。通过使用函数对象和标准算法（standard algorithm），我可以避免使用指针——例如使用迭代子（iterator），不过对于一个这么小的程序来说有点小题大作了。</p>
<p>这些技巧并不完美，要系统化地使用它们也并不总是那么容易。但是，应用它们产生了惊人的差异，而且通过减少显式的内存分配与重新分配的次数，你甚至可以使余下的例子更加容易被跟踪。早在1981年，我就指出，通过将我必须显式地跟踪的对象的数量从几万个减少到几打，为了使程序正确运行而付出的努力从可怕的苦工，变成了应付一些可管理的对象，甚至更加简单了。</p>
<p>如果你的程序还没有包含将显式内存管理减少到最小限度的库，那么要让你程序完成和正确运行的话，最快的途径也许就是先建立一个这样的库。</p>
<p>模板和标准库实现了容器、资源句柄以及诸如此类的东西，更早的使用甚至在多年以前。异常的使用使之更加完善。</p>
<p>如果你实在不能将内存分配/重新分配的操作隐藏到你需要的对象中时，你可以使用资源句柄（resource handle），以将内存泄漏的可能性降至最低。这里有个例子：我需要通过一个函数，在空闲内存中建立一个对象并返回它。这时候可能忘记释放这个对象。毕竟，我们不能说，仅仅关注当这个指针要被释放的时候，谁将负责去做。使用资源句柄，这里用了标准库中的auto_ptr，使需要为之负责的地方变得明确了。</p>
<p></p>

<pre>
#include&lt;memory>
#include&lt;iostream>
using namespace std;
struct S 
{
    S() { cout &lt;&lt; "make an S/n"; }
    ~S() { cout &lt;&lt; "destroy an S/n"; }
    S(const S&) { cout &lt;&lt; "copy initialize an S/n"; }
    S& operator=(const S&) { cout &lt;&lt; "copy assign an S/n"; }
};
S* f()
{
    return new S; // 谁该负责释放这个S？
};
auto_ptr&lt;S> g()
{
    return auto_ptr&lt;S>(new S); // 显式传递负责释放这个S
}
int main()
{
    cout &lt;&lt; "start main/n";
    S* p = f();
    cout &lt;&lt; "after f() before g()/n";
    // S* q = g(); // 将被编译器捕捉
    auto_ptr&lt;S> q = g();
    cout &lt;&lt; "exit main/n";
    // *p产生了内存泄漏
    // *q被自动释放
}
</pre>

<p>在更一般的意义上考虑资源，而不仅仅是内存。</p>
<p>如果在你的环境中不能系统地应用这些技巧（例如，你必须使用别的地方的代码，或者你的程序的另一部分简直是原始人类（译注：原文是Neanderthals，尼安德特人，旧石器时代广泛分布在欧洲的猿人）写的，如此等等），那么注意使用一个内存泄漏检测器作为开发过程的一部分，或者插入一个垃圾收集器（garbage collector）。</p>


<h4>2.3 浅谈C/C++内存泄漏及其检测工具</h4>
<p>对于一个c/c++程序员来说，内存泄漏是一个常见的也是令人头疼的问题。已经有许多技术被研究出来以应对这个问题，比如Smart Pointer，Garbage Collection等。Smart Pointer技术比较成熟，STL中已经包含支持Smart Pointer的class，但是它的使用似乎并不广泛，而且它也不能解决所有的问题；Garbage Collection技术在Java中已经比较成熟，但是在c/c++领域的发展并不顺畅，虽然很早就有人思考在C++中也加入GC的支持。现实世界就是这样的，作为一个c/c++程序员，内存泄漏是你心中永远的痛。不过好在现在有许多工具能够帮助我们验证内存泄漏的存在，找出发生问题的代码。</p>
<p>2.3.1 内存泄漏的定义</p>
<p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。以下这段小程序演示了堆内存发生泄漏的情形：</p>
<p></p>
<pre>
void MyFunction(int nSize)
{
char* p= new char[nSize];
if( !GetStringFrom( p, nSize ) ){
MessageBox(“Error”);
return;
}
…//using the string pointed by p;
delete p;
}
</pre>
<p>当函数GetStringFrom()返回零的时候，指针p指向的内存就不会被释放。这是一种常见的发生内存泄漏的情形。程序在入口处分配内存，在出口处释放内存，但是c函数可以在任何地方退出，所以一旦有某个出口处没有释放应该释放的内存，就会发生内存泄漏。</p>
<p>广义的说，内存泄漏不仅仅包含堆内存的泄漏，还包含系统资源的泄漏(resource leak)，比如核心态HANDLE，GDI Object，SOCKET， Interface等，从根本上说这些由操作系统分配的对象也消耗内存，如果这些对象发生泄漏最终也会导致内存的泄漏。而且，某些对象消耗的是核心态内存，这些对象严重泄漏时会导致整个操作系统不稳定。所以相比之下，系统资源的泄漏比堆内存的泄漏更为严重。</p>
<p>GDI Object的泄漏是一种常见的资源泄漏：</p>
<p></p>
<pre>
void CMyView::OnPaint( CDC* pDC )
{
CBitmap bmp;
CBitmap* pOldBmp;
bmp.LoadBitmap(IDB_MYBMP);
pOldBmp = pDC->SelectObject( &bmp );
…
if( Something() ){
return;
}
pDC->SelectObject( pOldBmp );
return;
}
</pre>
<p>当函数Something()返回非零的时候，程序在退出前没有把pOldBmp选回pDC中，这会导致pOldBmp指向的HBITMAP对象发生泄漏。这个程序如果长时间的运行，可能会导致整个系统花屏。这种问题在Win9x下比较容易暴露出来，因为Win9x的GDI堆比Win2k或NT的要小很多。</p>
<p>2.3.2 内存泄漏的发生方式</p>
<p>以发生的方式来分类，内存泄漏可以分为4类：</p>
<p>1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。比如例二，如果Something()函数一直返回True，那么pOldBmp指向的HBITMAP对象总是发生泄漏。</p>
<p>2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。比如例二，如果Something()函数只有在特定环境下才返回True，那么pOldBmp指向的HBITMAP对象并不总是发生泄漏。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。</p>
<p>3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，但是因为这个类是一个Singleton，所以内存泄漏只会发生一次。另一个例子：</p>
<p></p>
<pre>
char* g_lpszFileName = NULL;
void SetFileName( const char* lpcszFileName )
{
if( g_lpszFileName ){
free( g_lpszFileName );
}
g_lpszFileName = strdup( lpcszFileName );
}
</pre>
<p>如果程序在结束的时候没有释放g_lpszFileName指向的字符串，那么，即使多次调用SetFileName()，总会有一块内存，而且仅有一块内存发生泄漏。</p>
<p>4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。举一个例子：</p>
<p></p>
<pre>
class Connection
{
public:
Connection( SOCKET s);
~Connection();
…
private:
SOCKET _socket;
…
};
class ConnectionManager
{
public:
ConnectionManager(){}
~ConnectionManager(){
list::iterator it;
for( it = _connlist.begin(); it != _connlist.end(); ++it ){
delete （*it）;
}
_connlist.clear();
}
void OnClientConnected( SOCKET s ){
Connection* p = new Connection(s);
_connlist.push_back(p);
}
void OnClientDisconnected( Connection* pconn ){
_connlist.remove( pconn );
delete pconn;
}
private:
list _connlist;
};
</pre>
<p>假设在Client从Server端断开后，Server并没有呼叫OnClientDisconnected()函数，那么代表那次连接的Connection对象就不会被及时的删除（在Server程序退出的时候，所有Connection对象会在ConnectionManager的析构函数里被删除）。当不断的有连接建立、断开时隐式内存泄漏就发生了。</p>
<p>从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。</p>
<p>2.3.3 检测内存泄漏</p>
<p>检测内存泄漏的关键是要能截获住对分配内存和释放内存的函数的调用。截获住这两个函数，我们就能跟踪每一块内存的生命周期，比如，每当成功的分配一块内存后，就把它的指针加入一个全局的list中；每当释放一块内存，再把它的指针从list中删除。这样，当程序结束的时候，list中剩余的指针就是指向那些没有被释放的内存。这里只是简单的描述了检测内存泄漏的基本原理，详细的算法可以参见Steve Maguire的&lt;&lt;Writing Solid Code>>。</p>
<p>如果要检测堆内存的泄漏，那么需要截获住malloc/realloc/free和new/delete就可以了（其实new/delete最终也是用malloc/free的，所以只要截获前面一组即可）。对于其他的泄漏，可以采用类似的方法，截获住相应的分配和释放函数。比如，要检测BSTR的泄漏，就需要截获SysAllocString/SysFreeString；要检测HMENU的泄漏，就需要截获CreateMenu/ DestroyMenu。（有的资源的分配函数有多个，释放函数只有一个，比如，SysAllocStringLen也可以用来分配BSTR，这时就需要截获多个分配函数）</p>
<p>在Windows平台下，检测内存泄漏的工具常用的一般有三种，MS C-Runtime Library内建的检测功能；外挂式的检测工具，诸如，Purify，BoundsChecker等；利用Windows NT自带的Performance Monitor。这三种工具各有优缺点，MS C-Runtime Library虽然功能上较之外挂式的工具要弱，但是它是免费的；Performance Monitor虽然无法标示出发生问题的代码，但是它能检测出隐式的内存泄漏的存在，这是其他两类工具无能为力的地方。</p>
<p>以下我们详细讨论这三种检测工具：</p>
<p>2.3.3.1 VC下内存泄漏的检测方法</p>
<p>用MFC开发的应用程序，在DEBUG版模式下编译后，都会自动加入内存泄漏的检测代码。在程序结束后，如果发生了内存泄漏，在Debug窗口中会显示出所有发生泄漏的内存块的信息，以下两行显示了一块被泄漏的内存块的信息：</p>
<p>E:/TestMemLeak/TestDlg.cpp(70) : {59} normal block at 0x00881710, 200 bytes long.</p>
<p>Data: <abcdefghijklmnop> 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70</p>
<p>第一行显示该内存块由TestDlg.cpp文件，第70行代码分配，地址在0x00881710，大小为200字节，{59}是指调用内存分配函数的Request Order，关于它的详细信息可以参见MSDN中_CrtSetBreakAlloc()的帮助。第二行显示该内存块前16个字节的内容，尖括号内是以ASCII方式显示，接着的是以16进制方式显示。</p>
<p>一般大家都误以为这些内存泄漏的检测功能是由MFC提供的，其实不然。MFC只是封装和利用了MS C-Runtime Library的Debug Function。非MFC程序也可以利用MS C-Runtime Library的Debug Function加入内存泄漏的检测功能。MS C-Runtime Library在实现malloc/free，strdup等函数时已经内建了内存泄漏的检测功能。</p>
<p>注意观察一下由MFC Application Wizard生成的项目，在每一个cpp文件的头部都有这样一段宏定义：</p>
<p></p>
<pre>
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
</pre>
<p>有了这样的定义，在编译DEBUG版时，出现在这个cpp文件中的所有new都被替换成DEBUG_NEW了。那么DEBUG_NEW是什么呢？DEBUG_NEW也是一个宏，以下摘自afx.h，1632行</p>
<p></p>
<pre>
#define DEBUG_NEW new(THIS_FILE, __LINE__)
</pre>
<p>所以如果有这样一行代码：</p>
<p></p>
<pre>
char* p = new char[200];
</pre>
<p>经过宏替换就变成了：</p>
<p></p>
<p>char* p = new( THIS_FILE, __LINE__)char[200];</p>
<p>根据C++的标准，对于以上的new的使用方法，编译器会去找这样定义的operator new：</p>
<p></p>
<pre>
void* operator new(size_t, LPCSTR, int)
</pre>
<p>我们在afxmem.cpp 63行找到了一个这样的operator new 的实现</p>
<p></p>
<
<pre>
p>void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
{
return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}
void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)
{
…
pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);
if (pResult != NULL)
return pResult;
…
}
</pre>
<p>第二个operator new函数比较长，为了简单期间，我只摘录了部分。很显然最后的内存分配还是通过_malloc_dbg函数实现的，这个函数属于MS C-Runtime Library 的Debug Function。这个函数不但要求传入内存的大小，另外还有文件名和行号两个参数。文件名和行号就是用来记录此次分配是由哪一段代码造成的。如果这块内存在程序结束之前没有被释放，那么这些信息就会输出到Debug窗口里。</p>
<p>这里顺便提一下THIS_FILE，__FILE和__LINE__。__FILE__和__LINE__都是编译器定义的宏。当碰到__FILE__时，编译器会把__FILE__替换成一个字符串，这个字符串就是当前在编译的文件的路径名。当碰到__LINE__时，编译器会把__LINE__替换成一个数字，这个数字就是当前这行代码的行号。在DEBUG_NEW的定义中没有直接使用__FILE__，而是用了THIS_FILE，其目的是为了减小目标文件的大小。假设在某个cpp文件中有100处使用了new，如果直接使用__FILE__，那编译器会产生100个常量字符串，这100个字符串都是飧?/SPAN>cpp文件的路径名，显然十分冗余。如果使用THIS_FILE，编译器只会产生一个常量字符串，那100处new的调用使用的都是指向常量字符串的指针。</p>
<p>再次观察一下由MFC Application Wizard生成的项目，我们会发现在cpp文件中只对new做了映射，如果你在程序中直接使用malloc函数分配内存，调用malloc的文件名和行号是不会被记录下来的。如果这块内存发生了泄漏，MS C-Runtime Library仍然能检测到，但是当输出这块内存块的信息，不会包含分配它的的文件名和行号。</p>
<p>要在非MFC程序中打开内存泄漏的检测功能非常容易，你只要在程序的入口处加入以下几行代码：</p>
<p></p>
<pre>
int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
_CrtSetDbgFlag( tmpFlag );
</pre>
<p>这样，在程序结束的时候，也就是winmain，main或dllmain函数返回之后，如果还有内存块没有释放，它们的信息会被打印到Debug窗口里。</p>
<p>如果你试着创建了一个非MFC应用程序，而且在程序的入口处加入了以上代码，并且故意在程序中不释放某些内存块，你会在Debug窗口里看到以下的信息：</p>
<p></p>
<p>{47} normal block at 0x00C91C90, 200 bytes long.</p>
<p>Data: < > 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</p>
<p>内存泄漏的确检测到了，但是和上面MFC程序的例子相比，缺少了文件名和行号。对于一个比较大的程序，没有这些信息，解决问题将变得十分困难。</p>
<p>为了能够知道泄漏的内存块是在哪里分配的，你需要实现类似MFC的映射功能，把new，maolloc等函数映射到_malloc_dbg函数上。这里我不再赘述，你可以参考MFC的源代码。</p>
<p>由于Debug Function实现在MS C-RuntimeLibrary中，所以它只能检测到堆内存的泄漏，而且只限于malloc，realloc或strdup等分配的内存，而那些系统资源，比如HANDLE，GDI Object，或是不通过C-Runtime Library分配的内存，比如VARIANT，BSTR的泄漏，它是无法检测到的，这是这种检测法的一个重大的局限性。另外，为了能记录内存块是在哪里分配的，源代码必须相应的配合，这在调试一些老的程序非常麻烦，毕竟修改源代码不是一件省心的事，这是这种检测法的另一个局限性。</p>
<p>对于开发一个大型的程序，MS C-Runtime Library提供的检测功能是远远不够的。接下来我们就看看外挂式的检测工具。我用的比较多的是BoundsChecker，一则因为它的功能比较全面，更重要的是它的稳定性。这类工具如果不稳定，反而会忙里添乱。到底是出自鼎鼎大名的NuMega，我用下来基本上没有什么大问题。</p>
<h4>2.3.3.2 使用BoundsChecker检测内存泄漏</h4>
<p>BoundsChecker采用一种被称为 Code Injection的技术，来截获对分配内存和释放内存的函数的调用。简单地说，当你的程序开始运行时，BoundsChecker的DLL被自动载入进程的地址空间（这可以通过system-level的Hook实现），然后它会修改进程中对内存分配和释放的函数调用，让这些调用首先转入它的代码，然后再执行原来的代码。BoundsChecker在做这些动作的时，无须修改被调试程序的源代码或工程配置文件，这使得使用它非常的简便、直接。</p>
<p>这里我们以malloc函数为例，截获其他的函数方法与此类似。</p>
<p>需要被截获的函数可能在DLL中，也可能在程序的代码里。比如，如果静态连结C-Runtime Library，那么malloc函数的代码会被连结到程序里。为了截获住对这类函数的调用，BoundsChecker会动态修改这些函数的指令。</p>
<p>以下两段汇编代码，一段没有BoundsChecker介入，另一段则有BoundsChecker的介入：</p>
<p></p>
<pre>
126: _CRTIMP void * __cdecl malloc (
127: size_t nSize
128: )
129: {
00403C10 push ebp
00403C11 mov ebp,esp
130: return _nh_malloc_dbg(nSize, _newmode, _NORMAL_BLOCK, NULL, 0);
00403C13 push 0
00403C15 push 0
00403C17 push 1
00403C19 mov eax,[__newmode (0042376c)]
00403C1E push eax
00403C1F mov ecx,dword ptr [nSize]
00403C22 push ecx
00403C23 call _nh_malloc_dbg (00403c80)
00403C28 add esp,14h
131: }
</pre>
<p>以下这一段代码有BoundsChecker介入：</p>
<p></p>
<pre>
126: _CRTIMP void * __cdecl malloc (
127: size_t nSize
128: )
129: {
00403C10 jmp 01F41EC8
00403C15 push 0
00403C17 push 1
00403C19 mov eax,[__newmode (0042376c)]
00403C1E push eax
00403C1F mov ecx,dword ptr [nSize]
00403C22 push ecx
00403C23 call _nh_malloc_dbg (00403c80)
00403C28 add esp,14h
131: }
</pre>
<p>当BoundsChecker介入后，函数malloc的前三条汇编指令被替换成一条jmp指令，原来的三条指令被搬到地址01F41EC8处了。当程序进入malloc后先jmp到01F41EC8，执行原来的三条指令，然后就是BoundsChecker的天下了。大致上它会先记录函数的返回地址（函数的返回地址在stack上，所以很容易修改），然后把返回地址指向属于BoundsChecker的代码，接着跳到malloc函数原来的指令，也就是在00403c15的地方。当malloc函数结束的时候，由于返回地址被修改，它会返回到BoundsChecker的代码中，此时BoundsChecker会记录由malloc分配的内存的指针，然后再跳转到到原来的返回地址去。</p>
<p>如果内存分配/释放函数在DLL中，BoundsChecker则采用另一种方法来截获对这些函数的调用。BoundsChecker通过修改程序的DLL Import Table让table中的函数地址指向自己的地址，以达到截获的目的。</p>
<p>截获住这些分配和释放函数，BoundsChecker就能记录被分配的内存或资源的生命周期。接下来的问题是如何与源代码相关，也就是说当BoundsChecker检测到内存泄漏，它如何报告这块内存块是哪段代码分配的。答案是调试信息（Debug Information）。当我们编译一个Debug版的程序时，编译器会把源代码和二进制代码之间的对应关系记录下来，放到一个单独的文件里(.pdb)或者直接连结进目标程序，通过直接读取调试信息就能得到分配某块内存的源代码在哪个文件，哪一行上。使用Code Injection和Debug Information，使BoundsChecker不但能记录呼叫分配函数的源代码的位置，而且还能记录分配时的Call Stack，以及Call Stack上的函数的源代码位置。这在使用像MFC这样的类库时非常有用，以下我用一个例子来说明：</p>
<p></p>
<pre>
void ShowXItemMenu()
{
…
CMenu menu;
menu.CreatePopupMenu();
//add menu items.
menu.TrackPropupMenu();
…
}
void ShowYItemMenu( )
{
…
CMenu menu;
menu.CreatePopupMenu();
//add menu items.
menu.TrackPropupMenu();
menu.Detach();//this will cause HMENU leak
…
}
BOOL CMenu::CreatePopupMenu()
{
…
hMenu = CreatePopupMenu();
…
}
</pre>
<p>当调用ShowYItemMenu()时，我们故意造成HMENU的泄漏。但是，对于BoundsChecker来说被泄漏的HMENU是在class CMenu::CreatePopupMenu()中分配的。假设的你的程序有许多地方使用了CMenu的CreatePopupMenu()函数，如CMenu::CreatePopupMenu()造成的，你依然无法确认问题的根结到底在哪里，在ShowXItemMenu()中还是在ShowYItemMenu()中，或者还有其它的地方也使用了CreatePopupMenu()？有了Call Stack的信息，问题就容易了。BoundsChecker会如下报告泄漏的HMENU的信息：</p>
<p></p>
<pre>
Function
File
Line
CMenu::CreatePopupMenu
E:68/vc98/mfc/mfc/include/afxwin1.inl
1009
ShowYItemMenu
E:/testmemleak/mytest.cpp
100
</pre>
<p>这里省略了其他的函数调用</p>
<p>如此，我们很容易找到发生问题的函数是ShowYItemMenu()。当使用MFC之类的类库编程时，大部分的API调用都被封装在类库的class里，有了Call Stack信息，我们就可以非常容易的追踪到真正发生泄漏的代码。</p>
<p>记录Call Stack信息会使程序的运行变得非常慢，因此默认情况下BoundsChecker不会记录Call Stack信息。可以按照以下的步骤打开记录Call Stack信息的选项开关：</p>
<p>1. 打开菜单：BoundsChecker|Setting…</p>
<p>2. 在Error Detection页中，在Error Detection Scheme的List中选择Custom</p>
<p>3. 在Category的Combox中选择 Pointer and leak error check</p>
<p>4. 钩上Report Call Stack复选框</p>
<p>5. 点击Ok</p>
<p>基于Code Injection，BoundsChecker还提供了API Parameter的校验功能，memory over run等功能。这些功能对于程序的开发都非常有益。由于这些内容不属于本文的主题，所以不在此详述了。</p>
<p>尽管BoundsChecker的功能如此强大，但是面对隐式内存泄漏仍然显得苍白无力。所以接下来我们看看如何用Performance Monitor检测内存泄漏。</p>
<p>2.3.3.3 使用Performance Monitor检测内存泄漏</p>
<p>NT的内核在设计过程中已经加入了系统监视功能，比如CPU的使用率，内存的使用情况，I/O操作的频繁度等都作为一个个Counter，应用程序可以通过读取这些Counter了解整个系统的或者某个进程的运行状况。Performance Monitor就是这样一个应用程序。</p>
<p>为了检测内存泄漏，我们一般可以监视Process对象的Handle Count，Virutal Bytes 和Working Set三个Counter。Handle Count记录了进程当前打开的HANDLE的个数，监视这个Counter有助于我们发现程序是否有Handle泄漏；Virtual Bytes记录了该进程当前在虚地址空间上使用的虚拟内存的大小，NT的内存分配采用了两步走的方法，首先，在虚地址空间上保留一段空间，这时操作系统并没有分配物理内存，只是保留了一段地址。然后，再提交这段空间，这时操作系统才会分配物理内存。所以，Virtual Bytes一般总大于程序的Working Set。监视Virutal Bytes可以帮助我们发现一些系统底层的问题; Working Set记录了操作系统为进程已提交的内存的总量，这个值和程序申请的内存总量存在密切的关系，如果程序存在内存的泄漏这个值会持续增加，但是Virtual Bytes却是跳跃式增加的。</p>
<p>监视这些Counter可以让我们了解进程使用内存的情况，如果发生了泄漏，即使是隐式内存泄漏，这些Counter的值也会持续增加。但是，我们知道有问题却不知道哪里有问题，所以一般使用Performance Monitor来验证是否有内存泄漏，而使用BoundsChecker来找到和解决。</p>
<p>当Performance Monitor显示有内存泄漏，而BoundsChecker却无法检测到，这时有两种可能：第一种，发生了偶发性内存泄漏。这时你要确保使用Performance Monitor和使用BoundsChecker时，程序的运行环境和操作方法是一致的。第二种，发生了隐式的内存泄漏。这时你要重新审查程序的设计，然后仔细研究Performance Monitor记录的Counter的值的变化图，分析其中的变化和程序运行逻辑的关系，找到一些可能的原因。这是一个痛苦的过程，充满了假设、猜想、验证、失败，但这也是一个积累经验的绝好机会。</p>
<p>3 探讨C++内存回收</p>
<p>3.1 C++内存对象大会战</p>
<p>如果一个人自称为程序高手，却对内存一无所知，那么我可以告诉你，他一定在吹牛。用C或C++写程序，需要更多地关注内存，这不仅仅是因为内存的分配是否合理直接影响着程序的效率和性能，更为主要的是，当我们操作内存的时候一不小心就会出现问题，而且很多时候，这些问题都是不易发觉的，比如内存泄漏，比如悬挂指针。笔者今天在这里并不是要讨论如何避免这些问题，而是想从另外一个角度来认识C++内存对象。</p>
<p>我们知道，C++将内存划分为三个逻辑区域：堆、栈和静态存储区。既然如此，我称位于它们之中的对象分别为堆对象，栈对象以及静态对象。那么这些不同的内存对象有什么区别了？堆对象和栈对象各有什么优劣了？如何禁止创建堆对象或栈对象了？这些便是今天的主题。</p>
<p>3.1.1 基本概念</p>
<p>先来看看栈。栈，一般用于存放局部变量或对象，如我们在函数定义中用类似下面语句声明的对象：</p>
<p></p>
<p>Type stack_object ;</p>
<p>stack_object便是一个栈对象，它的生命期是从定义点开始，当所在函数返回时，生命结束。</p>
<p>另外，几乎所有的临时对象都是栈对象。比如，下面的函数定义：</p>
<p></p>
<p>Type fun(Type object); </p>
<p>这个函数至少产生两个临时对象，首先，参数是按值传递的，所以会调用拷贝构造函数生成一个临时对象object_copy1 ，在函数内部使用的不是使用的不是object，而是object_copy1，自然，object_copy1是一个栈对象，它在函数返回时被释放；还有这个函数是值返回的，在函数返回时，如果我们不考虑返回值优化（NRV），那么也会产生一个临时对象object_copy2，这个临时对象会在函数返回后一段时间内被释放。比如某个函数中有如下代码：</p>
<p></p>
<p>Type tt ,result ; //生成两个栈对象</p>
<p>tt = fun(tt); //函数返回时，生成的是一个临时对象object_copy2</p>
<p>上面的第二个语句的执行情况是这样的，首先函数fun返回时生成一个临时对象object_copy2 ，然后再调用赋值运算符执行</p>
<p></p>
<p>tt = object_copy2 ; //调用赋值运算符 </p>
<p>看到了吗？编译器在我们毫无知觉的情况下，为我们生成了这么多临时对象，而生成这些临时对象的时间和空间的开销可能是很大的，所以，你也许明白了，为什么对于“大”对象最好用const引用传递代替按值进行函数参数传递了。</p>
<p>接下来，看看堆。堆，又叫自由存储区，它是在程序执行的过程中动态分配的，所以它最大的特性就是动态性。在C++中，所有堆对象的创建和销毁都要由程序员负责，所以，如果处理不好，就会发生内存问题。如果分配了堆对象，却忘记了释放，就会产生内存泄漏；而如果已释放了对象，却没有将相应的指针置为NULL，该指针就是所谓的“悬挂指针”，再度使用此指针时，就会出现非法访问，严重时就导致程序崩溃。</p>
<p>那么，C++中是怎样分配堆对象的？唯一的方法就是用new（当然，用类malloc指令也可获得C式堆内存），只要使用new，就会在堆中分配一块内存，并且返回指向该堆对象的指针。</p>
<p>再来看看静态存储区。所有的静态对象、全局对象都于静态存储区分配。关于全局对象，是在main()函数执行前就分配好了的。其实，在main()函数中的显示代码执行之前，会调用一个由编译器生成的_main()函数，而_main()函数会进行所有全局对象的的构造及初始化工作。而在main()函数结束之前，会调用由编译器生成的exit函数，来释放所有的全局对象。比如下面的代码：</p>
<p></p>
<pre>
void main（void）
{
… …// 显式代码
} 
实际上，被转化成这样：
void main（void）
{
_main（）; //隐式代码，由编译器产生，用以构造所有全局对象
… … // 显式代码
… …
exit（） ; // 隐式代码，由编译器产生，用以释放所有全局对象
}
</pre>
<p></p>
<p>所以，知道了这个之后，便可以由此引出一些技巧，如，假设我们要在main()函数执行之前做某些准备工作，那么我们可以将这些准备工作写到一个自定义的全局对象的构造函数中，这样，在main()函数的显式代码执行之前，这个全局对象的构造函数会被调用，执行预期的动作，这样就达到了我们的目的。 刚才讲的是静态存储区中的全局对象，那么，局部静态对象了？局部静态对象通常也是在函数中定义的，就像栈对象一样，只不过，其前面多了个static关键字。局部静态对象的生命期是从其所在函数第一次被调用，更确切地说，是当第一次执行到该静态对象的声明代码时，产生该静态局部对象，直到整个程序结束时，才销毁该对象。</p>
<p>还有一种静态对象，那就是它作为class的静态成员。考虑这种情况时，就牵涉了一些较复杂的问题。</p>
<p>第一个问题是class的静态成员对象的生命期，class的静态成员对象随着第一个class object的产生而产生，在整个程序结束时消亡。也就是有这样的情况存在，在程序中我们定义了一个class，该类中有一个静态对象作为成员，但是在程序执行过程中，如果我们没有创建任何一个该class object，那么也就不会产生该class所包含的那个静态对象。还有，如果创建了多个class object，那么所有这些object都共享那个静态对象成员。</p>
<p>第二个问题是，当出现下列情况时：</p>
<p></p>
<
<pre>
class Base
{
public:
static Type s_object ;
}
class Derived1 : public Base / / 公共继承
{
… …// other data
}
class Derived2 : public Base / / 公共继承
{
… …// other data
}
Base example ;
Derivde1 example1 ;
Derivde2 example2 ;
example.s_object = …… ;
example1.s_object = …… ;
example2.s_object = …… ;
</pre>
<p>请注意上面标为黑体的三条语句，它们所访问的s_object是同一个对象吗？答案是肯定的，它们的确是指向同一个对象，这听起来不像是真的，是吗？但这是事实，你可以自己写段简单的代码验证一下。我要做的是来解释为什么会这样？ 我们知道，当一个类比如Derived1，从另一个类比如Base继承时，那么，可以看作一个Derived1对象中含有一个Base型的对象，这就是一个subobject。一个Derived1对象的大致内存布局如下：</p>
<p></p>
<p>让我们想想，当我们将一个Derived1型的对象传给一个接受非引用Base型参数的函数时会发生切割，那么是怎么切割的呢？相信现在你已经知道了，那就是仅仅取出了Derived1型的对象中的subobject，而忽略了所有Derived1自定义的其它数据成员，然后将这个subobject传递给函数（实际上，函数中使用的是这个subobject的拷贝）。</p>
<p>所有继承Base类的派生类的对象都含有一个Base型的subobject（这是能用Base型指针指向一个Derived1对象的关键所在，自然也是多态的关键了），而所有的subobject和所有Base型的对象都共用同一个s_object对象，自然，从Base类派生的整个继承体系中的类的实例都会共用同一个s_object对象了。上面提到的example、example1、example2的对象布局如下图所示：</p>
<p>3.1.2 三种内存对象的比较</p>
<p>栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要程序员操心；而且栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用operator new操作，operator new会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了。但是要注意的是，通常栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配。特别要注意递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误。</p>
<p>堆对象，其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。</p>
<p>接下来看看static对象。</p>
<p>首先是全局对象。全局对象为类间通信和函数间通信提供了一种最简单的方式，虽然这种方式并不优雅。一般而言，在完全的面向对象语言中，是不存在全局对象的，比如C#，因为全局对象意味着不安全和高耦合，在程序中过多地使用全局对象将大大降低程序的健壮性、稳定性、可维护性和可复用性。C++也完全可以剔除全局对象，但是最终没有，我想原因之一是为了兼容C。</p>
<p>其次是类的静态成员，上面已经提到，基类及其派生类的所有对象都共享这个静态成员对象，所以当需要在这些class之间或这些class objects之间进行数据共享或通信时，这样的静态成员无疑是很好的选择。</p>
<p>接着是静态局部对象，主要可用于保存该对象所在函数被屡次调用期间的中间状态，其中一个最显著的例子就是递归函数，我们都知道递归函数是自己调用自己的函数，如果在递归函数中定义一个nonstatic局部对象，那么当递归次数相当大时，所产生的开销也是巨大的。这是因为nonstatic局部对象是栈对象，每递归调用一次，就会产生一个这样的对象，每返回一次，就会释放这个对象，而且，这样的对象只局限于当前调用层，对于更深入的嵌套层和更浅露的外层，都是不可见的。每个层都有自己的局部对象和参数。</p>
<p>在递归函数设计中，可以使用static对象替代nonstatic局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放nonstatic对象的开销，而且static对象还可以保存递归调用的中间状态，并且可为各个调用层所访问。</p>
<p>3.1.3 使用栈对象的意外收获</p>
<p>前面已经介绍到，栈对象是在适当的时候创建，然后在适当的时候自动释放的，也就是栈对象有自动管理功能。那么栈对象会在什么会自动释放了？第一，在其生命期结束的时候；第二，在其所在的函数发生异常的时候。你也许说，这些都很正常啊，没什么大不了的。是的，没什么大不了的。但是只要我们再深入一点点，也许就有意外的收获了。</p>
<p>栈对象，自动释放时，会调用它自己的析构函数。如果我们在栈对象中封装资源，而且在栈对象的析构函数中执行释放资源的动作，那么就会使资源泄漏的概率大大降低，因为栈对象可以自动的释放资源，即使在所在函数发生异常的时候。实际的过程是这样的：函数抛出异常时，会发生所谓的stack_unwinding（堆栈回滚），即堆栈会展开，由于是栈对象，自然存在于栈中，所以在堆栈回滚的过程中，栈对象的析构函数会被执行，从而释放其所封装的资源。除非，除非在析构函数执行的过程中再次抛出异常――而这种可能性是很小的，所以用栈对象封装资源是比较安全的。基于此认识，我们就可以创建一个自己的句柄或代理来封装资源了。智能指针（auto_ptr）中就使用了这种技术。在有这种需要的时候，我们就希望我们的资源封装类只能在栈中创建，也就是要限制在堆中创建该资源封装类的实例。</p>
<p>3.1.4 禁止产生堆对象</p>
<p>上面已经提到，你决定禁止产生某种类型的堆对象，这时你可以自己创建一个资源封装类，该类对象只能在栈中产生，这样就能在异常的情况下自动释放封装的资源。</p>
<p>那么怎样禁止产生堆对象了？我们已经知道，产生堆对象的唯一方法是使用new操作，如果我们禁止使用new不就行了么。再进一步，new操作执行时会调用operator new，而operator new是可以重载的。方法有了，就是使new operator 为private，为了对称，最好将operator delete也重载为private。现在，你也许又有疑问了,难道创建栈对象不需要调用new吗？是的，不需要，因为创建栈对象不需要搜索内存，而是直接调整堆栈指针，将对象压栈，而operator new的主要任务是搜索合适的堆内存，为堆对象分配空间，这在上面已经提到过了。好，让我们看看下面的示例代码：</p>
<p></p>
<pre>
#include &lt;stdlib.h> //需要用到C式内存分配函数
class Resource ; //代表需要被封装的资源类
class NoHashObject
{
private:
Resource* ptr ;//指向被封装的资源
... ... //其它数据成员
void* operator new(size_t size) //非严格实现，仅作示意之用
{
return malloc(size) ;
}
void operator delete(void* pp) //非严格实现，仅作示意之用
{
free(pp) ;
}
public:
NoHashObject()
{
//此处可以获得需要封装的资源，并让ptr指针指向该资源
ptr = new Resource() ;
}
~NoHashObject()
{
delete ptr ; //释放封装的资源
}
};
</pre>
<p>NoHashObject现在就是一个禁止堆对象的类了，如果你写下如下代码：</p>
<p>NoHashObject* fp = new NoHashObject() ; //编译期错误！</p>
<p>delete fp ;</p>
<p></p>
<p>上面代码会产生编译期错误。好了，现在你已经知道了如何设计一个禁止堆对象的类了，你也许和我一样有这样的疑问，难道在类NoHashObject的定义不能改变的情况下，就一定不能产生该类型的堆对象了吗？不，还是有办法的，我称之为“暴力破解法”。C++是如此地强大，强大到你可以用它做你想做的任何事情。这里主要用到的是技巧是指针类型的强制转换。</p>
<p></p>
<pre>
void main(void)
{
char* temp = new char[sizeof(NoHashObject)] ;
//强制类型转换，现在ptr是一个指向NoHashObject对象的指针
NoHashObject* obj_ptr = (NoHashObject*)temp ;
temp = NULL ; //防止通过temp指针修改NoHashObject对象
//再一次强制类型转换，让rp指针指向堆中NoHashObject对象的ptr成员
Resource* rp = (Resource*)obj_ptr ;
//初始化obj_ptr指向的NoHashObject对象的ptr成员
rp = new Resource() ;
//现在可以通过使用obj_ptr指针使用堆中的NoHashObject对象成员了
... ...
delete rp ;//释放资源
temp = (char*)obj_ptr ;
obj_ptr = NULL ;//防止悬挂指针产生
delete [] temp ;//释放NoHashObject对象所占的堆空间。
}
</pre>
<p></p>
<p>上面的实现是麻烦的，而且这种实现方式几乎不会在实践中使用，但是我还是写出来路，因为理解它，对于我们理解C++内存对象是有好处的。对于上面的这么多强制类型转换，其最根本的是什么了？我们可以这样理解：</p>
<p>某块内存中的数据是不变的，而类型就是我们戴上的眼镜，当我们戴上一种眼镜后，我们就会用对应的类型来解释内存中的数据，这样不同的解释就得到了不同的信息。</p>
<p>所谓强制类型转换实际上就是换上另一副眼镜后再来看同样的那块内存数据。</p>
<p>另外要提醒的是，不同的编译器对对象的成员数据的布局安排可能是不一样的，比如，大多数编译器将NoHashObject的ptr指针成员安排在对象空间的头4个字节，这样才会保证下面这条语句的转换动作像我们预期的那样执行：</p>
<p></p>
<pre>
Resource* rp = (Resource*)obj_ptr ; 
</pre>
<p>但是，并不一定所有的编译器都是如此。</p>
<p>既然我们可以禁止产生某种类型的堆对象，那么可以设计一个类，使之不能产生栈对象吗？当然可以。</p>
<p>3.1.5 禁止产生栈对象</p>
<p>前面已经提到了，创建栈对象时会移动栈顶指针以“挪出”适当大小的空间，然后在这个空间上直接调用对应的构造函数以形成一个栈对象，而当函数返回时，会调用其析构函数释放这个对象，然后再调整栈顶指针收回那块栈内存。在这个过程中是不需要operator new/delete操作的，所以将operator new/delete设置为private不能达到目的。当然从上面的叙述中，你也许已经想到了：将构造函数或析构函数设为私有的，这样系统就不能调用构造/析构函数了，当然就不能在栈中生成对象了。</p>
<p>这样的确可以，而且我也打算采用这种方案。但是在此之前，有一点需要考虑清楚,那就是，如果我们将构造函数设置为私有，那么我们也就不能用new来直接产生堆对象了，因为new在为对象分配空间后也会调用它的构造函数啊。所以，我打算只将析构函数设置为private。再进一步，将析构函数设为private除了会限制栈对象生成外，还有其它影响吗？是的，这还会限制继承。</p>
<p>如果一个类不打算作为基类，通常采用的方案就是将其析构函数声明为private。</p>
<p>为了限制栈对象，却不限制继承，我们可以将析构函数声明为protected，这样就两全其美了。如下代码所示：</p>
<p></p>
<pre>
class NoStackObject
{
protected:
~NoStackObject() { }
public:
void destroy()
{
delete this ;//调用保护析构函数
}
};
</pre>
<p>接着，可以像这样使用NoStackObject类：</p>
<p></p>
<pre>
NoStackObject* hash_ptr = new NoStackObject() ;
... ... //对hash_ptr指向的对象进行操作
hash_ptr->destroy() ;
</pre>
<p>呵呵，是不是觉得有点怪怪的，我们用new创建一个对象，却不是用delete去删除它，而是要用destroy方法。很显然，用户是不习惯这种怪异的使用方式的。所以，我决定将构造函数也设为private或protected。这又回到了上面曾试图避免的问题，即不用new，那么该用什么方式来生成一个对象了？我们可以用间接的办法完成，即让这个类提供一个static成员函数专门用于产生该类型的堆对象。（设计模式中的singleton模式就可以用这种方式实现。）让我们来看看：</p>
<p></p>
<pre>class NoStackObject
{
protected:
NoStackObject() { }
~NoStackObject() { }
public:
static NoStackObject* creatInstance()
{
return new NoStackObject() ;//调用保护的构造函数
}
void destroy()
{
delete this ;//调用保护的析构函数
}
}; </pre>
<p>现在可以这样使用NoStackObject类了：</p>
<p></p>
<pre>
NoStackObject* hash_ptr = NoStackObject::creatInstance() ;
... ... //对hash_ptr指向的对象进行操作
hash_ptr->destroy() ;
hash_ptr = NULL ; //防止使用悬挂指针
</pre>
<p>现在感觉是不是好多了，生成对象和释放对象的操作一致了。</p>
<p>3.2 浅议C++ 中的垃圾回收方法</p>
<p>许多 C 或者 C++ 程序员对垃圾回收嗤之以鼻，认为垃圾回收肯定比自己来管理动态内存要低效，而且在回收的时候一定会让程序停顿在那里，而如果自己控制内存管理的话，分配和释放时间都是稳定的，不会导致程序停顿。最后，很多 C/C++ 程序员坚信在C/C++ 中无法实现垃圾回收机制。这些错误的观点都是由于不了解垃圾回收的算法而臆想出来的。</p>
<p>其实垃圾回收机制并不慢，甚至比动态内存分配更高效。因为我们可以只分配不释放，那么分配内存的时候只需要从堆上一直的获得新的内存，移动堆顶的指针就够了；而释放的过程被省略了，自然也加快了速度。现代的垃圾回收算法已经发展了很多，增量收集算法已经可以让垃圾回收过程分段进行，避免打断程序的运行了。而传统的动态内存管理的算法同样有在适当的时间收集内存碎片的工作要做，并不比垃圾回收更有优势。</p>
<p>而垃圾回收的算法的基础通常基于扫描并标记当前可能被使用的所有内存块，从已经被分配的所有内存中把未标记的内存回收来做的。C/C++ 中无法实现垃圾回收的观点通常基于无法正确扫描出所有可能还会被使用的内存块，但是，看似不可能的事情实际上实现起来却并不复杂。首先，通过扫描内存的数据，指向堆上动态分配出来内存的指针是很容易被识别出来的，如果有识别错误，也只能是把一些不是指针的数据当成指针，而不会把指针当成非指针数据。这样，回收垃圾的过程只会漏回收掉而不会错误的把不应该回收的内存清理。其次，如果回溯所有内存块被引用的根，只可能存在于全局变量和当前的栈内，而全局变量(包括函数内的静态变量)都是集中存在于 bss 段或 data段中。</p>
<p>垃圾回收的时候，只需要扫描 bss 段, data 段以及当前被使用着的栈空间，找到可能是动态内存指针的量，把引用到的内存递归扫描就可以得到当前正在使用的所有动态内存了。</p>
<p>如果肯为你的工程实现一个不错的垃圾回收器，提高内存管理的速度，甚至减少总的内存消耗都是可能的。如果有兴趣的话，可以搜索一下网上已有的关于垃圾回收的论文和实现了的库，开拓视野对一个程序员尤为重要。</p>


<p style='float:right;'>本页共1708段，63063个字符，124249 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
    goTopEx();
    function xiay(){
        window.scrollBy(0,window.innerHeight-10);
    }
    function shangy(){
        window.scrollBy(0,-window.innerHeight+10);
    }
    var obj3=document.getElementById("xiay");
    var obj4=document.getElementById("goBottom");
    function getHeight(){  
        if(browser4=="ch"){
            //谷歌浏览器
            return document.body.clientHeight; 
        }else{
            //IE、firefox等浏览器 
            return document.documentElement.clientHeight;  
        }  
    }
    getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
    getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
    if(browser4!="ch"){    //firefox需要尝一下才显示向下图标
        xiay();
        shangy();
    }
</script>
</div>

</body>
</html>
