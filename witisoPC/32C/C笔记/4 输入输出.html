<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">
<p>程序输入源和输出目标统称为设备(device)。无论什么设备，是用于输入还是输出，C语言都通过流进行输入和输出操作。</p>

<p>流与文件息息相关。这里的文件指的不是磁盘文件，而是程序待处理的流和实际物理设备之间的媒介。大多数情况下，C语言的初学者无需了解这些文件，因为流、文件、设备之间的交互都由C库函数和操作系统自动完成。</p>

<p>C语言的流有两种模式：文本模式和二进制模式。文本流只由字符组成，如发送至屏幕的文本数据。文本流被组织成行，每行最多可255个字符，且以行结束符或换行符结尾。文本流中的某些字符（如换行符）有特殊的含义。</p>

<p>C标准库中有许多用于处理输入流和输出流的函数。如Printf(),puts(),gets(),scanf()等；</p>

<p>C语言fputs()函数：写文件函数(将一指定的字符串写入文件）</p>

<p>#include &lt;stdio.h></p>

<p>int fputs(const char * s, FILE * stream);

<p>函数说明：fputs()用来将参数s 所指的字符串写入到参数stream 所指的文件内。</p>

<p>返回值：若成功则返回写出的字符个数, 返回EOF 则表示有错误发生.</p>


<p>ASCII文件和二进制文件有什么不同？ </p>

<p>ASCII文件是将存储在文件中的每个字节解释成一个ASCII字符，二进制文件是将文件内容解释成一个二进制的比特流，由程序解释这些比特流的意义。 </p>

<p>既然程序执行结束系统会关闭所有打开的文件，为什么程序中还要用close关闭文件？ </p>

<p>在有些大系统中，某些文件会被反覆地打开或同时打开。如果某次打开后没有关闭可能会使某些文件操作的结果不正确。 </p>



<p>fread(sendbuff,sizeof(char),1024,filehandle);

<p>fread读取数据块,在读数据时它不会碰到'\0'就停止,而是把'\0'一起读入sendbuff中,一直读满1024个char个字节才停止,所以你数据不够这么长的的话,就肯定会有乱码,fread不是读取一行,而是读取一块数据</p>

<p>printf("格式控制串","输出项列表")</p>

<p>格式控制串包括1 普通字符：原样输出；2 转义字符，以"\"开头； 3 格式说明符，以"%"开头，控制数据输出格式。</p>



<p>在用scanf()函数传参时，数值和字符类型变量之前要使用取地址符&，而字符串变量则不需要，因为其变量名本身就代表内存地址。</p>



<p>缓冲输入，将若干内容先存储到称为缓冲区（buffer）的临时存储区域，等待适当时机将缓冲区内的内容变得对程序可用，非缓冲输入是不使用缓冲区，直接让输入对程序可用。<strong>缓冲输入对于频繁读写有更高的效率，而非缓冲输入是即时交互程序所需要的</strong>。</p>

<p>filelength函数用于获取文件的长度，但是最大只能获取2g的文件大小，因为返回值类型long使用4个字节大小来表示，最大为2的31次方也就是2G的大小。</p>

<p>long filelength(int _FileHandle);</p>

<p>_FileHandle：文件的句柄。</p>

<p>返回值：文件的大小，单位为字节。</p>

<p>FILE* file=fopen("test.txt","r");</p>

<p>int iSize=filelength(fileno(file));</p>

<p>fclose(file);</p>

<p>void *malloc(unsigned int num_bytes);</p>



<p>printf能输出string型的变量吗</p>

<p>string是类，printf()只能打印基本类型。</p>

<p>string s;</p>

<p>cout << s;</p>

<p>printf("%s", s.c_str()); //不推荐</p>



<p></p>
<pre>
putc(); 字符
fscanf(); 字词，遇到空格和换行时结束
puts(); 串、行
fputs(); 串、行，比puts()安全，是puts()的替代函数

C++写写入文件
fstream file("test.txt",ios::out);
file&lt;"2 sex:"&lt;endl;
</pre>


<p>对文件操作的顺序：打开文件→读写文件→关闭文件。打开文件是指将文件从磁盘调入内存，并与文件操作指针建立关联。文件使用结束应及时关闭，以免丢失信息，关闭文件的同时也是存盘的过程。</p>

<p>fgets(str,n,fp)的功能是：从fp所指向的文件中读取长度不超过n-1的字符串存入str开始的内存。</p>

<p>若在取字符过程中遇到行结束标志\n或文件结束标志EOF，则读取操作自动结束。取出的字符数可以少于n-1个。取字符结束后自动在末尾加上字符串结束标志\0。</p>

<p>feof(fp)测试文件是否结束，返回1或0.</p>

<p>c语言在文件中存取数据有两种方式：顺序读写和随机读写，即可以通过一般的读写操作函数进行顺序存取，又可以通过函数fseek(fp,位移量,起始点)对文件中的位置指针进行定位，再用读写操作函数进行存取，即实现随机存取。</p>

<p>fputs(p1,p2)从p1开始的内存中读取一个字符串存入p2指向的文件；</p>

<p>fread(buffer,size,cout,fp)从文件指针fp指向的文件中读取count个size大小的数据存入内存buffer开始的单元。</p>


<p>printf("exp",var1,var2,……);</p>

<p>exp:格式字符串；</p>

<p>exp：字符，\,%</p>

<p>%引导转换说明：conversion specification</p>

<p>scanf("exp",&var,&var2……);</p>
<p>exp：%;


<p><strong>fopen()打开一个文件并且创建一个用于存储文件和缓冲区信息的结果，返回指向该结构的指针。</strong></p>

<p>fclose()关闭文件并刷新缓冲区；</p>

<p>C程序把输入看作是字节流，输入流来源于文件，输入设备（如键盘）或者甚至是另一个程序的输出；</p>

<pre>
typedef struct {
  short             level;      /* fill/empty level of buffer */
  unsigned          flags;      /* File status flags */
  char              fd;         /* File descriptor */
  unsigned char     hold;       /* Ungetc char if no buffer */
  short             bsize;      /* Buffer size */
  unsigned char     *buffer;    /* Data transfer buffer */
  unsigned char     *curp;      /* Current active pointer */
  unsigned          istemp;     /* Temporary file indicator */
  short             token;      /* Used for validity checking */
}  FILE;                        /* This is the FILE object */
</pre>




<p>scanf用lf%代表double，用f%代表float；</p>

<p>C语言操作文件时会在内存中开辟一块缓冲操作区。</p>




<p>文件指针FILE *fp，FILE是一个结构。</p>


<p>gets（字符数组）</p>

<p>从终端接受一个包含任意字符的字符串，直到遇到回车。 </p>

<p>puts（字符数组）</p>

<p>将一个字符串（以‘\0’结束的字符序列）输出到终端</p>



<p>文本文件在读入内存时先转换为二进制文件，在地直接在屏幕上显示字符，因此便于阅读和逐个字符打印。</p>

<p>二进制文件在读写数据时不需要转换，但显示在屏幕上时需要先转换为ASCII码再显示。</p>

<p>一旦建立了一个流，将它与文件相关联的一种方法是使用函数open()。</p>

<p>文件结束符EOF为-1.</p>


<p>打开文件是指将文件指针与某一外存中的文件关联起来，半为文件的读写做好准备，例如为文件准备缓冲区，记录读写位置等。</p>
<p>C语言程序不能直接访问外存储器中的文件，文件访问通过一个FILE类型的结构体变量做为中介。打开文件是让文件和这个结构体变量关联起来，以后通过这个结构体变量访问对应的文件。</p>
<p>程序不能直接访问外存中的信息，文件访问是通过缓冲区实现的，每个打开的文件在内存中都有一块对应的缓冲区，程序对文件的读写是对这块缓冲区的读写。缓冲区与文件的信息交互由系统自动完成，不需要程序的介入。</p>
<p>程序访问文件时，必须知道对应的缓冲区在什么地方，缓冲区是空的还是满的，当前读写的信息处于文件中的什么位置等信息。C语言将这些信息定义成一个称为FILE的结构体基本类型，每个访问的文件都有一个对应的FILE类型的变量。当程序需要访问某个文件时，必须定义一个对应这个文件的指针，打开文件时，会创建一个保存该文件信息的FILE类型的变量，并返回指向该变量的指向，这个指针称为文件指针。</p>
<p>文件定位指针记录文件中当前读写位置，是一个long int类型的变量，表示将要读写的数据是文件中的第几个字节，当程序读写文件时，系统根据文件定位指针的值把信息写入文件的指定位置。</p>
<p>fopen()函数不仅打开一个文件，还创建一个缓冲区（在读写模式下创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen()返回一个指向该结构的指针，以便其他函数知道如何找到该结构。假设把该指针赋给一个指针变量fp，我们说fopen()函数“打开一个流”。如果以文本模式打开该文件，就获得一个文本流，如果以二进制模式打开该文件，就获得一个二进制流。</p>
<p>这个结构通常包含一个指定流中当前位置的文件指示器。除此之外，它还包含错误和文件结尾的指示器、一个指向缓冲区开始处的指针、一个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数）。</p>

<p>fgets()+fputs()：字符串方式读写，末尾会添加\n；</p>
<p>fscanf()+fprintf()：格式化读写，可以为内容添加\t等控制字符，形成表格数据；</p>
<p>fread()+fwrite()：字节流读写，如读写结构体数据；</p>
<p>feof()：判断是否到达文件的结尾；</p>
<p>EOF，对于文本文件，数据以字符的ASCII码值的形式存放，普通字符的ASCII码的范围是32到127（十进制），EOF的16进制代码为0XFF（十进制为-1），因此可以用EOF作为文件的结束标志。当把数据以二进制的形式存入到文件中时，就有可能会将数字-1存入到文件中，此时继续根据EOF来判断文件是否结束就会出问题，为了解决这个问题，ASCI C就提供了foef函数。</p>
<p>fgetc()等函数会设置EOF。当读到文件末尾时。</p>


<p>scanf()函数之所以要求指针作为参数，最主要的原因是希望通过调用这个函数来改变main()函数本地的变量i的值。</p>
<p>用puts(str)代替printf("%s",str)</p>
<p>用putchar('\n')代替printf("\n");</p>

<p>用“a”方式打开文件并不要求文件事先存在，如果文件不存在不会得到出错信息，因为“a”的含义是打开或创建一个新文件。如果文件存在则向文件末尾写入新数据；如果文件不存在，则创建一个新文件，这时“a”和“w”没有什么区别。</p>

<p>在scanf()函数调用时，控制字符串中的一个空白字符（“ ”、“\n”或“\t”）指令(directive)，可以匹配无穷多个连续的空白字符序列。在scanf()函数调用时，通常也不应该出现空白字符指令，尤其是在控制字符串的结尾更不应该。scanf("%f%f",&a,&b);默认就是按空格字符去区隔的，不管%f%f之间有没有空格，或有多个空格。</p>


<p>stdin 是一个指向FILE 类型对象的指针类型的表达式。</p>
<p>在很多实现中，它其实是一个“常量”表达式。例如在Visual C++中，stdin 是这样定义的：</p>
<p>#define stdin (&_iob[0])</p>

<p><h4>格式输出函数</h4></p>

<p>函数作用：向终端（或系统隐含指定的输出设备）输出若干个任意类型的数据。</p>

<p>一般格式：printf（格式控制，输出表列）</p>

<p>s格式符输出字符串.</p>

<p>① %s例如：</p>

<p>printf("%s","china")</p>

<p>输出字符串“china”（不包括双引号）。</p>

<p>② %ms，输出的字符串占m列，若串长大于m，则全部输出，若串长小于m，则左补空格。</p>

<p>③ %-ms，若串长小于m，字符串向左靠，右补空格。</p>

<p>④ %m. ns,输出占m列，只取字符串中左端n个字符，输出在m列的右侧，左补空格。</p>

<p>⑤ %-m.ns，n个字符输出在m列的左侧，右补空格，若n〉m，m自动取n值。</p>

<p>printf(“%3s,%7.2s,%.4s,%-5.3s\n”, “china”, “china”, “china”, “china”);</p>
<p>其底层是通过一个循环分析"format"的每一个字符，对字符%及其后的每一个字符进行分析，对应variable list分别进行构建字符串。</p>


<p>通俗地说，fgets将输入流中由调用起，stdin输入的东西存入起始地址为tran_to_int的地方，并且最多读取sizeof(tran_to_int)个，并在后方sscanf函数中将刚才读入的数据按照%d的格式存入stay_here，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于scanf的问题</p>
<p></p>
<p>  scanf("%d", &stay_here);</p>
<p>这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是回车会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。</p>
<h4>预定义指针到设备文件（键盘或显示器）的FILE常量</h4></p>
<p>指向FILE常量的指针：设备文件</p>
<p>stdin：键盘</p>
<p>stdout：显示器</p>
<p>stderr：显示器</p>
<p>m=fgetc(stdin); 从指向FILE常量stdin(即键盘）的指针指定的文件中读取一个字符，并返回其ASCII值，该值赋值给m。</p>
<p>fputc(m,stdout);将字符（其ASCII值存储在m中）写入由FILE常量stdout指针指定的文件（显示器）。</p>
<p>系统在主存中开辟一个专用的内存区域用来临时存放输入/输出信息，这种内存区域称为缓冲区。输入/输出流可以是缓冲的，也可以是非缓冲的。引入缓冲的目的是为了提高系统的效率。通常情况使用缓冲流。（FILE一般使用缓冲区）</p>

<p>The first argument to printf is always a format string. The format string  provides a template for the string to be printed, and it contains any number  of special format specifiers. Format specifiers tell printf how to interpret  and format the arguments following the format string. All format specifiers  begin with %.</p>
<p>For example, the format specifier for an int is %d. Whenever printf sees  a %d in the format string, it knows to expect an int argument following the  format specifier. Then printf replaces the format specifier with the argument’s  actual value.</p>
<p>文件打开时，系统给文件分配一个位置指针，用于指向文件当前的读写位置。每次读取字符，文件的位置指针便会自动向下移动读取数量的字节，不需要人为进行控制。这种功能在许多读写函数中都会有体现。</p>

<p>fgetc()当读到文件末尾的空字符时，返回EOF，并设置EOF。</p>
<p>while ((c = fgetc(fp)) != EOF) {</p>
<p>feof()用于检测EOF，以下代码用于检测EOF，如果在循环体内用fgetc()，则有一个字符的区别。</p>
<p>while (!feof(fp)) {</p>


<p>The program could read one character from the file, process it, read the next character from the file, and so on. Reading a file a character at a time from a disk requires a lot of hardware activity and is slow. The <strong>buffered approach</strong> is to read a large chunk from the disk, store the chunk in the buffer, and read the buffer one character at a time. Because it is much quicker to read individual bytes of data from memory than from a had disk, this approach is much faster as well as easier on the hardware. Similarly, in output, a program can first fill the buffer and then transfer the entire block of data to a hard disk, clearing the buffer for the next batch of output. This is called flushing the buffer.</p>

<h4>input</h4>
<p>The cin is to use whitespace-spaces, tabs, and newlines- to delineate a string. This means cin reads just one word when it gets input for a character array.</p>

<p>After it reads this word, cin automatically adds the terminating null character when it places the string into the array.</p>

<p>To be able to enter whole phrases instead of single words as a string, you can use some line-oriented class member functions: getline() and get(). getline() discards the newline character, whereas get() leaves it in the input queue.</p>





<p>A buffer is a block of memory where data is accumulated before being physically read or written to the associated file or device. Streams can be either fully buffered, line buffered or unbuffered. On fully buffered streams, data is read/written when the buffer is filled, on line buffered streams this happens when a new-line character is encountered, and on unbuffered streams characters are intended to be read/written as soon as possible.</p>
<p>Streams have certain internal indicators that specify their current state and which affect the behavior of some input and output operations performed on them:</p>


<p>Error indicator</p>


<p>This indicator is set when an error has occurred in an operation related to the stream. This indicator can be checked with the ferror function, and can be reset by calling either to clearerr, freopen or rewind.</p>


<p>End-Of-File indicator</p>


<p>When set, indicates that the last reading or writing operation performed with the stream reached the End of File. It can be checked with the feof function, and can be reset by calling either to clearerr or freopen or by calling to any repositioning function (rewind, fseek and fsetpos)， or by calling of fgetc().</p>


<p>Position indicator</p>


<p>It is an internal pointer of each stream which points to the next character to be read or written in the next I/O operation. Its value can be obtained by the ftell and fgetpos functions, and can be changed using the repositioning functions rewind, fseek and fsetpos.</p>
<p>A stream buffer is an object in charge of performing the reading and writing operations of the stream object it is associated with: the stream delegates all such operations to its associated stream buffer object, which is an intermediary between the stream and its controlled input and output sequences.</p>


<p>All stream objects, no matter whether buffered or unbuffered, have an associated stream buffer: Some stream buffer types may then be set to either use an intermediate buffer or not.</p>
<p>I/O streams are objects of type FILE that can only be accessed and manipulated through pointers of type FILE* (Note: while it may be possible to create a local object of type FILE by dereferencing and copying a valid FILE*, using the address of such copy in the I/O functions is undefined behavior). Each stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).</p>


<p>I/O streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. All streams access the same locale object: the one most recently installed with setlocale.</p>


<p>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each stream object holds the following:</p>


<p>1) (C95) Character width: unset, narrow, or wide</p>


<p>2) Buffering state: unbuffered, line-buffered, fully buffered.</p>


<p>3) The buffer, which may be replaced by an external, user-provided buffer.</p>


<p>4) I/O mode: input, output, or update (both input and output).</p>


<p>5) Binary/text mode indicator.</p>


<p>6) End-of-file status indicator.</p>


<p>7) Error status indicator.</p>


<p>8) File position indicator (an object of type fpos_t), which, for wide character streams, includes the parse state (an object of type mbstate_t(C95)).</p>


<p>9) (C11) Reentrant lock used to prevent data races when multiple threads read, write, position, or query the position of a stream.</p>
<p>stdin  expression of type FILE* associated with the input stream</p>
<p>stdout expression of type FILE* associated with the output stream</p>


<p>stderr expression of type FILE* associated with the error output stream</p>

<p>fgetc()+fputc()：字符方式读写；</p>












</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>



