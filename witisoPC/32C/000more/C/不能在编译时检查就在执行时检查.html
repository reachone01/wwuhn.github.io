<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>P.6不能在编译时检查就在执行时检查</h4>

<p>面向对象思考 2019-11-03 23:13:20</p>
<p>C++核心准则边译边学-P.6 不能在编译时检查就在执行时检查</p>
<p>P.6: What cannot be checked at compile time should be checkable at run time（不能在编译时检查的应当可以在执行时检查）</p>
<p>Reason（原因）</p>
<p>Leaving hard-to-detect errors in a program is asking for crashes and bad results.</p>
<p>在程序中留下难以检查的错误会直接导致程序崩溃和不良后果。</p>
<p>Note（注意）</p>
<p>Ideally, we catch all errors (that are not errors in the programmer's logic) at either compile time or run time. It is impossible to catch all errors at compile time and often not affordable to catch all remaining errors at run time. However, we should endeavor to write programs that in principle can be checked, given sufficient resources (analysis programs, run-time checks, machine resources, time).</p>
<p>理想情况下，我们会在编译时或执行时捕捉错误（不包括程序执行逻辑的错误）。我们不可能在编译时捕捉所有的错误，通常也无法做到在执行时检出剩下的所有错误。但即使是这样，我们还是应该努力按照可检查的原则写代码，就像有充足的资源（分析程序，执行检查，机器资源、时间）那样。</p>
<p>Example, bad（反面示例）</p>
<pre>
// separately compiled, possibly dynamically loaded
extern void f(int* p);
void g(int n)
{
    // bad: the number of elements is not passed to f()
    f(new int[n]);
}
</pre>
<p>Here, a crucial bit of information (the number of elements) has been so thoroughly "obscured" that static analysis is probably rendered infeasible and dynamic checking can be very difficult when f() is part of an ABI so that we cannot "instrument" that pointer. We could embed helpful information into the free store, but that requires global changes to a system and maybe to the compiler. What we have here is a design that makes error detection very hard.</p>
<p>代码中关于要素个数的重要的信息已经被彻底的忽略掉，因此当f()是ABI的一部分，而无法将指针转化为检查手段时，静态分析几乎不可能，动态检查也会非常困难。我们可以在自由存储中组入有用的信息，但是那需要对系统甚至编译器进行全局性的修改。我们面临的是一个让错误检出非常困难的设计。</p>
<p>译者注：ABI（Application Binary Interface）是操作系统为运行在该系统下的应用程序提供的二进制接口。。</p>
<p>Example, bad（反面示例）</p>
<p>We can of course pass the number of elements along with the pointer:</p>
<p>我们当然可以把要素的个数和指针一起传递过去：</p>
<pre>
// separately compiled, possibly dynamically loaded
extern void f2(int* p, int n);
void g2(int n)
{
    f2(new int[n], m); // bad: a wrong number of elements can be passed to f()
}
</pre>
<p>Passing the number of elements as an argument is better (and far more common) than just passing the pointer and relying on some (unstated) convention for knowing or discovering the number of elements. However (as shown), a simple typo can introduce a serious error. The connection between the two arguments of f2() is conventional, rather than explicit.</p>
<p>相比只是传递一个指针然后通过某种（心照不宣）的转换以获取元素个数的方式，将元素个数作为参数传递会比较好（也更常见）。但是正如代码中显示的，一个简单的打字错误就可能导入严重的错误。函数f2()的两个参数之间的关系可以说约定俗成，但还是没有达到明确的程度。</p>
<p>Also, it is implicit that f2() is supposed to delete its argument (or did the caller make a second mistake?).</p>
<p>另外，有一点比较含蓄，就是我们可以推断f2()会释放参数管理的内存（抑或这只是调用者的另一个错误？）</p>
<p>译者注：表达含糊也是错误的主要来源之一。</p>
<p>Example, bad（反面示例）</p>
<p>The standard library resource management pointers fail to pass the size when they point to an object:</p>
<p>当标准库中的资源管理指针指向一个对象时，如果传递大小信息会导致失败。</p>
<p>译者注：代码前的说明只是make_unique的补充说明，没有看出和本文的主题之间有什么关系。这段代码的问题应该在于同样的大小信息需要两次指定，这同样会带来出错的可能性。</p>
<p>Example（示例）</p>
<p>We need to pass the pointer and the number of elements as an integral object:</p>
<p>我们需要将指针和元素的个数作为一个整体传递：</p>
<pre>
extern void f4(vector&); // separately compiled, possibly dynamically loaded
extern void f4(span); // separately compiled, possibly dynamically loaded
 // NB: this assumes the calling code is ABI-compatible, using a
 // compatible C++ compiler and the same stdlib implementation
void g3(int n)
{ 
    vector v(n);
    f4(v); // pass a reference, retain ownership
    f4(span{v}); // pass a view, retain ownership
}
</pre>
<p>This design carries the number of elements along as an integral part of an object, so that errors are unlikely and dynamic (run-time) checking is always feasible, if not always affordable.</p>
<p>这个设计将元素的个数作为对象的一部分，因此不大可能引发错误而且动态（执行时）检查总是可行的，虽然这样做的代价可能十分巨大。</p>
<p>Example（示例）</p>
<p>How do we transfer both ownership and all information needed for validating use?</p>
<p>我们如何即传递所有权又传递用于检查的所有信息？</p>
<pre>
vector f5(int n) // OK: move
{
    vector v(n); 
    // ... initialize v ...
    return v;
}
unique_ptr f6(int n) // bad: loses n
{ 
    auto p = make_unique(n);
    // ... initialize *p ...
    return p;
}
owner f7(int n) // bad: loses n and we might forget to delete
{
    owner p = new int[n];
    // ... initialize *p ...
    return p;
}
</pre>
<p>译者注：第一段代码返回一个vector对象，它即包含指针又包含元素个数；第二段代码返回一个unique_ptr，所有权移交没有问题了，但是丢失了元素个数信息；第三段代码不但丢失了元素个数信息，而且没有办法保证内存一定会被删除。非常不幸，第三段代码正是我们日常开发中最常见的代码。</p>
<p>Example（示例）</p>
<p>??? T.B.D</p>
<p>show how possible checks are avoided by interfaces that pass polymorphic base classes around, when they actually know what they need? Or strings as "free-style" options希望表现到处传递多态基类指针的接口时多么容易逃避检查，使用者什么时候才能确切知道需要何种检查? 或者像“free-style"选项那样的文字描述也行。</p>
<p>译者注：作者虽然没有提供示例代码，但作者认为传递多态基类类型指针时无法进行有效检查这一点应该是确切无疑的。</p>
<p>Enforcement（实施建议）</p>
<p>Flag (pointer, count)-style interfaces (this will flag a lot of examples that can't be fixed for compatibility reasons)找出（指针，数量）-风格的接口（这可以找出很多由于兼容性理由而不能修改的例子）</p>
<p>??? T.B.D</p>
<p>译者注：由于兼容性的原因，发现有风险的接口很容易，但修改却很难。作为读者，至少争取在今后的代码中不要发生类似问题吧。</p>


<p style='float:right;'>本页共92段，5178个字符，7652 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
