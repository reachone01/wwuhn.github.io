<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
    (browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
    (browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
    (browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
    (browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
    (browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
    (browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
    (browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
    "other browser";
    var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
    var obj=document.getElementById("goTopBtn"); 
    var obj2=document.getElementById("shangy"); 
    var obj3=document.getElementById("xiay");
    var obj4=document.getElementById("goBottom");  
    
    function getScrollTop(){  
        if(browser4=="ch"){
            //chrome
            //chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
            return document.documentElement.scrollTop; 
        }else{
            //IE、firefox
            return document.documentElement.scrollTop;  
        }  
    }
    function setScrollTop(value){ 
        if(browser4=="ch"){ 
            //chrome
            document.documentElement.scrollTop=value; 
        }else{  
            //IE、firefox
            document.documentElement.scrollTop=value;  
        } 
    }     
    window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
    getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
    document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
    document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
    }  
    obj.onclick=function(){  
        var goTop=setInterval(scrollMove,10);  
        function scrollMove(){  
                setScrollTop(getScrollTop()/1.1);  
                if(getScrollTop()<1)clearInterval(goTop);  
        }  
    }  
}  
function downn(){
    if(browser4=="ch"){
        //chrome
        window.scrollBy(0,document.body.clientHeight);
    }else{
        //IE、firefox
        window.scrollBy(0,document.documentElement.clientHeight*1000); 
    }
}
</script>
<script>
function changePage(){ 
    var page = document.getElementById("container");
    page.style.background="black";
    page.style.color="white";
    page.style.fontSize="22px";
    page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
    font-size:18px;
    text-decoration:none;
}
a:link{
    text-decoration:none;
    }
#container{
    font-size:1.2em;
    margin:auto;
    font-family:"宋体";
    width:65.29%;
    line-height:1.6em;
}
P{
    margin-top:16px;
    margin-bottom:16px;
    text-indent:2em;
}
.uls{
    color:#CC6666;
    font-weight:bold;
}
.uls>ol{
    list-style:none;
    font-weight:normal;
    list-style:lower-latin;
    color:#000000;
    line-height:1.3em;
}
h3{
    font-size:1.1em;
    font-weight:bold;
    text-indent:0em;
    color:#990000;
}
h4{
    font-size:1.0em;
    font-weight:bold;
    text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
    width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
    right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
    opacity=.3;
    font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
    bottom:240px;
}
#ftsize2{
    bottom:214px;
}
#ftsize3{
    bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
    background-color:#ccc;
    border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
    text-decoration: none;
    color:white;
}
img{
    margin-right:2em;
    text-indent:2em;
    border:0;
}
.picsay{
    color:#930;
    font-size:90%;
    line-height:110%;
    margin-top:-12px;
    padding:0;
}
.remark{
    color:#930;
    font-size:90%;
    line-height:140%;
    margin-top:-12px;
    text-indent:0em;
    padding:0;
}
.ref{
    color:#930;
    font-size:95%;
    line-height:150%;
    margin-top:-12px;
    text-indent:2em;
    padding:0;
}
pre{
    font-size:120%;
    line-height:130%;
    padding:0;
    //background-color:#f6f6f6;
    //background-color:#fff5ee;
    //background-color:#ffe;
    background-color:#eee;
    padding:8px;
    }
.code0, .code2, .code4{
    font-size:95%;
    line-height:110%;
    margin-top:-12px;
    padding:0;
    //background-color:#D9D1CA;
    //background-color:#f6f6f6;
    //background-color:#fff5ee;
    background-color:#ffe;
}
.code0{
    color:red;
    text-indent:0em;
}
.code2{
    color:#930;
    text-indent:2em;
}
.code4{
    color:blue;
    text-indent:4em;
}
sub,sup{
    font-size:80%;
    color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>用C语言写面向的对象是一种什么样的体验？</h4>

<p>众所周知面向对象的三个特性：封装性、继承性、多态性。这几个特性的具体含义我等会会班门弄斧讲一下含义，下面，请允许我先用C++面向对象思维将设计模式中最常用的简单工厂模式写一边，相信这三个特性不言而喻。</p>
<p></p>
<p>以下我将用一个工厂类实现具体汽车的生产，奔驰车、宝马车、奥迪车都将通过工厂类来生产，由父类指针指向具体的汽车实例：</p>
<p>头文件：</p>
<pre>
//Car.h
#ifndef CAR_H_
#define CAR_H_
typedef enum CarType_E
{
    CAR_TYPE_BENZE = 0,
        CAR_TYPE_BMW ,
        CAR_TYPE_AUDI ,
        CAR_TYPE_NONE ,
}CarType_E;
class BaseCar
{
public:
    BaseCar(CarType_E CarType);
    virtual ~BaseCar();
    
    virtual void CarSpeaker();
    CarType_E _CarType;
};
class BenzeCar : public BaseCar
{
public:
    BenzeCar(CarType_E CarType);
    ~BenzeCar();
public:
    void CarSpeaker();
};
class BMWCar : public BaseCar
{
public:
    BMWCar(CarType_E CarType);
    ~BMWCar();
    
    void CarSpeaker();
};
class AudiCar : public BaseCar
{
public:
    AudiCar(CarType_E CarType);
    ~AudiCar();
    
    void CarSpeaker();
};
class CarFactory
{
public:
    BaseCar* createNewCar(CarType_E CarType);
};
#endif /* CAR_H_ */
源代码：
//Car.cpp
#include "Car.h"
#include &lt;iostream>
using namespace std;
BaseCar::BaseCar(CarType_E CarType) : _CarType(CarType)
{
    printf("BaseCar create\n");
}
BaseCar::~BaseCar()
{
    printf("BaseCar delete\n");
}
void BaseCar::CarSpeaker()
{
    std::cout &lt;&lt; "BeBu! BeBu" &lt;&lt; endl;
}
BenzeCar::BenzeCar(CarType_E CarType) : BaseCar(CarType)
{
    printf("BenzeCar create\n");
}
BenzeCar::~BenzeCar()
{
    printf("BenzeCar delete\n");
}
void BenzeCar::CarSpeaker()
{
    printf("BeBu! BeBu! BenzeCar Car,Type:%d\n", _CarType);
}
BMWCar::BMWCar(CarType_E CarType) : BaseCar(CarType)
{
    printf("BMWCar create\n");
}
BMWCar::~BMWCar()
{
    printf("BMWCar delete\n");
}
void BMWCar::CarSpeaker()
{
    printf("BeBu! BeBu! BMWCar Car,Type:%d\n", _CarType);
}
AudiCar::AudiCar(CarType_E CarType) : BaseCar(CarType)
{
    printf("AudiCar create\n");
}
AudiCar::~AudiCar()
{
    printf("AudiCar delete\n");
}
void AudiCar::CarSpeaker()
{
    printf("BeBu! BeBu! AudiCar Car,Type:%d\n", _CarType);
}
BaseCar* CarFactory::createNewCar(CarType_E CarType)
{
    BaseCar* newCar = NULL;
    switch(CarType)
    {
    case CAR_TYPE_BENZE:
        {
            newCar = new BenzeCar(CAR_TYPE_BENZE);
            break;
        }
    case CAR_TYPE_BMW:
        {
            newCar = new BMWCar(CAR_TYPE_BMW);
            break;
        }
    case CAR_TYPE_AUDI:
        {
            newCar = new AudiCar(CAR_TYPE_AUDI);
            break;
        }
    default:
        {
            newCar = new BaseCar(CAR_TYPE_NONE);
            break;
        }
    }
    return newCar;
}
</pre>
<p>以上便是简单工厂模式的源码示例，现在，我们来聊聊为什么用C语言我们也可以实现这面向对象思维的三大特性：</p>
<p>首先是封装性：C++的封装性就是将抽象类的函数和属性都封装起来，不对外开放，外部要使用这些属性和方法都必须通过一个具体实例对象去访问这些方法和属性，而我们知道，C语言中一旦包含了头文件便可以使用头文件中的函数和变量，其实C语言中也可以用一种方法达到这种效果，那便是使用结构体+函数指针+static，结构体中定义属性和函数指针，static将方法都限制在本模块使用，对外部，通过指针函数的方式访问，如此一来，便可以达到面向对象封装性的实现；</p>
<p>对于继承性：C++ 面向对象的继承是可以继承父类的属性和方法，在子类对象中的内存中是有父类对象的内存的，那么，用C语言来写的话我们完全可以在父类结构体中定义一个父类变量在其中，在使用构造子类的时候同时构造父类，便可以达到继承性的特性；</p>
<p>对于多态性：C++中允许一个父类指针指向子类实体，在这个指针使用方法时，若此方法是虚函数，则执行动作会执行到具体的子类函数中，本质的实现方式是通过一个虚函数指针的方式，由于我们用C语言写面向对象本就是通过函数指针的方式来封装函数，那我们完全可以将结构体父类的变量的函数指针让他指向子类的函数来达到多态的特性。</p>
<p>好了，在你们面前班门弄斧了一番，下面开始具体的代码实现：</p>
<p>头文件：</p>
<pre>
#ifndef CAR_H_
#define CAR_H_
#include &lt;stdio.h>
#include &lt;stdlib.h>
typedef enum CarType
{
    CAR_BENZE = 0,
        CAR_BMW,
        CAR_AUDI,
        CAR_NONE,
}CarType;
typedef struct Base_Car
{
    CarType car_type;
    void (* speaker)(struct Base_Car* car);
    
    void* parent_car; //point to parent,if no any parent,then make it NULL
}Base_Car;
typedef struct Benze_Car
{
    Base_Car* car;
    void (* speaker)(struct Base_Car* car);
}Benze_Car;
typedef struct BMW_Car
{
    Base_Car* car;
    void (* speaker)(struct Base_Car* car);
}BMW_Car;
typedef struct Audi_Car
{
    Base_Car* car;
    void (* speaker)(struct Base_Car* car);
}Audi_Car;
typedef struct Car_Factory
{
    Base_Car* (* create_new_car)(CarType car_type);
}Car_Factory;
Car_Factory* new_car_factory();
void delete_car_factory(Car_Factory* car_factory);
Base_Car* new_Base_Car();
Benze_Car* new_benze_Car();
BMW_Car* new_bmw_Car();
Audi_Car* new_audi_Car();
void delete_Base_Car(struct Base_Car* car);
void delete_Benze_Car(struct Benze_Car* car);
void delete_BMW_Car(struct BMW_Car* car);
void delete_Audi_Car(struct Audi_Car* car);
#endif /* CAR_H_ */
源文件：
#include "Car.h"
static void Car_speaker(struct Base_Car* car)
{
    printf("this is a car\n");
}
static void Benze_speaker(struct Base_Car* car)
{
    printf("this is Benze Car, car type is :%d\n",car->car_type);
}
static void BMW_speaker(struct Base_Car* car)
{
    printf("this is BMW Car, car type is :%d\n",car->car_type);
}
static void Audi_speaker(struct Base_Car* car)
{
    printf("this is Audi Car, car type is :%d\n",car->car_type);
}
Benze_Car* new_benze_Car()
{
    Benze_Car* real_car = (Benze_Car*)malloc(sizeof(Benze_Car));
    Base_Car* base_car = new_Base_Car();
    printf("Benze_Car create\n");
    real_car->car = base_car;
    real_car->speaker = Benze_speaker;
    base_car->car_type = CAR_BENZE;
    base_car->parent_car = (void*)real_car;
    base_car->speaker = real_car->speaker;
    return real_car;
}
BMW_Car* new_bmw_Car()
{
    BMW_Car* real_car = (BMW_Car*)malloc(sizeof(BMW_Car));
    Base_Car* base_car = new_Base_Car();
    printf("BMW_Car create\n");
    base_car->car_type = CAR_BMW;
    real_car->car = base_car;
    real_car->speaker = BMW_speaker;
    base_car->car_type = CAR_BMW;
    base_car->parent_car = (void*)real_car;
    base_car->speaker = real_car->speaker;
    return real_car;
}
Audi_Car* new_audi_Car()
{
    Audi_Car* real_car = (Audi_Car*)malloc(sizeof(Audi_Car));
    Base_Car* base_car = new_Base_Car();
    printf("Audi_Car create\n");
    base_car->car_type = CAR_AUDI;
    real_car->car = base_car;
    real_car->speaker = Audi_speaker;
    base_car->car_type = CAR_AUDI;
    base_car->parent_car = (void*)real_car;
    base_car->speaker = real_car->speaker;
    return real_car;
}
Base_Car* new_Base_Car()
{
    Base_Car* base_car = (Base_Car*)malloc(sizeof(Base_Car));
    printf("BaseCar create\n");
    base_car->car_type = CAR_NONE;
    base_car->parent_car = NULL;
    base_car->speaker = Car_speaker;
    return base_car;
}
Base_Car* create_new_Car(CarType car_type)
{
    Base_Car* base_car = NULL;
    switch(car_type)
    {
    case CAR_BENZE:
        {
            Benze_Car* real_car = new_benze_Car();
            base_car = real_car->car;
            break;
        }
    case CAR_BMW:
        {
            BMW_Car* real_car = new_bmw_Car();
            base_car = real_car->car;
            break;
        }
    case CAR_AUDI:
        {
            Audi_Car* real_car = new_audi_Car();
            base_car = real_car->car;
            break;
        }
    default:
        break;
    }
    return base_car;
}
void delete_Benze_Car(struct Benze_Car* car)
{
    free(car->car);
    car->car = NULL;
    free(car);
    printf("Benze_Car delete\n");
}
void delete_BMW_Car(struct BMW_Car* car)
{
    free(car->car);
    car->car = NULL;
    free(car);
    printf("BMW_Car delete\n");
}
void delete_Audi_Car(struct Audi_Car* car)
{
    free(car->car);
    car->car = NULL;
    free(car);
    printf("Audi_Car delete\n");
}
void delete_Base_Car(struct Base_Car* car)
{
    if(NULL != car->parent_car)
    {
        switch(car->car_type)
        {
        case CAR_BENZE:
            {
                delete_Benze_Car((Benze_Car*)car->parent_car);
                car = NULL; //base car will be delete in child free function
                break;
            }
        case CAR_BMW:
            {
                delete_BMW_Car((BMW_Car*)car->parent_car);
                car = NULL;
                break;
            }
        case CAR_AUDI:
            {
                delete_Audi_Car((Audi_Car*)car->parent_car);
                car = NULL;
                break;
            }
        default:
            break;
        }
    }
    if(NULL != car)
    {
        free(car);
        car = NULL;
    }
    printf("Base_Car delete\n");
}
Car_Factory* new_car_factory()
{
    Car_Factory* car_factory = (Car_Factory*)malloc(sizeof(Car_Factory));
    car_factory->create_new_car = create_new_Car;
    return car_factory;
}
void delete_car_factory(Car_Factory* car_factory)
{
    free(car_factory);
    car_factory = NULL;
}
测试文件main.cpp
#include &lt;stdio.h>
#include "Car.h"
int main()
{
    Car_Factory* car_factory = new_car_factory();
    Base_Car* benzeCar = car_factory->create_new_car(CAR_BENZE);
    Base_Car* bmwCar = car_factory->create_new_car(CAR_BMW);
    Base_Car* audiCar = car_factory->create_new_car(CAR_AUDI);
    
    benzeCar->speaker(benzeCar);
    bmwCar->speaker(bmwCar);
    audiCar->speaker(audiCar);
    
    delete_Base_Car(benzeCar);
    benzeCar = NULL;
    delete_Base_Car(bmwCar);
    bmwCar = NULL;
    delete_Base_Car(audiCar);
    audiCar = NULL;
    delete_car_factory(car_factory);
    car_factory = NULL;
    return 0;
}
</pre>
<p>以上的结果可以看出，我们的测试代码接口都是一样的，效果达到了C++面向对象的设计理念，用C语言完成了一次狠狠的逆袭，希望大家在你们的项目工程中有帮助。</p>
<p>其实程序员的工作大部分是写代码，但是代码的阅读对象往往并不是我们自己，将我们的思维写进去才是一个程序员的境界，不要简单的根据流程去写一个代码，否则，程序员就真的只是一个工具了；</p>
<p>哦，BTW，在函数中使用了本结构体的指针在里面，是为了达到在函数中使用示例的属性，这样就独立每一个示例的属性操作了。</p>


<p style='float:right;'>本页共380段，8320个字符，10596 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
    goTopEx();
    function xiay(){
        window.scrollBy(0,window.innerHeight-10);
    }
    function shangy(){
        window.scrollBy(0,-window.innerHeight+10);
    }
    var obj3=document.getElementById("xiay");
    var obj4=document.getElementById("goBottom");
    function getHeight(){  
        if(browser4=="ch"){
            //谷歌浏览器
            return document.body.clientHeight; 
        }else{
            //IE、firefox等浏览器 
            return document.documentElement.clientHeight;  
        }  
    }
    getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
    getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
    if(browser4!="ch"){    //firefox需要尝一下才显示向下图标
        xiay();
        shangy();
    }
</script>
</div>

</body>
</html>
