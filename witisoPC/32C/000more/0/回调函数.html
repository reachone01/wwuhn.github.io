<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>回调函数</h4>


<p>ouyangshima</p>
<h4>定义</h4>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>回调函数简单讲就是一个函数指针。写一个函数,然后把函数地址传递给这个函数指针就可以了。</p>
<p>实例</p>
<pre>
#include &lt;iostream>   
using namespace std;   
typedef void(*DoMessageFunc)(char* pMsg);  
 
void DoMsgFunc(char* pMsg)   
{   
    cout &lt;&lt; "massge is: " &lt;&lt; pMsg &lt;&lt; endl;   
}   
DoMessageFunc m_pFunc;   
void RegistMsg(DoMessageFunc pFunc)   
{   
        m_pFunc = pFunc;   
}   
void HandleMessage(char* pMsg)   
{   
        m_pFunc(pMsg);   
}   
int  main()   
{   
        RegistMsg(DoMessageFunc(DoMsgFunc));             
        HandleMessage("AAAAAAA");  //等价于直接调用其内部的m_pFunc("AAAAAAA");  
        system("pause");
        return 0;   
} 
</pre>
 
 
<h4>回调函数的实现机制</h4>
<p>⑴ 定义一个回调函数； </p>
<p>⑵ 提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者； </p>
<p>⑶ 当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理；</p>
<h4>总结补充</h4>
<p>回调函数是一个定义了函数的原型，函数体则交由第三方来实现的一种动态应用模式。要实现一个回调函数，我们必须明确知道几点：该函数需要那些参数，返回什么类型的值。</p>
<p>Windows 系统还包含着另一种更为广泛的回调机制，即消息机制。</p>
<p>Windows平台的消息机制也可以看作是回调的一种应用，我们通过系统提供的接口注册消息处理函数（即回调函数），从而实现接收、处理消息的目的。</p>
<p>消息本是 Windows 的基本控制手段，乍看与函数调用无关，其实是一种变相的函数调用。发送消息的目的是通知收方运行一段预先准备好的代码，相当于调用一个函数。消息所附带的 WParam 和 LParam 相当于函数的参数，只不过比普通参数更通用一些。应用程序可以主动发送消息，更多情况下是坐等 Windows 发送消息。一旦消息进入所属消息队列，便检感兴趣的那些，跳转去执行相应的消息处理代码。操作系统本是为应用程序服务，由应用程序来调用。而应用程序一旦启动，却要反过来等待操作系统的调用。这分明也是一种回调，或者说是一种广义回调。其实，应用程序之间也可以形成这种回调。假如进程 B 收到进程 A 发来的消息，启动了一段代码，其中又向进程 A 发送消息，这就形成了回调。这种回调比较隐蔽，弄不好会搞成递归调用，若缺少终止条件，将会循环不已，直至把程序搞垮。若是故意编写成此递归调用，并设好终止条件，倒是很有意思。但这种程序结构太隐蔽，除非十分必要，还是不用为好。</p>
<p>利用消息也可以构成狭义回调。上面所举排序函数一例，可以把回调函数地址换成窗口handle。如此，当需要比较数据大小时，不是去调用回调函数，而是借 API 函数 SendMessage 向指定窗口发送消息。收到消息方负责比较数据大小，把比较结果通过消息本身的返回值传给消息发送方。所实现的功能与回调函数并无不同。当然，此例中改为消息纯属画蛇添脚，反倒把程序搞得很慢。但其他情况下并非总是如此，特别是需要异步调用时，发送消息是一种不错的选择。假如回调函数中包含文件处理之类的低速处理，调用方等不得，需要把同步调用改为异步调用，去启动一个单独的线程，然后马上执行后续代码，其余的事让线程慢慢去做。一个替代办法是借 API 函数PostMessage发送一个异步消息，然后立即执行后续代码。这要比自己搞个线程省事许多，而且更安全。</p>
<p>如今我们是活在一个 object 时代。只要与编程有关，无论何事都离不开 object。但 object 并未消除回调，反而把它发扬光大，弄得到处都是，只不过大都以事件（event）的身份出现，镶嵌在某个结构之中，显得更正统，更容易被人接受。应用程序要使用某个构件，总要先弄清构件的属性、方法和事件，然后给构件属性赋值，在适当的时候调用适当的构件方法，还要给事件编写处理例程，以备构件代码来调用。何谓事件？它不过是一个指向事件例程的地址，与回调函数地址没什么区别。</p>
<p>事件驱动程序设计是围绕着消息基础形成的，发生一个事件，伴随着一大堆的消息。</p>
<p>回调函数主要用于一些比较费时的操作,或响应不知道何时将会发生的事件,回调函数提供了一种异步的机制,相对于同步执行,提高了效率.</p>
<h4>函数指针</h4>
<p>回调在C语言中是通过函数指针来实现的,通过将回调函数的地址传给被调函数从而实现回调。因此，要实现回调，必须首先定义函数指针，请看下面的例子：</p>
<pre>
void Func(char *s)；// 函数原型
void (*pFunc) (char *);//函数指针
</pre>
<p>可以看出，函数的定义和函数指针的定义非常类似。</p>
<p>一般的化，为了简化函数指针类型的变量定义，提高程序的可读性，我们需要把函数指针类型自定义一下。</p>
<pre>
typedef void(*pcb)(char *);
</pre>
<p>回调函数可以象普通函数一样被程序调用，但是只有它被当作参数传递给被调函数时才能称作回调函数。</p>
<h4>函数调用约定</h4>
<p>main函数前有"_cdecl"标识，说明函数的调用约定，调用方式影响函数调用时参数的传递方式和函数返回后栈的恢复访求。如果为"_cdecl"(是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法)和"_stdcal"方式，则参数均为从右往左入栈，而"_fastcall"使用ECX和EDX寄存器传递，余下部分参数从右向左保存在栈中。</p>
<p>在函数返回后，如果函数是"_cdecl"调用方式，则是调用者将esp和ebp指令恢复到调用前的状态；而如果是"_stdcall"方式，则有被调用函数将栈恢复到调用之前，以便调用函数可以继续执行。</p>
<p>在win32中，常出现"WINAPI"和“CALLBACK”标识，他们都是宏，他们都是指向的是"_stdcall"的调用方式。如果代码中没有指定函数的调用方式，那么编译器会根据编译选项(/Gz /Gd /Gr)来决定参数的处理凡是。一般的WindowsAPI都是使用stdcall调用方式，而main函数使用cdecl调用约定。</p>
<p>实例一</p>
<pre>
#include <iostream>
typedef void (*MyFun)(int n, char* str);
class Call
{
private:
    MyFun myFun;
public:
    void SetFun(MyFun _myFun)
    {
        myFun = _myFun;     
    }
    void LetRun(int n, char* str)              
    {
        myFun(n, str);     
    }  
}; 
void Test(int n, char* str)   //如果不定义全局函数，而定义在类中 则必须是静态成员函数
{
    while(n>0)
    {
        cout&lt;&lt;n&lt;&lt;" "&lt;&lt;str&lt;&lt;endl;
        n--;
    }
} 
int main()
{ 
    Call call;
    call.SetFun((MyFun)Test);    //调回调函数的接口，并传入一个函数作为参数
    call.LetRun(10,"hello"); 
 
    system("pause");
    return 0;
}
</pre>
 
<p>实例二</p>
<pre>
#include &lt;iostream>
class AClass
{
public:
    void method1()
    {
        std::cout &lt;&lt; "Method 1" &lt;&lt; std::endl;
    }
    void method2()
    {
        std::cout &lt;&lt; "Method 2" &lt;&lt; std::endl;
    }
};
int main()
{
    void (AClass::*Method)(void); 
    AClass  inst1;
    Method = &AClass::method1;
    (inst1.*Method)(); 
 
    AClass* inst2 = new AClass;
    Method = &AClass::method2;
    (inst2->*Method)();
    delete inst2; 
 
    system("pause");
    return 0;
}
</pre>
 

<p style='float:right;'>本页共133段，4310个字符，8448 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
