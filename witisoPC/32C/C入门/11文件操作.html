<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>11文件操作</h4>


<h4>11.1 普通文件与设备文件，文件夹</h4>
<p>    “文件”是指一组相关数据的有序集合。普通文件存储在磁盘等外部设备中，在需要的时候由程序将数据读入内存。普通文件都有一个文件名，以方便程序打开和读写等操作。在操作系统中，把外部设备也看作是一个文件来进行管理，把它们的输入、输出等同于对磁盘文件的读和写。比如显示器、打印机、键盘等。</p>
<h4>11.2 文本文件与二进制文件   </h4>
<p>从存储的格式来看，文件分为文本文件与二进制文件。</p>
<p>常见的文本文件：.c文件，.txt文件等。</p>
<p>    常见的二进制文件：exe，dll，jpg，doc等。</p>
<p>    文本文件基于字符编码，以固定长度的二进制序列进行编码和解码（常见的有ASCII文编码和Unicode编码），而二进制文件是基于值编码的文件，二进制文件编码是变长的，具体的长度由具体的格式决定，比如EXE或者BMP二进制文件。文本文件使用notepad就可以读取，而二进制文件需要专门的工具，比如图片就需要专门的读图软件才能打开，如果用notepad打开，就会看见不少乱码。</p>
<p>    文本“5678”的存储形式为：字符的ASCII码： 00110101 00110110 00110111 00111000 （四个字节）</p>
<p>    值5678的存储形式为：值的二进制： 00010110 00101110 （两个字节）</p>
<p>“用文本方式读写的文件一定是文本文件，用二进制读写的文件一定是二进制文件”这类观点是错误的。C的文本方读写与二进制读写的差别仅仅体现在回车换行符的处理上。文本方式写时，每遇到一个\n(0AH换行符)，它将其换成\r\n(0D0AH，回车换行)，然后再写入文件；当文本读取时，它每遇到一个\r\n将其反变化为\n，然后送到读缓冲区。二进制读写时，其不存在任何转换，直接将写缓冲区中数据写入文件。</p>
<h4>11.3 文件系统</h4>
<p>“文件系统”是指操作系统中用于组织和管理磁盘上文件的方法以及数据结构。文件系统负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。程序中相关的文件操作，最后都会交给文件系统去替程序完成。</p>
<p>常见的文件系统有：FAT，NTFS，Ext2-4，ZFS等文件系统。其中FAT和NTFS用于WINDOWS系统，而Ext2-4用于Linux系统，ZFS则用于Solaris系统。</p>
<p>VFS是Linux中的一个抽象的统一接口：它定义了所有文件系统都支持的基本的和概念上的接口和数据结构，这样就在用户上层看来，无论对何种文件系统都拥有统一的接口，和操作方式。一是上层的文件系统的系统调用，二是虚拟文件系统 VFS(Virtual Filesystem Switch)，三是挂载到 VFS 中的各实际文件系统。</p>
<h4>11.4 打开文件fopen_s</h4>
<p>在进行文件读写等操作的时候，首先需要调用fopen()函数打开文件，先得到文件的指针或者句柄。在打开文件时候，需要设置打开文件的标志。一些常见的标志如图所示：</p>
<p> fopen("newfile.txt", "rw, ccs=UTF-8");//默认为ANSI</p>
<p>fopen是C标准IO库的函数，与非C标准库函数open()函数相比，用fopen打开的文件读写是带缓存的，即用fwrite向文件里写一个字节，一般来讲它不会立刻调用write将该操作提交给kernel，而是积累到一定程度再一起写。</p>
<p>在Windows中，文本方式写时，存在”\n”与”\r\n”的转换，而二进制方式无转换。文本方式读时存在”\r\n”à至”\n”的转换，而二进制方式无转换。在linux中文本方式的读写与二进制方式的读写无差别，不存在回车换行间的转换。这样当直接在windows和linux中共享文件时，将会出现与回车换行相关的问题。</p>
<p>fopen_s()函数是用于fopen()的新的安全版本。现在都推荐使用fopen_s()来打开文件。它的调用方法：</p>
<pre>
FILE *pfile=NULL;
errno_t err = fopen_s(&pfile,FILENAME,"wb+");
if(err!=0 || pfile==NULL)
{
        return -1;
}
</pre>
<p>    当完成了文件IO之后，最后不要忘记了调用fclose()函数将文件关闭。比如：</p>
<pre>
    fclose(pfile);
</pre>
<h4>11.5 读写文件</h4>
<p>文件操作中，最频繁的就是文件的读写操作了。在C语言里，可以使用fread/fwrite,fscanf/fprintf,fgets/fputs,fgetc/fputc等函数来进行文件的读写。总的来说，C语言中文件的读写分为如下几种形式：</p>
<p>11.5.1 二进制文件读写</p>
<pre>
int  binary_io()
{
    //打开或者创建文件
    char *path = "h:\\doc\\new.txt";
    FILE *fp1 = NULL;
    errno_t err;
    err = fopen_s(&fp1,path,"w");
    if(fp1==NULL || err != 0)
    {
        printf("Open file failed\n");
        return -1;
    }
    //基于fp1这个指针，对文件进行读写等操作
    char buff[]="hello world";
    fwrite(buff,sizeof(buff),1,fp1);
    int data = 0x10;
    fwrite(&data,sizeof(data),1,fp1);
    fclose(fp1);
    //读数据
    err = fopen_s(&fp1,path,"r");
    if(err!=0)
    {
        return -1;
    }
    data = 0;
    memset(buff,0,sizeof(buff));
    fread(buff,sizeof(buff),1,fp1);
    printf("buff:%s\n", buff);
    fread(&data,sizeof(data),1,fp1);
    printf("data:0x%x\n", data);
    fclose(fp1);
    return 0;
}
</pre>
<p>11.5.2 格式化输入输出到文本文件。</p>
<p>将除了ascci之外的数据以文本的方式写入文件</p>
<pre>
int format_io()
{
    char *file="h:\\doc\\1.txt";
    FILE *pfile=NULL;
    errno_t err = fopen_s(&pfile,file,"w");
    if(err!=0 || pfile==NULL)
    {
        printf("Open file failed\n");
        return -1;
    }
    fprintf(pfile,"%s %x %lf","hello-world",
        0x10,3.1415);
    fclose(pfile);
    char buff[64]={0};
    int data=0;
    double d = 0.0;
    err=fopen_s(&pfile,file,"r");
    if(err!=0)
    {
        printf("Open file failed\n");
        return -1;
    }
    fscanf_s(pfile,"%s%x%lf",buff,64,&data,&d);
    printf("buff:%s,data:%d,d:%lf\n",buff,data,d);
    fclose(pfile);
    return 0;
}
</pre>
<p>11.5.3 字符输入输出到文本文件</p>
<pre>
int char_io()
{
    char *path="h:\\doc\\test.dat";
    FILE *pfile = NULL;
    errno_t err = fopen_s(&pfile,path,"w");
    if(err!=0 || pfile==NULL)
    {
        printf("Open file failed\n");
        return -1;
    }
    char *str="hello world, goodbye world!";
    while(*str!='\0')
    {
        fputc(*str,pfile);
        str++;
    }
    fclose(pfile);
    err = fopen_s(&pfile,path,"r");
    if(err!=0 ||pfile==NULL)
    {
        return -1;
    }
    while(!feof(pfile))
    {
        printf("%c",fgetc(pfile));
    }
    printf("\n");
    fclose(pfile);
    return 0;
}
</pre>
<p>11.5.4 字符串输入输出到文本文件</p>
<pre>
int str_io()
{
    char *file ="h:\\doc\\str.txt";
    FILE *pfile = NULL;
    errno_t err = fopen_s(&pfile,file,"w");
    if(err!=0 || pfile==NULL)
    {
        return -1;
    }
    fputs("hello world!\n",pfile);//\n-->\r\n
    fputs("nice to meet u\n",pfile);
    fclose(pfile);
    err = fopen_s(&pfile,file,"r");
    if(err!=0 || pfile==NULL)
    {
        return -1;
    }
    char buff[1024]={0};
    while(!feof(pfile))
    {
        fgets(buff,1024,pfile);
        printf("%s", buff);
        memset(buff,0,1024);
    }
    fclose(pfile);
    return 0;
}
</pre>
<p>在Windows中，文本方式写时，存在”\n”à”\r\n”的转换，而二进制方式无转换。文本方式读时存在”\r\n”至”\n”的转换，而二进制方式无转换。在linux中文本方式的读写与二进制方式的读写无差别，不存在回车换行间的转换。这样当直接在windows和linux中共享文件时，将会出现与回车换行相关的问题。</p>
<h4>11.6 文件相关操作</h4>
<p>在C语言中除了文件的读写操作之外，还有如下一些有关文件的其它操作：</p>
<p>11.6.1 rewind</p>
<p>在文件进行读写操作的时候，有一个叫当前读写位置的指针，用来记录文件当前读写的位置。可以通过rewind()函数或者fseek()函数来移动文件的当前读写位置指针。</p>
<pre>
rewind(fp);//首部
</pre>
<p>执行完上面的函数后，会将文件fp当前的读写位置移动到文件的开头位置。</p>
<p>将文件当前读写位置移动到最开始的地方。等同于:</p>
<pre>
fseek(fp,0,0);
</pre>
<p>11.6.2 fseek</p>
<p>fseek()函数用于更灵活的移动文件当前的读写位置指针。它有三个参数，第一个参数是被打开文件的指针，第二个参数是移动的偏移，偏移值可以为正或者为负，第三个参数是代表第二个参数的偏移相对于什么位置。比如：</p>
<pre>
fseek(fp,50,SEEK_CUR);
</pre>
<p>那么就是将文件的读写指针移动到当前位置后面50个字节。而SEEK_SET则是相对于文件开头，SEEK_END是文件结尾。比如</p>
<pre>
fseek(fp, -50, SEEK_END);
</pre>
<p>就是将文件读写指针移动到距离文件结束50个字节的位置。</p>
<p>下面是使用fseek()函数来移动文件读写指针的一个例子：</p>
<pre>
int seek_demo()
{
    //打开或者创建文件
    char *path = "h:\\doc\\new.txt";
    FILE *fp1 = NULL;
    errno_t err;
    err = fopen_s(&fp1,path,"w");
    if(fp1==NULL || err != 0)
    {
         printf("Open file failed\n");
         return -1;
    }
    //基于fp1这个指针，对文件进行读写等操作
    char buff[]="hello world";
    fwrite(buff,sizeof(buff),1,fp1);
        
    //rewind(fp1);
    fseek(fp1,-5,SEEK_CUR);
    int data = 0x10;
    fwrite(&data,sizeof(data),1,fp1);
    fclose(fp1);
    //读数据
    err = fopen_s(&fp1,path,"r");
    if(err!=0)
    {
         return -1;
    }
    data = 0;
    memset(buff,0,sizeof(buff));
    fread(buff,sizeof(buff),1,fp1);
    printf("buff:%s\n", buff);
    fread(&data,sizeof(data),1,fp1);
    printf("data:0x%x\n", data);
    fclose(fp1);
    return 0;
}
</pre>
<p>11.6.3 feof</p>
<p>在读文件的时候，当文件的当前位置到达文件末尾，就不能继续读数据了。函数feof()就是用来判断文件当前位置是否达到文件末尾，如果到达，就返回真，否则为假。</p>
<p>下面是一个使用feof()来读文件的例子：</p>
<pre>
int read_ini()
{
    char *file="h:\\doc\\config.ini";
    FILE *pfile = NULL;
    errno_t err = fopen_s(&pfile,file,"r");
    if(err !=0 ||pfile == NULL)
    {
         return -1;
    }
    while(!feof(pfile))//如果文件当前读写位置没有到达结尾，就继续读
    {
         char buff[1024]={0};
         fgets(buff,1024,pfile);
         printf("%s",buff);
    }
    printf("\n");
    fclose(pfile);
    return 0;
}
</pre>
<p>11.6.4 rename/remove/mkdir</p>
<p>文件的重命名，删除，创建文件夹都是与文件有关的一些基本操作。下面一一介绍C语言里这些函数的调用方式：</p>
<p>1 重命名文件：</p>
<pre>
void rename_file()
{
    //将文件1.txt重命名为2.txt
    char *src="h:\\doc\\1.txt";
    char *dst="h:\\doc\\2.txt";
    rename(src,dst);
}
</pre>
<p>2 删除文件</p>
<pre>
void delete_file()
{
    char *del_file = "h:\\doc\\test.dat";
    remove(del_file);
}
</pre>
<p>3 创建文件夹</p>
<pre>
int  create_dir()
{
    //创建文件夹
    char *dir = "h:\\doc\\test\\x";
    int res = _mkdir(dir);//注意，创建不能递归完成，h:\doc\test必须已经存在，否则函数会失败
    if(res==-1)
    {
         printf("create dir failed\n");
         return -1;
    }
    return 0;
}
</pre>
<p>11.6.5 ftell</p>
<p>函数ftell()用于获取文件读写指针的当前位置。可以结合fseek()函数来计算文件的大小，代码如下：</p>
<pre>
static long getfilesize(char *szFile)
{
    long size = 0;
    if (szFile == NULL)
    {
         return 0;
    }
    FILE *fp;
    if((fp=fopen(szFile,"r"))==NULL)
         return 0;
    fseek(fp,0,SEEK_END);// 首先将文件读写指针移动到文件结尾
    size = ftell(fp);    // 获取文件读写指针的当前位置，即为文件大小;
    fclose(fp);
    return size;
}
</pre>
<h4>11.7 结构体的文件读写更新</h4>
<p>首先定义下面这样一个结构体：</p>
<pre>
#define MAXLEN 64
typedef struct _record
{
    char name[MAXLEN];
    int age;
}record,*precord;
record  r =  {“tom”,25};
</pre>
<p>要将结构体变量r中的数据写入文件，可以按照下面的方法直接写入：</p>
<pre>
fwrite(&r,sizeof(r),1,fp);
</pre>
<p>当时，这样写入，会导致结构体中成员name[MAXLEN]中大量的零被写入，导致文件中存放了很多无用的数据零。所以，这样直接写入不是最佳方法。</p>
<p>于是可以考虑将这个结构体按照如下格式写入文件：</p>
<p>假如name[MAXLEN]中的有效字符个数为len，那么写入方法为：</p>
<p>Len+name+age</p>
<p>也就是先将name的字符数len写入文件，接着写入name的有效字符数据，再写入年龄数据。其中len和age各为4个字节的整数，name为字符。比如对于下面结构体记录数据：</p>
<pre>
record  r1  =  {“tom”,25};
record  r2  =  {“lily”,22};
</pre>
<p>3”tom”25 4”lily”22</p>
<p>这样在每个name前面都用一个长度来记录name中字符的个数，就可以避免将过多的无用的零写入文件了。</p>
<p>下面是实现这种方式写入和读出数据方法的代码：</p>
<pre>
int opt_write_file(FILE *fp)
{
    char ch;
    do
    {
         record rcd={0};
         printf("Please input name and age\n");
         scanf_s("%s%d", rcd.name,MAXLEN,&rcd.age);
         size_t len = strlen(rcd.name);
         fwrite(&len,sizeof(len),1,fp);//先写入name中字符的个数
         fwrite(rcd.name,len,1,fp);//接着写入name字符数
         fwrite(&rcd.age,sizeof(int),1,fp);//再写入年龄
         printf("input q to quit,else to continue\n");
         //scanf_s("%c",&ch,1);
         //fflush(stdin);
         ch = _getch();
         if(ch=='q')
             break;
    } while (1);
    return 0;
}
int opt_read_file(FILE *fp)
{
    while(!feof(fp))
    {
         record rcd = {0};
         size_t len=0;
         int res = fread(&len,sizeof(len),1,fp);//先读取name的字符数
         if(res == 0)
         {
             return 0;
         }
         fread(rcd.name,len,1,fp);//再按照字符数读取name
         fread(&rcd.age,sizeof(rcd.age),1,fp);//再读取年龄
         printf("name:%s,age:%d,res:%d\n", rcd.name,rcd.age,res);
    }
    return 0;
</pre>


<p style='float:right;'>本页共372段，9716个字符，15026 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
