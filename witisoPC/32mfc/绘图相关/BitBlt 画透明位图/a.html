<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:75.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:130%;
	line-height:140%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:100%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
height:28px;
//white-space:nowrap;
//overflow:hidden; 
//text-overflow:ellipsis; 
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
padding-left:2px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
</style>
</head>

<body>

<div id="container">
  <p align="left"><strong>BitBlt</strong><strong>（）用法 </strong></p>

<p>在VC中显示位图常用取BitBlt（）方法，它是将一幅位图从一个设备场景复制到另一个。源和目标DC相互间必须兼容。</p>

<p>虽然此方法的功能是这样的，但是我一直没有理解网上一些例子代码，不知道其用到的各DC和位图如何得到，及它们之间的关系。</p>

<p>今天工作中要将一些位图显示到窗口中，所以重要学习了一下。</p>

<p>我已经将要用的位图导入到工程资源中，所以我可以用：</p>

<p> CBitmap cbmp;</p>

<p> cbmp.LoadBitmap(IDB_BMP1);</p>

<p>这样得到一个CBitmap对象。</p>

<p>然后：</p>

<p> BITMAP bitmap;</p>

<p> cbmp.GetBitmap(&amp;bitmap);</p>

<p>这样得到一个BITMAP对象，之所以要得到此对象是因为从其中可以得到位图的大小数据。</p>

<p>然后计算得到要在什么位置显示此位图（可以放在一个CRect rect;对象中）。</p>

<p></p>

<p>然后显示此位图，这是最重要的一步：</p>
<p></p>

<pre>
CDC dcMemory;
dcMemory.CreateCompatibleDC(pDC);
hOldBitmap = dcMemory.SelectObject(&cbmp);
pDC->BitBlt(rect.left,
    rect.top,
    bitmap.bmWidth,
    bitmap.bmHeight,
    &dcMemory,
    0,0,
    SRCCOPY);
</pre>

<p>其中pDC是一个CDC*，是将要在其中显示位图的设备环境。</p>

<p></p>

<p>这样位图就已经显示出来了，但是还要释放资源：</p>

<p> cbmp.DeleteObject();</p>

<p> dcMemory.SelectObject(hOldBitmap);</p>

<p> dcMemory.DeleteDC();</p>

<p>其中，要将临时设备环境选择入初始时位图，否则将不能正确释放！！</p>

<p></p>

<p>总结：</p>

<p>要在一个设备环境中显示位图，不能直接在上面“画”（目前我是我么觉得的），需要创建一个与之相兼容的新设备环境然后将位图选择入些新设备环境，然后再从些新设备环境中拷备位图以显示到正确的设备环境中。而选入这个动作相当与已经将位图“画在了临时设备环境中”（实际上并没有画，否则就可以直接选入要画图的CDC了），而且选入后位图在临时设备环境中的位置是左上角！ </p>
  <h3><a href="https://blog.csdn.net/linshaolie/article/details/21905739?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">使用BitBlt实现位图背景透明</a></h3>

<p>我们先看一下BitBlt这个函数的原型：</p>
  <p>BOOL BitBlt(intx,int y, int  nWidth,nHeight, CDC* PsrcDC, int xSrc, int ySrc, DWORD dwRop);</p>
  <p>参数介绍：</p>
  <p>int x                表示绘制位图目标左上角x坐标；</p>
  <p>int y  表示绘制位图目标左上角y坐标；</p>
  <p>int nWidth 表示绘制位图目标的区域宽度；</p>
  <p>int nHeight           表示绘制位图目标的区域高度；</p>
  <p>CDC* pSrcDC       表示存储源位图的设备描述表；</p>
  <p>int xSrc 表示源位图的左上角x坐标；</p>
  <p>int ySrc 表示源位图的左上角y坐标；</p>
  <p>DWORD dwRop      表示栅格运算标志；</p>
  <p></p>
  <p>dwRop的取值与值的描述如下表所示：</p>
 <table id="tbrowser">
  <col width="123">
  <col width="438">
  <tr height="19">
    <td height="19" width="223">值</td>
    <td width="438">描述</td>
  </tr>
  <tr height="19">
    <td height="19">BLACKNESS</td>
    <td>用调色板中索引为0的颜色(默认是黑色)填充目标矩形。</td>
  </tr>
  <tr height="19">
    <td height="19">CAPTUREBLT</td>
    <td>用调色板中索引为0的颜色(默认是黑色)填充目标矩形。</td>
  </tr>
  <tr height="19">
    <td height="19">DSTINVERT&nbsp;</td>
    <td>将目标矩形反色。&nbsp;</td>
  </tr>
  <tr height="19">
    <td height="19">MERGECOPY</td>
    <td>将源矩形中的颜色与当前目标设备环境选中的画刷通过逻辑与操作进行混合。</td>
  </tr>
  <tr height="19">
    <td height="19">MERGEPAINT</td>
    <td>将源矩形的颜色反色后与目标矩形的颜色通过逻辑或操作进行混合。</td>
  </tr>
  <tr height="19">
    <td height="19">NOMIRRORBITMAP&nbsp;</td>
    <td>防止位图镜像翻转。</td>
  </tr>
  <tr height="19">
    <td height="19">NOTSRCCOPY</td>
    <td>源矩形反色复制到目标矩形。</td>
  </tr>
  <tr height="19">
    <td height="19">NOTSRCERASE</td>
    <td>将源矩形与目标矩形的颜色通过逻辑或操作混合后，再反色。</td>
  </tr>
  <tr height="19">
    <td height="19">PATCOPY</td>
    <td>将目标设备环境选中的画刷复制到目标位图。</td>
  </tr>
  <tr height="19">
    <td height="19">PATINVERT</td>
    <td>将目标设备环境选中的画刷与目标矩形中的颜色进行逻辑异或操作，复制到目标位图。</td>
  </tr>
  <tr height="19">
    <td height="19">PATPAINT</td>
    <td>将目标设备环境选中的画刷与源矩形中的颜色的反色进行逻辑或操作，其结果再与目标矩形的颜色进行逻辑或操作。</td>
  </tr>
  <tr height="19">
    <td height="19">SRCAND</td>
    <td>将源矩形与目标矩形的颜色进行逻辑与操作。</td>
  </tr>
  <tr height="19">
    <td height="19">SRCCOPY</td>
    <td>直接将源矩形拷贝到目标矩形，最常用的绘制位图属性。</td>
  </tr>
  <tr height="19">
    <td height="19">SRCERASE</td>
    <td>将目标矩形的反色与源矩形的颜色进行逻辑与操作。</td>
  </tr>
  <tr height="19">
    <td height="19">SRCINVERT</td>
    <td>将源矩形的颜色与目标矩形进行逻辑异或操作。</td>
  </tr>
  <tr height="19">
    <td height="19">SRCPAINT</td>
    <td>将源矩形的颜色与目标矩形进行逻辑或操作。</td>
  </tr>
  <tr height="19">
    <td height="19">WHITENESS</td>
    <td>用调色板中索引为1的颜色(默认是白色)填充目标矩形。</td>
  </tr>
</table>

  <p>下面是整个实现过程：</p>
  <p>1)创建一张大小与需要绘制图像相同的位图作为“掩码”位图(maskBmp)；</p>
  <p>2)将新创建的“掩码”位图存储至掩码位图的设备描述表(maskDC)中；</p>
  <p>3)把内存设备描述表（memDC）的背景设置成“透明色”(SetBkColor(RGB(?,  ?, ?)))，即不需要显示的颜色；</p>
  <p>4)复制粘贴位图到“掩码”位图的设备描述表中，这个时候“掩码”位图设备描述表中存放的位图与位图设备描述表中的位图一样 (maskDC.BitBlt(……)),此时会进行掩码运算，体现掩码特性，即：与设置的背景设相同的为体现出白色，不同的体现出黑色。（下面会详细说明过程）。</p>
  <p>5)将内存DC里的图片与实际窗口背景颜色（设为白色）做逻辑异或（关键词：SRCINVERT）操作并在实际窗口中呈像；</p>
  <p>6)将掩码DC的图与实际窗口背景颜色做逻辑与（关键字：SRCAND）操作，并在窗口中呈像；</p>
  <p>7)重复第五步。</p>
  <p>下面进行演示：</p>
  <p>首先我们要贴上的图片是如下的一张图（即黑色背景红色方块）：</p>
  <p><img src="1.png" /></p>
  <p>我们要将它的背景透明(其实是变成与背景色相同的颜色)，然后显示在窗口上。</p>
  <p>说明：</p>
  <p>图片宽度定义为 const int BMPWIDTH = 182,</p>
  <p>    高度定义为  const int BMPHEIGHT =172;</p>
  <p></p>
  <p>第一步：创建一张掩码图，代码如下：</p>
  <p>CBitmap maskBmp;</p>

<p>maskBmp.CreateBitmap(BMPWIDTH, BMPHEIGHT,  1, 1,NULL);  </p>
  <p>CreateBitmap函数说明：</p>
  <p>参数1     nWidth：        指定位图宽度、单位为像素。</p>
  <p>参数2     nHeight：       指定位图高度、单位为像素。</p>
  <p>参数3     CPlanes：       指定该设备使用的颜色位面数目。</p>
  <p>参数4     CBitsPerPel：   指定用来区分单个像素点颜色的位数（比特数目）。</p>
  <p>参数5     LpvBits：        指向颜色数据数组指针。这些颜色数据用来设置矩形区域内像素的颜色。矩形区域中的每一扫描线必须是双字节的整数倍（不足部分以0填充）。如果该参数为NULL，将不对新生成的位图进行初始化。</p>
  <p></p>
  <p>第二步：将创建的掩码位图选进掩码位图的设备描述表中</p>
  <p>如下：</p>
  <p></p>

<pre>
CDC maskDC;                            // 定义掩码DC
maskDC.CreateCompatibleDC(NULL);       // 初始化设备DC
CBitmap *oldMaskBmp = maskDC.SelectObject(&maskBmp);  

</pre>

  <p>第三步：将内存设备描述表的背景色设置为透明色（即要实现透明的背景色，如本例子为黑色）</p>
 
<pre>
CBitmap bmpSquare; 		    // 定义一个CBitmap对象存储将要绘制的图(ID为IDC_SQUARE)
bmpSquare.LoadBitmap(IDC_SQUARE);    // 加载位图
 
CDC memDC;                   	    // 创建内存DC
memDC.CreateCompatibleDC(NULL);                        // 初始化DC
CBitmap *oldMemBmp = memDC.SelectObject(&bmpSquare);   // 将位图存入内存DC中,并返回旧的位图
memDC.SetBkColor(RGB(0,0,0));      
</pre>
         

  <p>第四步：将内存DC的位图在掩码DC中呈像</p>
  <p>maskDC.BitBlt(0, 0, BMPWIDTH, BMPHEIGHT,  &amp;memDC, 0,0, SRCCOPY);</p>

<p>说明：</p>
  <p style="background-color:#ccc">memDC中图为(黑色底红色方块):<img width="5%" src="1.png" /> + memDC背景色(全黑):<img width="5%" src="3.jpg" /> = 掩码计算后(白色底黑色方块):<img width="5%" style="border:#CCCCCC 0px solid" src="5.jpg" /></p>
  <p></p>
  <p style="background-color:#ccc">现在maskDC中的图即为：<img style="border:#CCCCCC 0px solid"  width="5%" src="5.jpg" /> （白底黑方块）</p>
  <p></p>
  <p></p>
  <p>第五步：将内存DC里的图片与实际窗口背景颜色（设为白色）做逻辑异或（关键词：SRCINVERT）操作并在实际窗口中呈像；如下：</p>
  <p>CPanitDC dc(this);            //窗口DC</p>

<p>dc.BitBlt(0, 0, BMPWIDTH, BMPHEIGHT,  &amp;memDC, 0, 0,SRCINVERT);</p>

<p>说明：</p>
  <p style="background-color:#ccc">memDC中图为（黑色底红色方块）<img width="5%" src="11.jpg" />：+窗口背景色（全白）<img width="5%" src="12.jpg" />：=异或操作后（白底蓝绿色方块）：<img width="5%" src="13.jpg" /> .</p>
  <p>逻辑说明：</p>

<pre>
  memDC背景（黑）其RGB为：     0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0
  窗口背景（白）为：           1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1
  异或操作（相同为0不同为1）： 1 1 1 1 1 1 1 1，1 1 1 1 1 1  1 1，1 1 1 1 1 1 1 1（白色）
  ------------------------------------------------------
  memDC方块（红）为：  1 1 1 1 1 1 1 1，0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0
  窗口背景（白）为：   1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1
  异或操作结果：       0 0 0 0 0 0 0 0，1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1（蓝绿色）
</pre>

   
  <p>第六步：将掩码DC的图与实际窗口背景颜色做逻辑与（关键字：SRCAND）操作，并在窗口中呈像；如下：</p>
  <p>dc.BitBlt(0, 0, BMPWIDTH, BMPHEIGHT,  &amp;maskDC, 0, 0,SRCAND);</p>

<p>说明：</p>
  <p style="background-color:#ccc">maskDC中图为（白底黑方块）：<img width="5%" src="21.jpg" /> + 窗口背景色（白底蓝绿色方块）：<img width="5%" src="22.jpg" /> = 异或操作后（白底黑方块）：<img width="5%" src="23.jpg" /> .</p>
  <p></p>
  <p style="background-color:#ccc">此时在绘图区域的背景图为<img width="5%" src="23.jpg" />（白色背景黑色方块）</p>
  <p>逻辑说明：</p>
<p></p>

<pre>
maskDC背景（白）其RGB为：     1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1
窗口背景（白）为：            1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1
与操作（1，1为1，其他为0）：  1 1 1 1 1 1 1 1，1 1 1 1 1 1  1 1，1 1 1 1 1 1 1 1（白色）
---------------------------------------------------------------
maskDC方块（黑）为：    0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0
窗口背景（蓝绿）为：    0 0 0 0 0 0 0 0，1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1
逻辑与操作结果：        0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0（黑色）
</pre>

  <p></p>
  <p>第七步：也是最后一步，重复第五步，也就是将内存DC里的图片与实际窗口背景颜色（设为白色）做逻辑异或（关键词：SRCINVERT）操作并在实际窗口中呈像；如下：</p>
  <p>dc.BitBlt(0, 0, BMPWIDTH, BMPHEIGHT,  &amp;memDC, 0, 0,SRCINVERT);</p>

<p>说明：</p>
  <p style="background-color:#ccc">memDC中图为（黑底红方块）<img width="5%" src="31.jpg" />：+窗口背景色（白底黑方块）：<img width="5%" src="32.jpg" />  = 异或操作后（白底红方块）：<img width="5%" src="33.jpg" />.</p>
  <p>逻辑说明：</p>
<p></p>

<pre>
  memDC背景（黑）其RGB为：     0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0
  窗口背景（白）为：           1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1，1 1 1 1 1 1 1 1
  异或操作（相同为0不同为1）： 1 1 1 1 1 1 1 1，1 1 1 1 1 1  1 1，1 1 1 1 1 1 1 1（白色）
  ------------------------------------------------------------------------
  memDC方块（红）为：  1 1 1 1 1 1 1 1，0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0
  窗口背景（黑）为：   0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0
  异或操作结果：       1 1 1 1 1 1 1 1，0 0 0 0 0 0 0 0，0 0 0 0 0 0 0 0（红色）1
</pre>

  <p></p>
  <p>此时的方块背景色白色即与整个窗口背景色相同，也就是说我们实现了透明显示位图哈。</p>
  <p>最后，别忘记把改释放的资源释放！</p>
  <p>如：</p>
  <p>maskDC.SelectObject(oldMaskBmp);</p>

<p>memDC.SelectObject(oldMemBmp);</p>

<p>memDC.DeleteDC();</p>


<h3><a href="https://blog.csdn.net/u012513234/article/details/45250911">BitBlt画透明位图</a></h3>

<p>    CDC::BitBlt函数，应用在GDI的绘图中，有时候我们需要显示的位图有一部分是透明的，例如在棋类游戏中，棋盘图片和棋子图片融合的时候，棋子边缘应该是透明。</p>

<p>   在图1中，棋盘和棋子图片融合在一起，需要设置棋子图片边缘的“品红色”为透明。<img width="1000" height="315" src="a_clip_image001.jpg" alt="https://img-blog.csdn.net/20150424203609907?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxMzIzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p><strong>BitBlt</strong><strong>函数说明：       </strong><strong> </strong></p>

<p>          </p>

<p>BOOL BitBlt( int  x, int y, int nWidth, int nHeight, CDC* pSrcDC, int xSrc, int ySrc, DWORD dwRop  ); </p>
  <p align="left">     CSDN中关于bitblt函数的说明：Copies a bitmap from the source  device context to this current device context.  将源设备上下文中一个位图，拷贝到当前设备上下文中。其中x,y是当前设备上下文的绘图位置，nWidth和nHeight是位图大小，xSrc和ySrc是源设备上下文的位图位置。dwRop 是源位图和当前位图的运算方式，下面是其取值</p>

<p>BLACKNESS 用黑色填充目标矩形区域.</p>

<p>DSTINVERT 将目标矩形图象进行反相.</p>

<p>MERGECOPY 将源矩形图象与指定的图案刷(Pattern)进行布尔&quot;与&quot;运算.</p>

<p>MERGEPAINT 将源矩形图形经过反相后，与目标矩形图象进行布尔&quot;或&quot;运算.</p>

<p>NOTSRCCOPY 将源矩形图象经过反相后，复制到目标矩形上.</p>

<p>NOTSRCERASE 先将源矩形图象与目标矩形图象进行布尔&quot;或&quot;运算，然后再将得图象进行反相.</p>

<p>PATCOPY 将指定的图案刷复制到目标矩形上.</p>

<p>PATINVERT 将指定的图案刷与目标矩形图象进行布尔&quot;异或&quot;运算.</p>

<p>PATPAINT 先将源矩形图象进行反相，与指定的图案刷进行布尔&quot;或&quot;运算，</p>

<p>再与目标矩形图象进行布尔&quot;或&quot;运算</p>

<p>SRCAND 将源矩形图象与目标矩形图象进行布尔&quot;与&quot;运算.</p>

<p>SRCCOPY 将源矩形图象直接复制到目标矩形上.</p>

<p>SRCERASE 将目标矩形图象进行反相，再与源矩形图象进行布尔&quot;与&quot;运算.</p>

<p>SRCINVERT 将源矩形图象与目标矩形图象进行布尔&quot;异或&quot;运算.</p>

<p>SRCPAINT 将源矩形图象与目标矩形图象进行布尔&quot;或&quot;运算.</p>

<p>WHITENESS 用白色填充目标矩形区域.</p>

<p> 下面举例说明 位图的运算方式，两个位图按照对应像素 按位运算      例如像素（R1，G1，B1）和（R2，G2，B2）采用SRCAND “与”运算，则结果为（R1&amp;R2，G1&amp;G2，B1&amp;B2）。 </p>
  <p align="left"><strong>测试：</strong>建立MFC单文档，在资源中添加BITMAP资源IDB_BITMAP1，IDB_BITMAP2,在view类的OnDraw中，添加以下代码：</p>

<p></p>

<pre>
void CXXXXXXXXView::OnDraw(CDC* pDC)
{
	CceshiTransparentDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	if (!pDoc)
		return;

	// TODO: 在此处为本机数据添加绘制代码
	// 图片1
	CBitmap bitmap1;
	bitmap1.LoadBitmap(IDB_BITMAP1);
	CDC  dcMem1;
	dcMem1.CreateCompatibleDC(pDC);
	CBitmap *pOldBitmap1=dcMem1.SelectObject(&bitmap1);

	// 获取图像尺寸
	BITMAP  bitmapInfo;
	bitmap1.GetBitmap(&bitmapInfo);
	
	// 图片2
	CBitmap bitmap2;
	bitmap2.LoadBitmap(IDB_BITMAP2);
	CDC  dcMem2;
	dcMem2.CreateCompatibleDC(pDC);
	CBitmap *pOldBitmap2=dcMem2.SelectObject(&bitmap2);
	
	// 两个位图取“与”
	pDC->BitBlt(100,100,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMem1,0,0,SRCCOPY);
	pDC->BitBlt(100,100,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMem2,0,0,SRCAND);
	 
	dcMem1.SelectObject(pOldBitmap1);
	dcMem2.SelectObject(pOldBitmap2);

	dcMem1.DeleteDC();
	dcMem2.DeleteDC();
}
</pre>




<p>测试位图（使用两张图，叠在一起）</p>

<p><img width="300" height="200" src="a_clip_image003.jpg"  />

<img width="300" height="200" src="a_clip_image005.jpg"  /></p>

<p>与运算:</p>

<p><img width="100%" height="300" src="a_clip_image007.jpg" alt="https://img-blog.csdn.net/20150424231624772" /></p>

<p></p>

<p>从结果图可以看出，位图操作是逐pixel逐bit进行运算的。 </p>
  <p align="left"><strong></strong><strong>单色位图与彩色位图的相互转化 </strong></p>

<p></p>

<p></p>

<p>CSDN中关于bitblt函数还有以下说明，</p>

<p>If destination, source, and pattern  bitmaps do not have the same color format, theBitBlt function converts the  source and pattern bitmaps to match the destination. The foreground and  background colors of the destination bitmap are used in the conversion.</p>

<p>When the BitBlt function converts a  monochrome bitmap to color, it sets white bits (1) to the background color and  black bits (0) to the foreground color. The foreground and background colors of  the destination device context are used. To convert color to monochrome, BitBlt  sets pixels that match the background color to white and sets all other pixels  to black.BitBlt uses the foreground and background colors of the color device  context to convert from color to monochrome. </p>
  <p align="left">翻译：如果目的，源和模式位图颜色模式不同，<strong>BitBlt</strong>函数会转换源和模式位图，以适应目的位图。目的位图的前景色和背景色，应用在转换过程中。单色位图只有“1”和“0”两种像素值。</p>

<p>BitBlt函数转换<strong>“单色位图”（源）</strong>到<strong>“彩色位图”（目的）</strong>时，会将<strong>“单色位图”</strong>中的<strong>“1”</strong>转化为<strong>背景色</strong>（<u>目的的背景色</u>），<strong>“0”</strong>转化为<strong>前景色</strong>（<u>目的的前景色</u>）。这里需要十分注意背景设置函数pdcDest-&gt;SetBkColor(...)和前景设置函数pdcDest-&gt;SetTextColor(...)的使用。</p>

<p>BitBlt函数转换<strong>“彩色位图”（源）</strong>到<strong>“单色位图”（目的）</strong>时，将<strong>“彩色位图”</strong>中像素值等于<strong>“背景色”</strong>（通过pdcSource-&gt;SetBkColor(...)设置）的像素转化为<strong>“单色位图”</strong>中为<strong>“1”</strong>，其他的像素值变成了“0”。</p>

<p><strong>测试图片：</strong></p>

<p><strong><img width="319" height="319" src="a_clip_image009.jpg" alt="https://img-blog.csdn.net/20150425094011375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxMzIzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></strong><strong></p>

<p></strong></p>

<p>测试代码：</p>
<p></p>

<pre>
	// 第1步：加载源位图bitmapDest，选入内存设备dcDest
	CDC dcSource;
	dcSource.CreateCompatibleDC(pDC);
	CBitmap bitmapDest;
	bitmapDest.LoadBitmap(IDB_BITMAP3);
	CBitmap *pOldBitmapDest=dcSource.SelectObject(&bitmapDest);// 源位图 选到了设备上下文

	BITMAP bitmapInfo;                                         // 获取位图信息
	bitmapDest.GetBitmap(&bitmapInfo);

	// 第2步：建立单值位图bitmapMonochrome，选入内存设备dcMonoChrome

	CDC dcMonoChrome;                       // 单色设备上下文
	dcMonoChrome.CreateCompatibleDC(pDC);
	CBitmap bitmapMonochrome;
	bitmapMonochrome.CreateBitmap(bitmapInfo.bmWidth,bitmapInfo.bmHeight,1,1,NULL);
	CBitmap *pOldBitmapMonoChrome=dcMonoChrome.SelectObject(&bitmapMonochrome);        


	// 第3步：彩色位图 -----------> 单色位图 

	/// 注意这里设置  源位图的背景色
	dcSource.SetBkColor(RGB(164,51,39));  

	// 源位图中   像素值为(164,51,39)的 对应到单色位图中的1，其他值变为0
	dcMonoChrome.BitBlt(0,0,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcSource,0,0,SRCCOPY);  


	// 第4步:画出转化后的单色图

	// pDC->BitBlt(50,50,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMonoChrome,0,0,SRCCOPY);

	// 第5步:单色图   ---------->   彩色位图
	pDC->SetBkColor(RGB(220,216,67));                 //单色中的1--------------->(220,216,67)
	pDC->SetTextColor(RGB(173,98,50));                //单色中的0--------------->(173,98,50)
	pDC->BitBlt(50,50,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMonoChrome,0,0,SRCCOPY);


	// 释放
	dcSource.SelectObject(pOldBitmapDest);
	bitmapDest.DeleteObject();
	dcSource.DeleteDC();

	dcMonoChrome.SelectObject(&bitmapMonochrome); 
	bitmapMonochrome.DeleteObject();
	dcMonoChrome.DeleteDC();
</pre>


<p>结果分析：</p>

<p><img width="100%" src="a_clip_image011.jpg"  /></p>


<p></p>

<p></p>

<p><strong>彩色位图融合到彩色背景</strong><strong> </strong></p>

<p>返回文章开头提到的，棋子周围的图片透明处理。这里要借助单色位图，作为 “掩图”，去除棋子周围的透明区域。</p>

<p>性质1：二进制逻辑运算中，0[xor]0=0；0[xor]1=1，可见，“异或”操作中0具有保持原bit不变的性质。</p>

<p></p>

<p>性质2：1[xor]0[xor]0=1；1[xor]1[xor]1=1；0[xor]1[xor]1=0；0 [xor]0[xor]0=0； 可见，一个bit1[xor]bit2[xor]bit2=bit1 连续“异或”，和“没有操作”一样。</p>

<p>借助一些小技巧，可以去掉图片周围的底色，现在有下面的“背景图”（A）和“源位图”（B），需要去掉“鸣人”周围的“棕红色”区域。</p>

<p>问题：根据性质2，A[异或]B[异或]B，可以去掉“棕红色”，但是糟糕的是“鸣人”也去掉了。</p>

<p>解决办法：在根据性质1，在第一次 [异或]B 后，将“鸣人”区域置为0，“棕红色”区域保持不变，办法是中间加上一个[与]操作。根据鸣人图片制作一个“掩码”图片，即图（C）。</p>

<p></p>

<p></p>

<p>图片叠加的步骤：A[异或]B[与]C[异或]B</p>

<p><img width="319" height="319" src="a_clip_image013.jpg" alt="https://img-blog.csdn.net/20150425125209078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxMzIzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" />       </p>

<p>               （A）      </p>

<p></p>

<p></p>

<p><img width="319" height="319" src="a_clip_image014.jpg" alt="https://img-blog.csdn.net/20150425125147331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxMzIzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p></p>

<p></p>

<p></p>

<p>             （B）</p>

<p></p>

<p></p>

<p><img width="319" height="319" src="a_clip_image016.jpg" alt="https://img-blog.csdn.net/20150425130638030?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxMzIzNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>

<p></p>

<p></p>

<p></p>

<p>              （C）</p>

<p>测试代码：</p>
<p></p>

<pre>
	// 第1步:创建背景  
	CBitmap bitmapBack;
	bitmapBack.LoadBitmap(IDB_BEIJING);
	CDC dcMemBack;
	dcMemBack.CreateCompatibleDC(pDC);
	CBitmap *pOldBitmapBack=dcMemBack.SelectObject(&bitmapBack);

	BITMAP bitmapInfo;
	bitmapBack.GetBitmap(&bitmapInfo);

	// 第2步：创建源图
	CBitmap bitmapSource;
	bitmapSource.LoadBitmap(IDB_BITMAP3);
	CDC  dcMemSource;
	dcMemSource.CreateCompatibleDC(pDC);
	CBitmap *pOldBitmapSource=dcMemSource.SelectObject(&bitmapSource);

	// 第3步：创建单色图
	CBitmap  bitmapMonochrome;
	bitmapMonochrome.CreateBitmap(bitmapInfo.bmWidth,bitmapInfo.bmHeight,1,1,NULL);
	CDC  dcMemMonochrome;
	dcMemMonochrome.CreateCompatibleDC(pDC);
	CBitmap *pOldBitmapMonochrome=dcMemMonochrome.SelectObject(&bitmapMonochrome);

	// 第4步：源位图----->单色图
	dcMemSource.SetBkColor(RGB(164,51,39));
	dcMemMonochrome.BitBlt(0,0,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMemSource,0,0,SRCCOPY);

	// 第5步：“鸣人”透明叠加“背景”图中
	pDC->BitBlt(50,50,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMemBack,0,0,SRCCOPY);
	pDC->BitBlt(50,50,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMemSource,0,0,SRCINVERT);

	// 注意这里涉及到将“单色位图”-------->“彩色位图”，然后在进行运算，
	// 默认下背景色是(255,255,255)，前景色是(0,0,0)，下面两句可以不加，
	pDC->SetBkColor(RGB(255,255,255));   //将dcMemMonochrome中的“1”转化为(255,255,255)
	pDC->SetTextColor(RGB(0,0,0));       //将dcMemMonochrome中的“0”转化为(0,0,0)

	pDC->BitBlt(50,50,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMemMonochrome,0,0,SRCAND);
	pDC->BitBlt(50,50,bitmapInfo.bmWidth,bitmapInfo.bmHeight,&dcMemSource,0,0,SRCINVERT);

	// 释放
	dcMemBack.SelectObject(pOldBitmapBack);
	bitmapBack.DeleteObject();
	dcMemBack.DeleteDC();
	
	dcMemSource.SelectObject(pOldBitmapSource);
	bitmapSource.DeleteObject();
	dcMemSource.DeleteDC();

	dcMemMonochrome.SelectObject(pOldBitmapMonochrome);
	bitmapMonochrome.DeleteObject();
	dcMemMonochrome.DeleteDC();
</pre>


<p>测试结果：</p>

<p><img width="319" height="319" src="a_clip_image018.jpg"  /></p>

</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>

<!--
_____________________________________________________________________________________

1 段落替换
\s*</p>

<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])


------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
\s*</p>\s*
\s*<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________

4 把第和章两个字去掉
第(\S*)章
------------------
$1
_____________________________________________________________________________________

7 正则表达式参考：
https://www.toutiao.com/i6370960744082571778/
_____________________________________________________________________________________

8
<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
9 将标注序号更改为上标，红色，需一个个替换，英文html中有[1]
(\[\d\])
------------------
<sup>$1</sup>
_____________________________________________________________________________________
10 替换章不是以1-9。?！…”“结尾的段落
([^1-90。?！…”：？“章])</p>
<p>
------------------
$1
-->


