<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h4>Windows窗口原理</h4>


<h4>1、Windows程序开发流程</h4>
<p>Windows 程序分为「程序代码」和「UI资源」两大部分，通过RC编译器整合为一个完整的EXE 文件。</p>
<img src="img/1.png" width="100%" />
<p>所谓UI 资源是指功能菜单、对话框外貌、程序图标、光标形状等等东西。</p>
<p>这些UI 资源的实际内容（二进制代码）系借助各种工具产生，并以各种扩展名存在，如.ico、.bmp、.cur 等等。程序员必须在一个所谓的资源描述档（.rc）中描述它们。</p>
<p>RC 编译器（RC.EXE）读取RC 档的描述后将所有UI资源档集中制作出一个.RES 档，再与程序代码结合在一起，这才是一个完整的Windows可执行文件。</p>
<h4>2、Windows程序与操作系统之间的关系</h4>
<p>Windows 程序的进行系依靠外部发生的事件来驱动。换句话说，程序不断等待（利用一个while 回路），等待任何可能的输入，然后做判断，然后再做适当的处理。上述的「输入」是由操作系统捕捉到之后，以消息形式（一种数据结构）进入程序之中。</p>
<img src="img/2.png"  />
<h4>3、Windows窗口生命周期</h4>
<p>3.1 程序初始化过程中调用CreateWindow，为程序建立了一个窗口，作为程序的屏幕舞台。CreateWindow产生窗口之后会送出 wM_CREATE直接给窗口函数，后者于是可以在此时做些初始化操作（例如配置内存、打开文件、读初始数据……）。</p>
<p>3.2 在程序活着的过程中，不断以 GetMessage从消息队列中抓取消息。如果这个消息是WM_oUIT，GetMessage会传回0而结束while循环，进而结束整个程序。</p>
<p>3.3 DispatchMessage通过Windows USER模块的协助与监督，把消息分派至窗口函数。消息将在该处被判别并处理。</p>
<p>3.4 程序不断进行第2步和第3步的操作。</p>
<p>3.5 当使用者按下系统菜单中的Close命令项时，系统送出WM_CLOSE。通常程序的窗口函数不拦截此消息，于是 DefWindowProc处理它。</p>
<p>3.6 DefWindowProc收到 WM_CLOSE后，调用 DestroyWindow把窗口清除。Destroy Window本身又会送出WM_DESTROY。</p>
<p>3.7 程序对WM_DESTROY的标准反应是调用PostQuitMessage。</p>
<p>3.8 PostQuitMessage没什么其它操作，就只送出 WM_QUIT 消息，准备让消息循环中的GetMessage取得，如步骤2，结束消息循环。</p>
<h4>4 Windows窗体原理</h4>
<p>Windows的三大核心系统：负责窗口对象产生和消息分发的USER模块，负责图像显示绘制的GDI模块，负责内存、进程、IO管理的KERNEL模块。</p>
<p>试想象一下如何在一个像素阵列上产生窗口对象，其实就是使用GDI绘制窗口，不停的以一定的频率刷新显示在屏幕上，这就是图形界面，如果由在DOS或Windows DOS模拟器下编写图形界面的经验这个比较好理解。所以说其实USER模块中的窗口产生是依靠GDI模块的(包括菜单、滚动条等都是使用GDI来绘制的)。</p>
<p>那么，下面我们就从USER模块和GDI模块来说说Windows 的窗体原理。</p>
<p>如果接触过Win32 SDK编程的知道一个标准Windows窗体的产生过程：</p>
<pre>
设计窗口类
注册窗口类
创建窗口
显示窗口
启动消息循环泵循环获取消息分发到窗体过程函数处理
</pre>
<p>贴上一个标准Windows窗体的产生代码：</p>
<pre>
#include &lt;windows.h>
 
LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
 
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
    static TCHAR szAppName[] = TEXT ("窗口类名称");
    HWND         hwnd;
    MSG          msg;
    WNDCLASSEX   wndclassex = {0};
 
	//设计窗口类
    wndclassex.cbSize        = sizeof(WNDCLASSEX);
    wndclassex.style         = CS_HREDRAW | CS_VREDRAW;
    wndclassex.lpfnWndProc   = WndProc;
    wndclassex.cbClsExtra    = 0;
    wndclassex.cbWndExtra    = 0;
    wndclassex.hInstance     = hInstance;
    wndclassex.hIcon         = LoadIcon (NULL, IDI_APPLICATION);
    wndclassex.hCursor       = LoadCursor (NULL, IDC_ARROW);
    wndclassex.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wndclassex.lpszMenuName  = NULL;
    wndclassex.lpszClassName = szAppName;
    wndclassex.hIconSm       = wndclassex.hIcon;
	
	//注册窗口类
    if (!RegisterClassEx (&wndclassex))
    {
        MessageBox (NULL, TEXT ("RegisterClassEx failed!"), szAppName, MB_ICONERROR);
        return 0;
    }
 
	//产生窗口
    hwnd = CreateWindowEx (WS_EX_OVERLAPPEDWINDOW, 
		                   szAppName, 
        		           TEXT ("窗口名称"),
                		   WS_OVERLAPPEDWINDOW,
		                   CW_USEDEFAULT, 
        		           CW_USEDEFAULT, 
                		   CW_USEDEFAULT, 
		                   CW_USEDEFAULT, 
        		           NULL, 
                		   NULL, 
		                   hInstance,
        		           NULL); 
			
	//显示窗口
    ShowWindow (hwnd, iCmdShow);
    UpdateWindow (hwnd);
	
	//启动消息循环泵循环获取消息分配到窗体过程函数处理
    while (GetMessage (&msg, NULL, 0, 0))
    {
        TranslateMessage (&msg);
        DispatchMessage (&msg);
    }
 
    return msg.wParam;
}
 
//窗体过程函数
LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
 
    switch (message)
    {
    case WM_CREATE:
        return (0);
		
    case WM_PAINT:
        hdc = BeginPaint (hwnd, &ps);
        EndPaint (hwnd, &ps);
        return (0);
		
    case WM_DESTROY:
        PostQuitMessage (0);
        return (0);
    }
 
    return DefWindowProc (hwnd, message, wParam, lParam);
}
</pre>
<p>需要明白的是，所有Windows的窗体及控件归根结底都是使用CreateWindow或CreateWindowEx来创建的，他们都需要标准Windows窗体的产生过程。</p>
<h4>5 对话框及控件的产生和消息分派处理流程</h4>
<p>普通的窗体好理解，主要需要弄清楚是对话框及控件的产生和消息分派处理流程。</p>
<p>对话框及其子控件的管理依靠Windows内建的对话框管理器，对话框管理器的工作包括：</p>
<p>5.1 根据我们在资源设计器中设计的对话框及子控件产生的.rc文件来自动生成对话框和子控件(如果有手动编写.rc文件的经历的话，知道编写RC文件其实就是指定窗口和子控件大小、类型、样式等参数，对话框管理器将这些参数传入CreateWindow函数产生窗体)</p>
<p>5.2 模态对话框直接显示窗体，非模态对话框消息指明WS_VISIBLE属性的话，需要调用ShowWindow来显示窗体。</p>
<p>5.3 维护一个消息循环泵，对于模态对话框来说这个消息泵的消息不经过父窗口，所以表现为模态；对于非模态对话框这个消息泵消息经过主窗口，必须由主窗口传给非模态对话框，表现为非模态。</p>
<p>5.4 维护一个内建的窗体过程函数，对于对话框来说会处理对话框的关闭打开及子窗口的焦点、tab等，对于子控件也是一样，每个子控件会有自己类型的窗体过程函数，窗体过程函数处理子控件的获得或失去焦点、按下或弹起、创建等表现样式和行为。</p>
<p>对于对话框来说，他会开放一个对话框过程函数，让部分消息先通过对话框管理函数处理，如果对话框过程函数不处理才交给默认的内建过程函数处理，对于子控件来说，他们并没有开放过程函数，而是由内建窗体函数将要处理的消息发给父窗口处理。</p>
<p>那么对话框管理器完成了标准Windows窗体的产生中后半部分工作，至于设计窗口类和注册窗口类这是由Windows自己预先做好了的，如常见的“button”、“listbox”、“edit”类等等。</p>
<h4>6 动态创建控件、控件重绘、控件子类化原理</h4>
<p>那么既然所有的窗体(包括对话框和控件)产生过程一样，那么我们就可以将对话框管理器的部分工作替换掉：</p>
<p>6.1 不使用对话框读取.rc模板的方式，直接将参数传递给CreateWindow函数来创建对话框和控件，这就是常见的动态创建控件原理。</p>
<p>6.2 设置控件自绘制如BS_OWNDRAW属性，开放控件的WM_DRAWITEM消息给父窗口，由父窗口来绘制按钮样式，这就是常见的控件重绘原理。</p>
<p>6.3 替换内建的窗体函数，将消息传到自定义的窗体过程函数处理，这就是常见的控件子类化原理。</p>
<p>需要Windows操作系统和开发工具的小伙伴，可以点击下方了解更多免费领取噢~</p>
<p>下一节讲：MFC对话框原理</p>


<p style='float:right;'>本页共133段，5099个字符，8922 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
