<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>

<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}

function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}

#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}


#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{


padding-bottom:5px;
}

h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:5px;
	margin-left:2em;
	background-color:RGB(240,240,240);
    color:blue;
	margin-left:2em;
	}
</style>

</head>

<body>
<div id="container">







<div class='layout'><p>0/1 Knapsack using Branch and Bound</p><p>0</p></div>
<div class='layout'><p>Branch and bound is an algorithm design paradigm which is generally used for solving combinatorial optimization problems. These problems typically exponential in terms of time complexity and may require exploring all possible permutations in worst case. Branch and Bound solve these problems relatively quickly.</p><p>分枝定界是一种常用于求解组合优化问题的算法设计范式。这些问题的时间复杂度通常是指数级的，在最坏的情况下可能需要研究所有可能的排列。分支定界可以较快地解决这些问题。</p></div>
<div class='layout'><p>Let us consider below 0/1 Knapsack problem to understand Branch and Bound.</p><p>下面让我们考虑0/1背包问题来理解分枝定界。</p></div>
<div class='layout'><p>Given two integer arrays val[0…n-1] and wt[0…n-1] that represent values and weights associated with n items respectively. Find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to Knapsack capacity W.</p><p>给定两个整数数组val[0…n-1]和wt[0…n-1]，分别表示与n个项相关联的值和权重。找出val[]的最大值子集，使该子集的权重之和小于或等于背包容量W。</p></div>
<div class='layout'><p>Let us explore all approaches for this problem.</p><p>让我们探讨解决这个问题的所有方法。</p></div>


<div class='layout'><p>1. A Greedy approach is to pick the items in decreasing order of value per unit weight. The Greedy approach works only for fractional knapsack problem and may not produce correct result for 0/1 knapsack.</p><p>1 一种贪婪的方法是按每单位重量值的降序选取项目。贪心方法只适用于分数背包问题，对于0/1背包问题可能无法得到正确的结果。</p></div>

<div class='layout'><p></p><p>0/1背包问题：我们有一堆物品S={a1,a2,…,an}，每个物品ai都有一个重量wi和一个价值vi。现在有一个背包，这个背包的容量为W，现在要将这些物品在不超越背包容量的情况下选择性的放入背包，使得背包里面物品的价值最大，物品不能只选取其中一部份，必须选择全部，或不选！（放与不放到背包里，采用二进制表示，1表示放入背包，0表示不放入背包。）</p></div>

<div class='layout'><p></p><p>分数背包问题：这个问题和上面的问题比较类似，唯一不同的就是该问题里面的物品可以进行分割，便可以只选取1个物品ai的一部份。</p></div>

<div class='layout'><p>2. We can use Dynamic Programming (DP) for 0/1 Knapsack problem. In DP, we use a 2D table of size n * W. The DP Solution doesn’t work if item weights are not integers.</p>

<p>2 我们可以用动态规划（DP）求解0/1背包问题。在DP中，我们使用大小为n * w的2D表。如果项目权重不是整数，DP解决方案就不起作用。</p></div>
<div class='layout'><p>3. Since DP solution doesn’t alway work, a solution is to use Brute Force. With n items, there are 2^n solutions to be generated, check each to see if they satisfy the constraint, save maximum solution that satisfies constraint. This solution can be expressed as tree.</p><p>3 由于DP解决方案并不总是有效的，一个解决方案是使用暴力。对于n个项目，将生成2^n个解，检查每个解是否满足约束，保存满足约束的最大解。这个解可以表示为树。</p></div>
<p><img src="1.jpg" /></p>
<p></p>

<pre>
#include &lt;iostream>
#include &lt;algorithm>
#include &lt;vector>
#include &lt;cmath>

struct Item //物品定义
{
    int id; //编号，重量，价值。编号为0的物品这里没有使用
    double weight, value;
    Item(){}
    Item(int i, double w, double v) :id(i), weight(w), value(v){}
};
const int C=10;   // C背包所能承受的最大重量
const int n=5;    // 物品个数n

std::vector&lt;Item> allItems;      // 所有的物品
std::vector&lt;Item> selectedItems; // 装入背包的物品
double maxValue=0;               // 能够装入背包的最大价值

void Result(int solution) {
    selectedItems.clear();
    for(int i = 0; i &lt; n; i++) {
        if (solution & 1)
            selectedItems.push_back(allItems[i]);
        solution &gt;&gt;= 1;
    }
}

int KnapsackProblem_BruteForce() 
{
    int allCase =  static_cast&lt;int>(pow(2, n));
    maxValue = 0;
    for (int i = 0; i &lt; allCase; i++) 
    {
        int currentCase = i;
        double currentWeight = 0, currentValue = 0;
        for (int j = 0; j &lt; n ; j++) // 将所有二进制是1,所代表物品的重量和价值各自计算累加和
        {
            if (currentCase & 1)     // 二进制位等于1，则物体放进背包，0不放
            {
                currentWeight += allItems[j].weight;
                currentValue  += allItems[j].value;
            }
            if (currentWeight > C)   // 如果已经超重了就不需要继续加了
                break;
            currentCase = currentCase &gt;&gt;1;  //计算完移除一个
        }
        if (currentWeight &lt;= C && currentValue > maxValue) 
        {
            maxValue = currentValue;
            Result(i);
        }
    }
    return maxValue;
}

int main()
{ 
    allItems.push_back(Item(1, 2, 40));
    allItems.push_back(Item(2, 3.14, 50));
    allItems.push_back(Item(3, 1.98, 100));
    allItems.push_back(Item(4, 5, 95));
    allItems.push_back(Item(5, 3, 30));
    
    KnapsackProblem_BruteForce();
    for (size_t i = 0; i &lt; selectedItems.size(); i++)
        std::cout &lt;&lt; "物品编号：" &lt;&lt; selectedItems[i].id 
        &lt;&lt; " 重量：" &lt;&lt; selectedItems[i].weight
        &lt;&lt; " 价值：" &lt;&lt; selectedItems[i].value &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "背包最大价值：" &lt;&lt; maxValue;
    while(1);
    return 0;
}
/*
物品编号：1 重量：2 价值：40
物品编号：3 重量：1.98 价值：100
物品编号：4 重量：5 价值：95
背包最大价值：235
*/
</pre>

<div class='layout'><p>We can use Backtracking to optimize the Brute Force solution. In the tree representation, we can do DFS of tree. If we reach a point where a solution no longer is feasible, there is no need to continue exploring. In the given example, backtracking would be much more effective if we had even more items or a smaller knapsack capacity.</p><p>我们可以使用回溯来优化暴力解决方案。在树表示中，我们可以做树的DFS。如果我们到了一个解决方案不再可行的地步，就没有必要继续探索。在给定的例子中，如果我们有更多的物品或更小的背包容量，回溯将更加有效。</p></div>
<p><img src="2.jpg" /></p>
<div class='layout'><p>The backtracking based solution works better than brute force by ignoring infeasible solutions. We can do better (than backtracking) if we know a bound on best possible solution subtree rooted with every node. If the best in subtree is worse than current best, we can simply ignore this node and its subtrees. So we compute bound (best solution) for every node and compare the bound with current best solution before exploring the node.</p><p>基于回溯的解决方案通过忽略不可行的解决方案比暴力解决方案效果更好。如果我们知道每个节点根上的最佳可能解子树的界，我们可以做得更好（比回溯）。如果子树中的最佳值比当前最佳值差，我们可以忽略此节点及其子树。因此，我们计算每个节点的边界（最佳解），并在探索节点之前将边界与当前最佳解进行比较。</p></div>


<div class='layout'><p>
<p></p>

<pre>
void Backtracking()
{
    If you are already at a solution, report success.
    for ( every possible choice in the current position )
    {
        1 Make that choice and take one step along the path.
        2 Use recursion to solve the problem from the new position.
        3 If the recursive call succeeds, report the success to the next higher level.
        4 If not, back out of the current choice to restore the previous state.
    }
    Report failure.
}
</pre>

</p><p>

</p></div>
<div class='layout'><p>Example bounds used in below diagram are, A down can give $315, B down can $275, C down can $225, D down can $125 and E down can $30. </p><p>下图中使用的示例边界是，A向下可以给出315美元，B向下可以给出275美元，C向下可以给出225美元，D向下可以给出125美元，E向下可以给出30美元。</p></div>

<p><img src="3.jpg" /></p>
<div class='layout'><p>Branch and bound is very useful technique for searching a solution but in worst case, we need to fully calculate the entire tree. At best, we only need to fully calculate one path through the tree and prune the rest of it.</p><p>分枝定界是搜索解的一种非常有用的技术，但在最坏的情况下，我们需要完全计算整个树。充其量，我们只需要完全计算通过树的一条路径，然后修剪其余的路径。</p></div>
<div class='layout'><p>Source:</p><p>资料来源：</p></div>
<div class='layout'><p>Above images and content is adopted from following <a href="http://www.cse.msu.edu/~torng/Classes/Archives/cse830.03fall/Lectures/Lecture11.ppt">nice link</a>. </p><p>上面的图片和内容是通过下面的<a href="http://www.cse.msu.edu/~torng/Classes/Archives/cse830.03fall/Lectures/Lecture11.ppt">链接</a>
</p></div>

<div class='layout'><p></p><p>01背包属于找最优解问题，用回溯法需要构造解的子集树。对于每一个物品i，对于该物品只有选与不选2个决策，总共有n个物品，可以顺序依次考虑每个物品，这样就形成了一棵解空间树：基本思想就是遍历这棵树，以枚举所有情况，最后进行判断，如果重量不超过背包容量，且价值最大的话，该方案就是最后的答案。</p></div>
<div class='layout'><p></p><p>在搜索状态空间树时，只要左子节点是可一个可行结点，搜索就进入其左子树。对于右子树时，先计算上界函数，以判断是否将其减去（剪枝）。</p></div>
<div class='layout'><p></p><p>上界函数bound()：当前价值cw+剩余容量可容纳的最大价值<=当前最优价值bestp。　</p></div>
<div class='layout'><p></p><p>为了更好地计算和运用上界函数剪枝，选择先将物品按照其单位重量价值从大到小排序，此后就按照顺序考虑各个物品。</p></div>
<div class='layout'><p></p><p>利用回溯法试设计一个算法求出0-1背包问题的解，也就是求出一个解向量ｘi （即对n个物品放或不放的一种的方案）</p></div>
<div class='layout'><p></p><p>其中， (ｘi = 0 或１，ｘi = 0表示物体ｉ不放入背包，ｘi ＝1表示把物体ｉ放入背包）。</p></div>
<div class='layout'><p></p><p>在递归函数Backtrack中，当i>n时，算法搜索至叶子结点，得到一个新的物品装包方案。此时算法适时更新当前的最优价值。</p></div>
<div class='layout'><p></p><p>当i&lt;n时，当前扩展结点位于排列树的第（i-1）层，此时算法选择下一个要安排的物品，以深度优先方式递归的对相应的子树进行搜索，对不满足上界约束的结点，则剪去相应的子树。</p></div>

<p>回溯法求01背包问题：</p>

<div class='layout'><p></p><p>① 用约束函数在扩展结点处剪除不满足约束的子树； </p></div>
<div class='layout'><p></p><p>② 用限界函数剪去得不到问题解或最优解的子树。</p></div>


<pre>

#include &lt;iostream>
#include &lt;stdio.h>
using namespace std;

int n;          //物品数量
double c;       //背包容量
double v[100];  //各个物品的价值　value
double w[100];  //各个物品的重量　weight
double cw = 0.0;//当前背包重量　current weight
double cp = 0.0;//当前背包中物品总价值　current value
double bestp = 0.0; //当前最优价值best price
double perp[100];   //单位物品价值(排序后) per price
int order[100];     //物品编号
int put[100];//设置是否装入，为1的时候表示选择该组数据装入，为0的表示不选择该组数据
 
 
//按单位价值排序
void knapsack()
{
    int i,j;
    int temporder = 0;
    double temp = 0.0;
 
    for(i=1;i&lt;=n;i++)
        perp[i]=v[i]/w[i];      //计算单位价值（单位重量的物品价值）
    for(i=1;i&lt;=n-1;i++)
    {
        for(j=i+1;j&lt;=n;j++)
            if(perp[i]&lt;perp[j]) //冒泡排序perp[],order[],sortv[],sortw[]
        {
            temp = perp[i];     //冒泡对perp[]排序
            perp[i]=perp[j];
            perp[j]=temp;
 
            temporder=order[i]; //冒泡对order[]排序
            order[i]=order[j];
            order[j]=temporder;
 
            temp = v[i];        //冒泡对v[]排序
            v[i]=v[j];
            v[j]=temp;
 
            temp=w[i];          //冒泡对w[]排序
            w[i]=w[j];
            w[j]=temp;
        }
    }
}
 
void backtrack(int i)       //回溯函数
{   //i用来指示到达的层数（第几步，从0开始），同时也指示当前选择玩了几个物品
    double bound(int i);
    if(i>n) //递归结束的判定条件
    {
        bestp = cp;
        return;
    }
    //如若左子节点可行，则直接搜索左子树;
    //对于右子树，先计算上界函数，以判断是否将其减去
    if(cw+w[i]&lt;=c)//将物品i放入背包,搜索左子树
    {
        cw+=w[i];//同步更新当前背包的重量
        cp+=v[i];//同步更新当前背包的总价值
        put[i]=1;
        backtrack(i+1);//深度搜索进入下一层
        cw-=w[i];//回溯复原
        cp-=v[i];//回溯复原
    }
    if(bound(i+1)>bestp)//如若符合条件则搜索右子树
        backtrack(i+1);
}
 
//计算上界函数，功能为剪枝
double bound(int i)
{   //判断当前背包的总价值cp＋剩余容量可容纳的最大价值&lt;=当前最优价值
    double leftw= c-cw; //剩余背包容量
    double b = cp;      //记录当前背包的总价值cp,最后求上界
    //以物品单位重量价值递减次序装入物品
    while(i&lt;=n && w[i]&lt;=leftw)
    {
        leftw-=w[i];
        b+=v[i];
        i++;
    }
    //装满背包
    if(i&lt;=n)
        b+=v[i]/w[i]*leftw;
    return b;//返回计算出的上界
 
}
 
int main()
{
    int i;
    printf("请输入物品的数量和背包的容量：");
    scanf("%d %lf",&n,&c);
    /*printf("请输入物品的重量和价值：\n");
    for(i=1;i&lt;=n;i++)
    {
        printf("第%d个物品的重量：",i);
        scanf("%lf",&w[i]);
        printf("第%d个物品的价值是：",i);
        scanf("%lf",&v[i]);
        order[i]=i;
    }*/
    printf("请依次输入%d个物品的重量:\n",n);
    for(i=1;i&lt;=n;i++){
        scanf("%lf",&w[i]);
        order[i]=i;
    }
 
    printf("请依次输入%d个物品的价值:\n",n);
    for(i=1;i&lt;=n;i++){
        scanf("%lf",&v[i]);
    }
 
    knapsack();
    backtrack(1);
 
    printf("最优价值为：%lf\n",bestp);
    printf("需要装入的物品编号是：");
    for(i=1;i&lt;=n;i++)
    {
        if(put[i]==1)
            printf("%d ",order[i]);
    }
    while(1);
    return 0;
}
/*
5
10
2
3.14
1.98
5
3
40
50
100
95
30  
*/

/*
请输入物品的数量和背包的容量：5
10
请依次输入5个物品的重量:
2
3.14
1.98
5
3
请依次输入5个物品的价值:
40
50
100
95
30
最优价值为：235.000000
需要装入的物品编号是：3 1 4

*/

</pre>























</div> <!--container-->

<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>


<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}


</script>
</div>

</body>
</html>
<!--
_____________________________________________________________________________________

1 段落替换：
\s*<br />\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])
------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
\s*</p>\s*
\s*<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________

4 把第和章两个字去掉
第(\S*)章
------------------
$1
_____________________________________________________________________________________

7 正则表达式参考：
https://www.toutiao.com/i6370960744082571778/
_____________________________________________________________________________________

8
<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
-->
