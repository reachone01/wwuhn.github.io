<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>Python内存管理机制</h3>

<p>任何编程语言都会有一个内存模型，以便管理为变量分配的内存空间。不同的编程语言，如C、C++、Java、C#，Python，它们的内存模型都是不相同的，本文将以现在最流行的Python语言为例，来说明动态类型语言的内存管理方式。</p>
<p>1. 重复使用内存空间</p>
<p>赋值语句是Python语言中最简单的语句之一，虽然赋值语言很简单，但却内含玄机。</p>
<p>例如，将一个值赋给一个变量是最常见的赋值操作。</p>
<p>n = 1 # 将1赋给变量n</p>
<p>整数1是一个值，而n是一个对象。这是最简单不过的赋值语句了。那么在内存中是如何操作的呢？其实在Python中，任何值都可以看做是一个对象，例如，1是int类的实例，True是bool类的实例。所以将1赋给变量n，其实是n指向了int类型的对象，所以n本质上就是一个对象的引用。</p>
<p>Python作为动态语言，采用了引用与对象分离的策略，这也使得任何引用都可以指向任何对象，而且可以动态改变引用指向的对象类型，也就是说，可以将一个指向int类型的对象的引用重新指向bool类型的对象。所以可以将Python语言的对象模型看做是超市里的储物柜（这里只是用储物柜作为内存模型的比喻，不要与超市储物柜实际的操作进行比较）。</p>
<p>每一个小柜子相当于一块内存区域，这块内存区域保存了不同类型的值。对于像C++、Java一样的静态语言，一旦分配了某一个小柜子，就意味着这个柜子只能保存特定的物品，如只能放鞋子、只能放手套、只能放衣服。而对于打开小柜子的钥匙（相当于变量），同时也只能打开某一个特定的小柜子，相当于一个变量同时只能指向一个对象一样。当然，在钥匙上进行设置后，该钥匙可以指向其他同类型的小柜子（相当于改变变量指向的对象，如将一个指向int类型对象的变量指向了另外一个int类型的对象）。</p>
<p>不过Python语言就不一样了。在Python版的储物柜中，每一个小柜子并不限定存储物品的类型，而一把钥匙经过设置后，可以打开任意一个小柜子（相当于任意改变变量指向的对象）。这样做的好处是更灵活，没必要为存储特定的物品，增加新的储物柜，只要还有空的小柜子，就可以放任何物品。但缺点也很明显，就是打开一个小柜子后，需要多进行一步判断的操作，判断这个小柜子到底是存储的什么物品。</p>
<p>当然，对于同一个特定的小柜子，可能会配有多把钥匙，这些钥匙都可以打开这个特定的小柜子，这就相当于多个变量指向同一个对象。例如，</p>
<p>x = 10</p>
<p>y = 10</p>
<p>z = 10</p>
<p>x、y和z三个变量的值都是10，这个10就相当于要保存在小柜子中的物品。x、y和z相当于3把钥匙。而3个变量中的值都是10，所以被认为是同一个值（物品），因此，就只需要动用一个小柜子保存10，而3个变量都会指向这个小柜子（由于计算机中值具有无限可复制性，所以只要有一个物品，就可以无限复制，所以不必考虑现实中将小柜子中的东西拿走了就为空的情况）。所以其实x、y和z这3个变量指向了同一个内存地址（相当于小柜子的序号）。可以用id函数验证这3个变量的内存地址是否相同，代码如下：</p>
<p>print(id(x))</p>
<p>print(id(y))</p>
<p>print(id(z))</p>
<p>输出结果如下：</p>
<p>4470531424</p>
<p>4470531424</p>
<p>4470531424</p>
<p>也可以用下面的代码将内存地址转换为十六进制形式。</p>
<p>print(hex(id(x)))</p>
<p>print(hex(id(y)))</p>
<p>print(hex(id(z)))</p>
<p>输出结果如下：</p>
<p>0x10a76e560</p>
<p>0x10a76e560</p>
<p>0x10a76e560</p>
<p>根据前面的输出结果，很显然，x、y和z指向的是同一个内存地址。读者可以将10换成其他的对象，如True、10.12、"hello world"，结果都是一样（由于机器不同，输出的内存地址可能不同，但3个变量的内存地址肯定都是相同的）。</p>
<p>也可以用is运算符判断这3个变量是否指向同一个值。</p>
<p>print(x is y is z) # 输出结果：True</p>
<p>但要注意，只有不可变类型，如int、float、bool、string等，才会使用同一个储物柜。如果是可变类型，如列表、对象，每次都会分配新的内存空间。这里的不可变是指值一旦确定，值本身无法修改。例如int类型的10，这个10是固定的，不能修改，如果修改成11，那么就是新的值了，需要申请新的小柜子。而列表，如空列表[]，以后还可以向空列表中添加任何类型的值，也可以修改和删除列表中的值。所以没有办法为所有的空列表分配同一个小柜子，因为有的空列表，现在是空，以后不一定是空。所以每一个列表类型的值都会新分配一个小柜子，但元组就不同了，由于元组是只读的，所以一开始是空的元组，那么这个元组今生今世将永远是空，所以可以为所有的空元组，以及所有相同元素个数和值的元组分配同一个小柜子。看下面代码：</p>
<p>class MyClass:</p>
<p>    pass</p>
<p>a = []</p>
<p>b = []</p>
<p>c = MyClass()</p>
<p>d = MyClass()</p>
<p>t1 = (1,2,3)</p>
<p>t2 = (1,2,3)</p>
<p>print(a is b)  # False    元素个数和类型相同的列表不会使用同一个内存空间（小柜子）</p>
<p>print(c is d)  # False     MyClass类的不同实例不会使用同一个内存空间（小柜子）</p>
<p>print(t1 is t2) # True   元素个数和类型相同的元组会使用同一个内存空间（小柜子）</p>
<p>这种将相同，但不可变的值保存在同一个内存空间的方式也称为值的缓存，这样做非常节省内存空间，而且程序的执行效率更高。因为省去了大量分配内存空间的时间。</p>
<p>2. 引用计数器</p>
<p>在Python语言中是无法自己释放变量内存的，所以Python虚拟机提供了自动回收内存的机制，那么Python虚拟机是如何知道哪一个变量占用的内存可以被回收呢？通常的做法是为每一块被占用的内存设置一个引用计数器，如果该内存块没有被任何变量引用（也就是引用计数器为0），那么该内存块就可以被释放，否则无法被释放。</p>
<p>在sys模块中有一个getrefcount函数，可以用来获取任何变量指向的内存块的引用计数器当前的值。用法如下：</p>
<p>from sys import getrefcount</p>
<p>a = [1, 2, 3]</p>
<p>print(getrefcount(a))   # 输出2</p>
<p>b = a</p>
<p>print(getrefcount(b))  # 输出3</p>
<p>print(getrefcount(a))  # 输出3</p>
<p>x = 1</p>
<p>print(getrefcount(x))  #输出1640</p>
<p>y = 1</p>
<p>print(getrefcount(x))  # 输出1641</p>
<p>print(getrefcount(y))  # 输出1641</p>
<p>要注意，使用getrefcount函数获得引用计数器的值时，实际上会创建一个临时的引用，所以getrefcount函数返回的值会比实际的值多1。而对于具体的值（如本例的1），系统可能在很多地方都引用了该值，所以根据Python版本和当前运行的应用不同，getrefcount函数返回的值是不确定的。</p>
<p>3. 对象引用</p>
<p>像C++这样的编程语言，对象的传递分为值传递和指针传递。如果是值传递，就会将对象中的所有成员属性的值都一起复制，而指针传递，只是复制了对象的内存首地址。不过在Python中，并没有指针的概念。只有一个对象引用。也就是说，Python语言中对象的复制与C++中的对象指针复制是一样的。只是将对象引用计数器加1而已。具体看下面的代码：</p>
<p>from sys import getrefcount</p>
<p># 类的构造方法传入另外一个对象的引用</p>
<p>class MyClass(object):</p>
<p>    def __init__(self, other_obj):</p>
<p>        self.other_obj = other_obj      # 这里的other_obj与后面的data指向了同一块内存地址</p>
<p>data = {'name':'Bill','Age':30}</p>
<p>print(getrefcount(data))  	# 输出2</p>
<p>my = MyClass(data)</p>
<p>print(id(my.other_obj))   # 输出4364264288</p>
<p>print(id(data))  #输出4364264288</p>
<p>print(getrefcount(data))  # 输出3</p>
<p>在Python中，一切都是对象，包括值。如1、2、3、"abcd"等。所以Python会在使用这些值时，先将其保存在一块固定的内存区域，然后将所有赋给这些值的变量指向这块内存区域，同时引用计数器加1。</p>
<p>例如，</p>
<p>a = 1</p>
<p>b = 1</p>
<p>其中a和b指向了同一块内存空间，这两个变量其实都保存了对1的引用。使用id函数查看这两个变量的引用地址是相同的。</p>
<p>4. 循环引用与拓扑图</p>
<p>如果对象引用非常多，就可能会构成非常复杂的拓扑结果。例如，下面代码的引用拓扑关系就非常复杂。估计大多数同学都无法一下子看出这段程序中各个对象的拓扑关系。</p>
<p>class MyClass1:</p>
<p>    def __init__(self, obj):</p>
<p>        self.obj = obj</p>
<p>class MyClass2:</p>
<p>    def __init__(self,obj1,obj2):</p>
<p>        self.obj1 = obj1</p>
<p>        self.obj2 = obj2</p>
<p>data1 = ['hello', 'world']</p>
<p>data2 = [data1, MyClass1(data1),3,dict(data = data1)]</p>
<p>data3 = [data1,data2,MyClass2(data1,data2),MyClass1(MyClass2(data1,data2))]</p>
<p>看不出来也不要紧，可以使用objgraph模块绘制出某个变量与其他变量的拓扑关系，objgraph是第三方模块，需要使用pip install objgraph命令安装，如果机器上安装了多个Python环境，要注意看看pip命令是否属于当前正在使用的Python环境，不要将objgraph安装在其他的Python环境中。</p>
<p>安装完objgraph后，可以使用下面命令看看data3与其他对象的引用关系。</p>
<p>import objgraph</p>
<p>objgraph.show_refs([data3], filename='对象引用关系.png')</p>
<p>show_refs函数会在当前目录下生成一个”对象引用关系.png“的图像文件，如下图所示。</p>
<p>如果对象之间互相引用，有可能会形成循环引用。也就是a引用b，b引用a，见下面的代码。</p>
<p>import objgraph</p>
<p>from sys import getrefcount</p>
<p>a = {}</p>
<p>b = {'data':a}</p>
<p>a['value'] = b</p>
<p>objgraph.show_refs([b], filename='循环引用1.png')</p>
<p>在这段代码中。a和b都是一个字典，b中的一个value引用了a，而a的一个value引用了b，所以产生了一个循环引用。这段代码的引用拓扑图如下：</p>
<p>很明显，这两个字典是循环引用的。</p>
<p>不光是多个对象之间的引用可以产生循环引用，只有一个对象也可以产生循环引用，代码如下：</p>
<p>a = {}</p>
<p>a['value'] = a</p>
<p>a = []</p>
<p>a.append(a)</p>
<p>print(getrefcount(a))</p>
<p>objgraph.show_refs([a], filename='循环引用2.png')</p>
<p>在这段代码中，字典a的一个值是自身，拓扑图如下：</p>
<p>5. 减少引用计数的两种方法</p>
<p>前面一直说让引用计数器增加的方法，那么如何让引用计数器减少呢？通常有如下两种方法：</p>
<p>（1）用del删除某一个引用</p>
<p>（2）将变量指向另外一个引用，或设置为None，也就是引用重定向。</p>
<p>（1）用del删除某一个引用</p>
<p>del语句可以删除一个变量对某一个块内存空间的引用，也可以删除集合对象中的某个item，代码如下：</p>
<p>from sys import getrefcount</p>
<p>person = {'name':'Bill','age':40}</p>
<p>person1 = person</p>
<p>print(getrefcount(person1))  # 输出3</p>
<p>del person					# 删除person对字典的引用</p>
<p>print(getrefcount(person1))  # 由于引用少了一个，所以输出为2</p>
<p># print(person)  # 抛出异常		# 被删除的变量相当于重来没定义过，所以这条语句会抛出异常</p>
<p>del person1['age']		# 删除字典中key为age的值对</p>
<p>print(person1)</p>
<p>（2）引用重定向</p>
<p>from sys import getrefcount</p>
<p>value1 = [1,2,3,4]</p>
<p>value2 = value1</p>
<p>value3 = value2</p>
<p>print(getrefcount(value2))   # 输出4</p>
<p>value1 = 20</p>
<p>print(getrefcount(value2))	# 输出3，因为value1重新指向了20</p>
<p>value3 = None</p>
<p>print(getrefcount(value2))	# 输出2，因为value3被设置为None，也就是不指向任何内存空间，相当于空指针</p>
<p>6. 垃圾回收</p>
<p>像Java、JavaScript、Python这样的编程语言，都不允许直接通过代码释放变量占用的内存，虚拟机会自动释放这些内存区域。所以很多程序员就会认为在这些语言中可以放心大胆地申请各种类型的变量，并不用担心变量的释放问题，因为系统会自动替我们完成这些烦人的工作。</p>
<p>没错，这些语言的虚拟机会自动释放一些不需要的内存块，用专业术语描述就是：垃圾回收。 相当于为系统减肥或减负。因为不管你的计算机有多少内存，只要不断创建新的变量，哪怕该变量只占用了1个字节的内存空间，内存也有用完的一天。所以虚拟机会在适当的时候释放掉不需要的内存块。</p>
<p>在前面已经提到过，虚拟机会回收引用计数为0的内存块，因为这些内存块没有任何变量指向他们，所以留着没有任何意义。那么到底虚拟机在什么时候才会回收这些内存块呢？通常来讲，虚拟机会设置一个内存阈值，一旦超过了这个阈值，就会自动启动垃圾回收器来回收不需要的内存空间。对于不同编程语言的这个阈值是不同的。对于Python来说，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。</p>
<p>我们可以通过gc模块的get_threshold()方法，查看该阈值:</p>
<p>import gc</p>
<p>print(gc.get_threshold())</p>
<p>输出的结果为：</p>
<p>(700, 10, 10)</p>
<p>这个700就是这个阈值。后面的两个10是与分代回收相关的阈值，后面会详细介绍。可以使用gc模块中的set_threshold方法设置这个阈值。</p>
<p>由于垃圾回收是一项昂贵的工作，所以如果计算机的内存足够大，可以将这个阈值设置的大一点，这样可以避免垃圾回收器频繁调用。</p>
<p>当然，如果觉得必要，也可以使用下面的代码手工启动垃圾回收器。不过要注意，手工启动垃圾回收器后，垃圾回收器也不一定会立刻启动，通常会在系统空闲时启动垃圾回收器。</p>
<p>gc.collect()</p>
<p>7. 变量不用了要设置为None</p>
<p>有大量内存被占用，是一定要被释放的。但释放这些内存有一个前提条件，就是这个内存块不能有任何变量引用，也就是引用计数器为0。如果有多个变量指向同一个内存块，而且有一些变量已经不再使用了，一个好的习惯是将变量设置为None，或用del删除该变量。</p>
<p>person = {'Name':'Bill'}</p>
<p>value = [1,2,3]</p>
<p>del person</p>
<p>value  = None</p>
<p>当删除person变量，以及将value设置为None后，就不会再有任何变量指向字典和列表了，所以字典和列表占用的内存空间会被释放。</p>
<p>8. 解决循环引用的回收问题</p>
<p>在前面讲了Python GC（垃圾回收器）的一种算法策略，就是引用计数法，这种方法是Python GC采用的主要方法。不过这种策略也有其缺点。下面就看一下引用计数法的优缺点。</p>
<p>优点：简单，实时（一旦为0就会立刻释放内存空间，毫不犹豫）</p>
<p>缺点： 维护性高（简单实时，但是额外占用了一部分资源，虽然逻辑简单，但是麻烦。好比你吃草莓，吃一次洗一下手，而不是吃完洗手。），不能解决循环引用的问题。</p>
<p>那么Python到底是如何解决循环引用释放的问题呢？先看下面的代码。</p>
<p>import objgraph</p>
<p>from sys import getrefcount</p>
<p>a = {}</p>
<p>b = {'data':a}</p>
<p>a['value'] = b</p>
<p>del a</p>
<p>del b</p>
<p>在这段代码中，很明显，a和b互相引用。最后通过del语句删除a和b。由于a和b是循环引用，如果按前面引用计数器的方法，在删除a和b之前，两个字典分别由两个引用（引用计数器为2），一个是自身引用，另一个是a或b中的value引用的自己。如果只是删除了a和b，似乎这两个字典各自还剩一个引用。但其实这两个字典的内存空间已经释放。那么Python是如何做到的呢？</p>
<p>其实Python GC在检测所有引用时，会检测哪些引用之间是循环引用，如果检测到某些变量之间循环引用，例如，a引用b，b引用a，就会在检测a时，将b的引用计数器减1，在检测b时，会将a的引用计数器减1。也就是说，Python GC当发现某些引用是循环引用后，会将这些引用的计数器多减一个1。所以这些循环引用指向的空间仍然会被释放。</p>
<p>分代回收的策略有一个基本假设，就是存活的越久，越可能被经常使用，所以出于信任和效率，对这些“长寿”对象给予特殊照顾，在GC对所有对象进行检测时，就会尽可能少地检测这些“长寿”对象。就是现在有很多企业是免检企业一样，政府出于对这些企业的信任，给这些企业生产出的产品予以免检的特殊优待。</p>
<p>那么Python对什么样的对象会给予哪些特殊照顾呢？Python将对象共分为3代，分别用0、1、2表示。任何新创建的对象是0代，不会给予任何特殊照顾，当某一个0代对象经过若干次垃圾回收后仍然存活，那么就会将这个对象归入1代对象，如果这个1代对象，再经过若干次回收后，仍然存活，就会将该对象归为2代对象。</p>
<p>在前面的描述中，涉及到一个“若干次”回收，那么这个“若干次”是指什么呢？在前面使用get_threshold函数获取阈值时返回了(700,10,10），这个700就是引用计数策略的阈值，而后面的两个10与分代策略有关。第1个10是指第0代对象经过了10次垃圾回收后仍然存在，就会将其归为第1代对象。第2个10是指第1代对象经过了10次垃圾回收后仍然存在，就会将其归为第2代对象。也就是说，GC需要执行100次，才会扫描到第2代对象。当然，也可以通过set_threshold函数来调整这些值。</p>
<p>9. 分代回收</p>
<p>如果是多年的朋友，或一起做了多年的生意，有多年的业务往来，往往会产生一定的信任。通常来讲，合作的时间越长，产生的信任感就会越深。Python GC采用的垃圾回收策略中，也会使用这种信任感作为辅助算法，让GC运行得更有效率。这种策略就是分代（generation）回收。</p>
<p>import gc</p>
<p>gc.set_threshold(600, 5, 6)</p>
<p>总结</p>
<p>本文主要讲了Python如何自动释放内存。主要有如下3种策略：</p>
<p>1. 引用计数策略（为0时释放）</p>
<p>2. 循环引用策略（将相关引用计数器多减1）</p>
<p>3. 分代策略（解决了GC的效率问题）</p>
<p>通过这些策略的共同作用，可以让Python更加有效地管理内存，更进一步地提高Python的性能。</p>


<p style='float:right;'>本页共185段，9509个字符，19750 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
