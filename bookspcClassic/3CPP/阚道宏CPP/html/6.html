<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>

<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //65.29%
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:40em;
	line-height:1.6em;
	//overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.lettle{
	font-size:110%;
	line-height:160%;
	
	padding:0;
	color:#930;
	text-indent:2em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h2{
	font-size:1.2em;
	font-weight:bold;
	margin-top:0px;
	margin-bottom:0px;
	text-indent:0em;
	color:#990000;
	height:1.5em;
}
h3{
	text-indent:0em;
	font-size:1.2em;
	height:1.5em;
	padding:0;
	margin:0;
	color:#990000;
}
h4{
	text-indent:0em;
	font-size:1em;
	height:1.5em;
	padding:0;
	margin:0;
	color:#990000;
}
.title
{
	text-indent:0em; font-weight:bold;
	font-size:120%;
}
pre{
	width:115%;
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	overflow-x: auto;
	}
</style>
</head>
<body>
<div id="container">

﻿<h3>C++ 第六章 面向对象编程（一）</h3>
<p><a href="https://www.jianshu.com/u/7114c4e24754">ref</a> <a href="https://wenku.baidu.com/view/3f26286f73fe910ef12d2af90242a8956aecaa6d.html">2</a></p>
<h4>前言</h4>
<p>程序 =  数据 + 算法</p>
<p>变量是程序中的数据元素，函数是程序中的算法元素</p>
<p>面向对象程序设计将程序中的数据元素和算法元素根据内在关联关系进行分类管理，这就形成了”类“的概念，分类可以更好的管理</p>
<p>类相当于是一种自定义数据类型，用类所定义的变量称为”对象“</p>
<p>基于类编写程序可以更好的组织管理程序代码，也更便于代码重用，在团队分工开发模式中，某些程序员定义类，编写类代码，某些程序员使用类，定义对象，然后通过对象，重用别人的类代码，</p>
<p>本章内容共计7节。</p>
<pre>
前言
一、面向对象程序设计方法
    1.1 封装的概念：
    1.2 类的接口
    1.3 面向对象程序的设计过程
二、类的定义
    2.1 定义类的语法
    2.2 数据成员的语法细则
    2.3 函数成员的语法细则
    2.4 访问权限的语法细则
三、对象的定义和访问
    3.1 类的定义和访问
    3.2 对象指针即指向运算符
    3.3 类与对象的编译原理
四、对象的结构与析构
    4.1 变量在内存中的生存期
    4.2 参与对象的构造和析构的过程
        1、构造函数：
        2、析构函数
        3、拷贝函数中的深拷贝与浅拷贝
    4.3 类和对象编程的主要内容
五、对象的应用
    5.1 对象数组
        1、定义对象数组的语法：
        2、对象数组的访问：
    5.2 对象的动态分配
    5.3 对象在函数中的应用
    5.4 函数间的参数传递
        1、值传递与常对象
        2、引用传递与常引用
        3、指针传递与指向常对象的指针
六、类中的常成员与静态成员
    6.1 常数据成员
    6.2 常函数成员
    6.3 静态数据成员
    6.4 静态函数成员
    6.5 总结
七、类的友元
    7.1 友元函数
    7.2 友元类
</pre>
<h1>一、面向对象程序设计方法</h1>
<p>从结构化设计到面向对象设计</p>
<p>程序设计任务：编写一个计算圆形、长方形面积和周长的C++演示程序，程序由甲乙2位程序员分工协作，共同编写。使用结构化程序设计方法，将程序划分为5个函数。甲负责编写主函数，乙负责编写计算面积、周长的子函数。</p>
<p>采用结构化程序设计：数据分散管理策略</p>
<pre><code class="c++">/* 主函数 */
#include &lt;iostream&gt;
using namespace std;

/* 声明函数原型 */
double Clen(double r);
double Carea(double r);
double Rlen(double x, double y);
double Rarea(double x, double y);

int main()
{
    double r,a,b;
    cout&lt;&lt;"请输入半径：";
    cin&gt;&gt;r;
    cout&lt;&lt;endl;
    cout&lt;&lt;"请输入长宽";
    cin&gt;&gt;a&gt;&gt;b;
    cout&lt;&lt;"圆形的面积为："&lt;&lt;Carea(r)&lt;&lt;"周长为："&lt;&lt;Clen(r)&lt;&lt;endl;
    cout&lt;&lt;"长方形形的面积为："&lt;&lt;Rarea(a,b)&lt;&lt;"长方形的周长为："&lt;&lt;Rlen(a,b)&lt;&lt;endl;    
    return 0;
}
</code></pre>
<pre><code class="c++">/* 子函数 */
double Clen(double r)
{ return (3.14*2*r); }

double Carea(double r)
{ return(3.14*r*r); }

double Rlen(double x, double y)
{ return((x+y)*2); }

double Rarea(double x, double y)
{ return(x*y); }
</code></pre>
<p><strong>采用面向对象程序设计：</strong></p>
<pre><code class="c++">/*主函数*/
#include &lt;iostream&gt;
using namespace std;

/* 声明类 */
class Circle
{
    public:
        double r; //半径，数据成员
        double Carea(); //求面积，函数成员
        double Clen(); //求周长，函数成员
};
class Rectangle
{
    public:
        double a,b; //长宽，数据成员
        double Rarea(); //求面积，函数成员
        double Rlen(); //求周长，函数成员
};

int main()
{
    Circle obj1;//定义圆形类的对象obj.1
    Rectangle obj2;//定义长方形类对象obj2
    
    cout&lt;&lt;"请输入半径：";
    cin&gt;&gt;obj1.r; //获取半径
    cout&lt;&lt;endl;
    cout&lt;&lt;"请输入长宽"; //获取长宽
    cin&gt;&gt;obj2.a&gt;&gt;obj2.b;
    cout&lt;&lt;"圆形的面积为："&lt;&lt;obj1.Carea()&lt;&lt;",周长为："&lt;&lt;obj1.Clen()&lt;&lt;endl;
    cout&lt;&lt;"长方形形的面积为："&lt;&lt;obj2.Rarea()&lt;&lt;",长方形的周长为："&lt;&lt;obj2.Rlen()&lt;&lt;endl;    
    return 0;
}
</code></pre>
<pre><code class="c++">/* 定义类 */
class Circle //圆形类声明
{
    public:
        double r; //半径，数据成员
        double Carea(); //求面积，函数成员
        double Clen(); //求周长，函数成员
};
//圆形类，实现函数成员的具体定义。
double Circle::Carea()
{ return(3.14*r*r); }
double Circle::Clen()
{ return (3.14*2*r); }

class Rectangle
{
    public:
        double a,b;
        double Rarea();
        double Rlen();
};
double Rectangle::Rarea()
{ return(a*b); }
double Rectangle::Rlen()
{ return ((a+b)*2); }
</code></pre>
<p>类代码更便于管理，在大型程序开发中，程序员需要定义大量变量和函数，这时用类来组织代码的优势也更加明显，例如，为了开发Windows应用程序，微软为程序员提供了2000多个函数，这些函数统称为win32 API，如何组织管理这些函数是非常麻烦的问题，甚至为这些函数命名也是一件麻烦事儿，因为这些函数不能重名，可以将这些函数按功能划分为不同的类，不同类中的函数可以重名，即便于组织代码，也便于程序员理解记忆。</p>
<p>使用其他文件中的类，需要先声明再使用，类的声明形式，与定义类时的声明部分相同，可以直接复制过来。声明类的代码同样可以写入头文件当中，以简化代码，在类的实现和使用时，直接使用#include指令包含对应的头文件即可。</p>
<h2>1.1 封装的概念：</h2>
<p>封装是与代码重用相关得一个概念，代码重用是提高软件开发效率得重要手段，也是软件技术不断进步得主要动力，代码重用过程中，程序员有2类角色，一类是提供代码的程序员，一类是使用代码的程序员。可重用的代码相当于是一种程序零件，可提供给不同得程序员组装出不同的产品，提供程序代码的程序员相当于是程序供应商</p>
<ol>
<li><strong>提供代码的程序员</strong></p>
<p>将相对独立、能广泛使用的程序功能提炼出来，编写成函数或类等形式的可重用代码。可重用代码的特点是”一次开发，长期使用“。编写重用代码程序员的性格是”幸苦自己，方便别人“，因此只幸苦一次。该角色设计的程序代码越强大越好，越通用越好，这样才能被更多的人使用。</p>
</li>
<li><strong>使用代码的程序员</strong></p>
<p>站在使用代码的程序员的角度，他希望能够使用别人提供的程序零件，组装自己的程序，这样能够站在更高的起点上，开发功能更强的产品，他希望程序零件能够承担更多的功能，从而降低开发工作量，另外希望使用越方便越好，图省事儿，图方便，例如，头文件就是为了方便程序员声明别人编写的函数或类而引入的语法形式。</p>
</li>
</ol>
<p>c++语言可以将只在内部使用的成员封装起来，以防止它们被误访问，类的封装有2层含义</p>
<ol>
<li><strong>开放</strong></p>
<p>在定义类的时候，将必须被外部访问的成员开放出来，以保证类的功能，可以被正常使用，</p>
</li>
<li><strong>隐藏</strong></p>
<p>在定义类的时候，将必须不需要被外部访问的成员隐藏起来，以防止它们被误访问，被隐藏的成员只在内部使用，能被类里的其他成员访问。但不能被外部其他函数访问，</p>
</li>
</ol>
<p>c++语言中类的封装，是在类定义的时候，为类成员声明不同的访问权限来实现的。访问权限有3种：</p>
<ol>
<li><strong>公有权限（public）</strong></p>
<p>被赋予公用权限的类成员是开发的，称为公有成员</p>
</li>
<li><strong>私有权限（private）</strong></p>
<p>被赋予私有权限的成员将被隐藏，称为私有成员</p>
</li>
<li><strong>保护权限（protected）</strong></p>
<p>被赋予保护权限的成员是半开放的，称为保护成员</p>
</li>
</ol>
<p>访问权限，是编写类的程序员，为控制实用类的程序的使用操作，保障正确访问类成员而设定的，</p>
<h2>1.2 类的接口</h2>
<p>公有成员是封装后类对外的接口，一个类必须有公有成员，否则这个类无法使用</p>
<p>程序员设计类时应根据功能要求合理设定成员权限，一方面要开发用户正常使用所必须的成员，另一方面要尽可能隐藏不需要直接访问的成员。</p>
<h2>1.3 面向对象程序的设计过程</h2>
<p>面向对象的程序设计过程，可以简单的分为3个阶段，分别是：分析、抽象和组装，通常以uml统一建模语言来描述设计结果，并编写出书面的程序设计报告。</p>
<p><strong>类的设计：</strong>将客观事物归纳，划分成不同的类，是人类解决客观事件，常用的方法，分类就是抓住主要特征，忽略次要特征，将具有功能性的事务，划分成一类，分类的过程，是一个不断抽象的过程，面向对象程序设计将分类称为抽象，计算机程序处理任何事务，都是将事务转换成数据模型，对事务的处理，就是对数据的处理。面向对象程序设计，将一个个具体的事物称为对象，对事物进行规划，抽象所划分成的类别，称为类；数据被称为事物的属性，在程序中，用变量存储数据；处理数据的算法，被称为方法，在程序中用函数来描述；同类对象具有相同的属性和方法，这些属性和方法被划分成类的成员，程序员需分析，提炼出类的属性成员和方法成员，并合理设定各成员的访问权限，这就是类的设计。</p>
<p>一个类要提炼几个属性和方法，要根据具体功能来定。<strong>面向对象的分类设计过程是一个自底向上，逐步抽象的过程。从一个个具体的对象，可以抽象出小类，从小类可以抽象出更大的类，越往上类越宽泛、越抽象。</strong>c++语言支持面向对象程序设计，用类的语法形式来描述类图。</p>
<h1>二、类的定义</h1>
<p>定义一个类，就是用c++语言描述该类包含哪些数据成员、函数成员、以及各成员的访问权限</p>
<h2><strong>2.1 定义类的语法</strong></h2>
<pre><code class="c++">/* 类声明（declaration）部分 */
class 类名
{
    public:
        公有成员
    protected:
        保护成员
    private:
        私有成员
};
/* 函数成员的完整定义，类实现（implementation）部分 */
... ...
</code></pre>
<p><strong>详解：</strong></p>
<ul>
<li>class是定义类时的关键字</li>
<li>类名需符合标识符命名规则</li>
<li>类成员有2种，分别是数据成员和函数成员，某些特殊的类可能只有一种成员，比如只包括函数成员，或只包含数据成员</li>
<li>访问权限有3种，分别时public（公有权限）、protected（保护权限）、private（私有权限），不指定访问权限时，默认为private。</li>
<li>类定义代码分为2个部分，类声明部分在大括号中声明数据成员、函数成员，并指定各成员的访问权限，声明数据成员的语法形式类似于定义变量语句，但声明时不能初始化，声明函数成员只是声明其原型，完整的函数定义代码放在大括号外面的类实现部分，定义时需要在函数名前加“类名::”限定，指明该函数属于哪个类。</li>
<li>函数成员可以访问本类中任意位置的数据成员，或调用本类中任意位置的函数成员，类成员之间互相访问不需要“先定义，后访问”，或“先声明，后访问”，也不受权限约束，在类定义代码（包含声明和实现2部分）范围内，任何类成员都可以被本类的其他成员访问，类成员具有类作用域（class scope）</li>
<li>不同类作用域之间的标识符可以重名，即不同类成员之间可以重名。</li>
</ul>
<pre><code class="c++">/* 类声明（declaration）部分 */
class Abc
{
    int d0; 		//不指定访问权限时，默认为private。
    public: 		//公有权限
        int d1;
        double fun1();
    protected: 		//保护权限
        int d2;
        int fun2();
    private:		//私有权限
        double d3;
        void fun3();  
};
/* 函数成员的完整定义，类实现（implementation）部分 */
void Abc::fun3(){ ... ... }
double Abc::fun1(){ ... ... }
int Abc::fun2(){ ... ... }
</code></pre>
<h2>2.2 数据成员的语法细则</h2>
<p>数据成员也称为属性，是类中的变量，用于保存数据；数据成员的类型，可以是基本数类型，也可以是自定义数据类型；不同数据成员之间的类型可以相同，也可以不同。</p>
<p>数据成员不能与其他成员重名，声明数据成员的而语法形式类似于定义变量，所不同的是声明数据成员不能初始化。</p>
<h2>2.3 函数成员的语法细则</h2>
<p>函数成员也称为方法，是类中的函数，其功能通常是对本类中的数据成员进行处理；函数成员可以直接访问本类中的数据成员，数据成员相当于是类中的全局变量，函数成员可以直接调用本类中的其他函数成员。</p>
<p>在类中声明函数成员时，可以指定形参的默认值，即带默认形参值的函数。</p>
<p>不同函数成员之间可以重名，即重载函数，两个函数的形参个数不同，或数据类型不同，那么这两个函数就可以重载，函数成员不能与数据成员重名。</p>
<p>可以将函数成员定义成内联函数，在类实现部分定义函数成员时，可以用“inline”关键字将其定义成内联函数，或者直接将该函数成员定义在类声明部分的打括号里，c++编译器默认将直接定义在类声明部分大括号里的函数成员当做内联函数处理</p>
<h2>2.4 访问权限的语法细则</h2>
<p>每个类成员都有并且只有一种访问权限。定义类时，不同成员可以按任意位置编排，为便于阅读，不同权限成员编排在一起，或将数据成员编排在一起，函数成员编排在一起。</p>
<p>关键字public、protected和private指定了后续成员的访问权限，在类声明中，同一关键字可出现多次，也可以不出现（如果没有访问权限的成员）。通常，一个类需包含公有权限成员，否则该类没有对外接口，无法使用。</p>
<h1>三、对象的定义和访问</h1>
<p>类相当于时程序员自己定义的一种新的数据类型，可称为类类型，使用类通常是用类定义变量，用类定义的变量通常称为该类的对象或实例，使用类，需要先定义，在使用，或先声明再使用</p>
<h2>3.1 类的定义和访问</h2>
<p>定义对象和定义变量的语法形式基本相同。类就是一张图纸，计算机执行定义对象语句就是按照图纸再内存中创建一个程序实例（即对象），计算机会严格按照类定义来创建对象，所创建的对象具有类所规定的：数据成员、函数成员及访问权限。</p>
<p>定义好的对象可以访问，访问对象就是通过接口（即公有成员）操作内存中的对象，实现特定的程序功能，比如读写对象中的公有数据成员，或调用其中的公有函数成员。</p>
<p>对象中的公有成员可以访问，非公有成员（私有成员、保护成员）不能访问，这就是对象成员的访问权限控制</p>
<p>访问对象中的公有成员需要使用成员运算符点“.”，以“对象名.数据成员名”的形式访问对象中的变量，以“对象名.函数成员名(实参列表)”的形式调用对象中的函数。</p>
<h2>3.2 对象指针即指向运算符</h2>
<pre>
<code class="c++">//假设定义了一个类Rectangle，
// 拥有公有数据成员a、b和公有函数成员RArea()、RLen()
Rectangle obj2; //定义一个Rectangle的对象obj2
obj2.a;  
obj2.b;  		//访问对象中的成员 
obj2.RArea();  
obj2.RLen() 

//定义一个对象指针p
Rectangle *p;
p = &amp;obj2;
(*p).a;         //通过对象指针间接访问对象obj2中的公有成员
(*p).b;   		
(*p).RArea();  
(*p).RLen() 
p-&gt;a;        //通过指向运算符间接访问对象obj2中的公有成员
p-&gt;b;  		
p-&gt;RArea();  
p-&gt;RLen() 
</code></pre>
<p>即使通过指针，也只能访问类的公有成员，不能对私有成员和保护成员进行访问。</p>
<h2>3.3 类与对象的编译原理</h2>
<p>源程序中的c++代码，需要编译成等效的机器语言指令，才能被计算机硬件识别和执行，执行类代码的编译，编译时编译器将源程序中的类定义代码编译成等效的机器语言指令，当编译到类中的函数成员时，编译器会对其定义代码做出某些调整，然后再进行编译。编译器会为函数的行参指定一个<strong>指针常变量this（也就是：类名 *const this）</strong>，这个指针是指向本类的指针，并修改所在函数体中，对本类的访问方式，自动在成员名前加<em><em>上“</em> this-&gt;”（也就是：</em>this-&gt;成员名）<strong>的方式间接访问。c++在编译器在编译通过对象访问函数其成员时，会将其修改为直接调用该函数成员，然后将</strong>对象的地址（&amp;对象名）**作为实参，传递给对应的形参（*const this）</p>
<p>其目的是让多个同类对象，公用函数代码，降低内存占用，概念上讲，计算机严格按照类定义创建对象，同类的多个对象，都应该有类定义中规定的数据成员和函数成员。同类的多个对象，都包含各自的数据成员，每个对象所占用的内存空间，都等于类中全部数据成员所需内存空间的总和，但是他们的执行方法也就是函数是一样的，是可以共用的，因此编译器在编译时，通过调整函数成员的定义代码和调用形式，巧妙的实现了执行时，多个同类对象共用同一个函数，内存中只需保存一份函数代码即可。在这个过程中对象指针this扮演了重要角色。在编写函数成员代码时，形参this是隐含的，函数体中访问其他类成员也不需要添加this指针，这些都由编译器在编译时自动添加。</p>
<h1>四、对象的构造与析构</h1>
<h2>4.1 变量在内存中的生存期</h2>
<p>程序执行过程中，变量从内存分配，到释放，这个时间段被称为变量在内存中的生成期，不同类型的变量分配方式不同，在内存中的生成期也不同，全局变量和静态变量是静态分配的，他们在程序被加载后立即分配内存。直到程序执行结束退出时，才被释放，局部变量是自动分配的，在执行到其定义语句时为其分配内存待其所在代码块执行结束，即被释放。动态分配需要程序员使用new和delete运算符，自行决定何时分配及释放。</p>
<p>和变量一样，对象也有<strong>全局对象</strong>、<strong>局部对象</strong>、<strong>静态对象</strong>，也可以动态分配，程序执行时，对象也会经历从分配内存，到释放内存的过程，即对象具有生存期，不同类型的对象内存分配方式不同，在内存中具有不同的生存期，对象的内存分配方式和生成期和变量完全一样。</p>
<p><strong>程序执行过程中：</strong></p>
<ol>
<li>计算机创建对象，为对象分配内存空间，我们称对象在内存中诞生了</li>
<li>当对象生存期结束时，计算机销毁对象，释放其内存空间，我们称为对象死亡了</li>
<li>创建对象的过程称为对象的构造，销毁对象的过程称为对象的析构。</li>
</ol>
<h2>4.2 参与对象的构造和析构的过程</h2>
<p><strong>构造个性化对象：</strong></p>
<ul>
<li>初始化对象</li>
<li>构造时申请额外的内存</li>
</ul>
<p><strong>销毁个性化对象：</strong></p>
<ul>
<li>释放额外申请的内存</li>
</ul>
<h3><strong>1、构造函数：</strong></h3>
<p>c++语言允许程序员在类定义中添加构造函数，参与对象的构造过程，执行定义对象语句时，计算机将自动调用对象所属类的构造函数，实现对象的个性化，构造函数是类中的一种特殊函数成员，定义构造函数时，应当遵守以下几点特殊的语法细则：</p>
<ol>
<li>构造函数名必须与类名相同，定义时要在构造函数名前面加上类名的约束，指定是属于哪个类的构造函数，语法为：</p>
<pre><code class="c++">类名::类名(形参列表)
{ 赋值语句块 }
</code></pre>
</li>
<li>构造函数由计算机自动调用，程序员不能调用</li>
<li>构造函数通过形参传递初始值（可指定默认形参值），实现对新建对象数据成员的初始化。</li>
<li>构造函数可以重载，即定义多个同名的构造函数，这样可以提供多种形式的对象构造方法。</li>
<li>构造函数可以定义成内联函数</li>
<li>构造函数没有返回值，定义时不能写函数类型，写void也不行。</li>
<li>构造函数通常是类外调用，其访问权限应设为public或protected，不能设为private</li>
<li>一个类如果没有定义构造函数，编译器在编译时将自动添加一个空的构造函数，称为默认构造函数其形式为：类名( ) { }，函数体中没有任何语句，就是什么也没做，但是从语法形式上，一个类必须由构造函数，</li>
</ol>
<p>构造函数的常见功能主要有：初始化对象、显示对象的构造过程、构造时申请额外内存等</p>
<p><strong>构造函数——初始化对象</strong></p>
<p>在构造函数中给出数据成员的初始值，或初始化的方法，程序执行时，会自动调用构造函数，完成数据成员的初始化功能。</p>
<p>代码实例：</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Student
{
    private:
        char *c_name;//定义为字符型指针变量，用于接收字符串传递的地址
        int c_ID;
        int c_age;
        double c_score;
    public:
        void print();
        Student(char *name, int ID, int age, double score);
};

Student::Student(char *name, int ID, int age, double score)
//char name[]形参用于接收实参传递过来的数组，实际是一个指针，必须定义接收字符串宽度
{
    c_name= name; //此处赋值，相当于是将实参的内存首地址赋值给了私有成员中的char* name指针变量    
	c_ID = ID;
    c_age = age;
    c_score = score;
}

void Student::print()
{
    cout&lt;&lt;"姓名："&lt;&lt;c_name&lt;&lt;endl;
	//因c++对字符串处理的特殊机制，读取指针变量的地址，实际输出为这个字符串。
	// 要读取实际的地址的值时，需要强制转换指针类型
    cout&lt;&lt;"ID:"&lt;&lt;c_ID&lt;&lt;endl;
    cout&lt;&lt;"年龄:"&lt;&lt;c_age&lt;&lt;endl;
    cout&lt;&lt;"成绩:"&lt;&lt;c_score&lt;&lt;endl;
  }
int main()
{
    char name[]= "zhangsan";  //对字符串数组name进行赋值
    /*
    此时实参变量名name相当于是字符串name的首地址。
    如果直接写入字符串，而不是变量名，c++会将实参字符串看作是字符串常量    
	因为构造函数中，c++将char name[] 自动编译为一个指针，也就是char* name[]，
	无法将一个字符串常量负值给一个字符型指针。故而报错
    */
    Student stu(name, 8, 12, 89); //不能在实参name的位置写字符串，会报错。只能间接传递
    stu.print();
    return 0;
}
</code></pre>
<p>当构造函数中定义有重载函数时，及两个名称一样，但是形参不一样，或形参数量不一样的时候，c++将根据形参匹配的原则，也就是形实结合，自动调用形参和实参相匹配的构造函数。代码实例：</p>
<pre><code class="c++">class Circle
{
    private:
        double r;
    public:
        double area();
        //将构造函数定义为2个重载函数，其中一个带形参。一个不带
        Circle(double r);
        Circle();
};//定义方法成员double Circle::area() return(3.14*r*r)//定义重载构造函数，对变量r进行初始化
Circle::Circle(double r) {Circle::r = r}Circle::Circle() {Circle::r = 0 }

int main()
{
    Circle carea(5.3); //此时调用构造函数Circle(double r);
    Circle carea();//此时调用构造函数Circle();
    return 0;
}
</code></pre>
<p>类似于上述例子中的两个重载函数，可以写成带默认新参值的构造函数，将两个构造函数合二为一，简化代码。如下所示：</p>
<pre><code class="c++">Circle::Circle(double r = 0){ r = x };
</code></pre>
<p><strong>构造函数——用一个已经存在的对象，初始化新对象</strong>：</p>
<p>这种方式又称为<strong>拷贝构造函数</strong>，例如上述例子中的圆形类Circle，重新定义一个新的构造函数，并引用已经定义好的对象实例carea。</p>
<pre><code class="c++">Circle::Circle(Circle &amp;carea)//&amp;carea是一个本类对象的引用
{ r = carea.r }
</code></pre>
<p>拷贝构造函数接收一个已经存在的本类对象的引用，将该对象的数据成员一一对应，拷贝给新的对象的数据成员。实现一个用已经存在的对象，初始化新对象的功能。完整实例代码如下：</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Circle
{
    private:
        double R; //私有成员R，无法直接外部访问赋值
    public:
        double area();
        //声明构造函数，两个构造函数为重载函数，第二为拷贝构造函数。
        Circle(double r);
        Circle(Circle &amp;);
};
//定义方法成员
double Circle::area(){return(3.14*R*R);} 
//定义重载构造函数，对变量r进行初始化
Circle::Circle(double r=0 ) { R = r;}
//定义拷贝构造函数
Circle::Circle(Circle &amp;carea) { R = carea.R;
}

int main(){
    Circle carea1(5.3);   	// 此时调用构造函数Circle(double r);
    Circle carea2(carea1);	// 此时调用拷贝构造函数Circle(Circle &amp;);
			        // 利用已经存在的对象carea初始化carea2
    cout&lt;&lt;carea2.area();
    return 0;
}
</code></pre>
<p>可以看出，每添加一个构造函数，就为定义该类对象，增加了一种初始化形式，如果没有为类定义拷贝构造函数，则编译器在编译时，将自动添加一个默认拷贝构造函数，其功能，就是将实参对象的数据成员，一一对应，拷贝给新建的对象的数据成员。</p>
<p><strong>构造函数——显示对象的构造过程</strong>：</p>
<p>可以在构造函数的函数体中插入一些cout指令，这样可以让程序员在程序调试过程中实时观测到对象的构造过程，便于检查程序代码中的错误。实例如下：</p>
<pre><code class="c++">//定义重载构造函数
Circle::Circle()
{R=0; cout&lt;&lt;"Circle()called."&lt;&lt;endl;}

Circle::Circle(double x)
{R=x; cout&lt;&lt;"Circle(double x)called."&lt;&lt;endl;}

Circle::Circle(Circle &amp;carea)
{r=carea.R; cout&lt;&lt;"Circle(Circle &amp;carea)called."&lt;&lt;endl;}

Circle obj;// 显示信息：Circle()called.
</code></pre>
<p><strong>构造函数——构造函数时申请额外内存</strong>：</p>
<p>以学生信息录入为例，定义一个学生数据存储的类Student，该类的数据成员和方法如下所示：</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstring&gt; //使用字符串拷贝函数需包含的文件头，C语言是&lt;string.h&gt;，c++是&lt;cstring&gt;，两者完全一样。
using namespace std;
class Student
{
private:
    char name[10],ID[11];//约束数据成员的字符串长度
    int age; double score;
public:
    void show();
    Student(char *pname, char *pID, int in_age, double in_score)//内联构造函数
    {
        strcpy(name,pname); strcpy(ID,pID);//通过字符串拷贝函数，将形参传递的值，赋值给Student类的数据成员
        age = in_age; score = in_score;
    };
};

void Student::show(){
    cout&lt;&lt;"学生姓名："&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;"学生ID："&lt;&lt;ID&lt;&lt;endl;
    cout&lt;&lt;"学生年龄："&lt;&lt;age&lt;&lt;endl;
    cout&lt;&lt;"学生成绩："&lt;&lt;score&lt;&lt;endl;
}

int main()
{
    char name[]="张三";
    char ID[] = "1400500001";
    Student obj(name,ID,19,95);
    obj.show();
    return 0;
}
</code></pre>
<p>如果要在Student类中增加一个备注信息memo，备注信息可有可无，有长有短，该如何定义呢？可以将备注信息定义为字符型指针char *memo，然后在构造函数中按照实际的备注信息长度来动态分配内存，即申请额外的内存。方法如下：</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
class Student
{
private:
    char name[10],ID[11];
    int age; double score;
    char *memo;
public:
    void show();
    Student(char *pname, char *pID, int in_age, double in_score,char*pmemo)
    {
        strcpy(name,pname); strcpy(ID,pID);
        age = in_age; score = in_score;
        int len = strlen(pmemo);//计算实际传递过来的备注信息的长度
        if(len&lt;=0) memo=0;//如果备注信息为空，则将指针赋值为0，也就是空指针。
        else
        {
            memo = new char[len+1];//按照实际的长度分配内存，加1的原因是字符串末尾结算符有一个\0占位符            strcpy(memo, pmemo);//使用传递过来的备注信息，初始化数据成员。
        }
    };

    ~Student() //析构函数，用于销毁构造函数动态分配的内存
    {
        if(memo!=0) delete []memo;
    };
};
void Student::show()
{
    cout&lt;&lt;"学生姓名："&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;"学生ID："&lt;&lt;ID&lt;&lt;endl;
    cout&lt;&lt;"学生年龄："&lt;&lt;age&lt;&lt;endl;
    cout&lt;&lt;"学生成绩："&lt;&lt;score&lt;&lt;endl;
    cout&lt;&lt;"学生情况："&lt;&lt;memo&lt;&lt;endl;
}

int main()
{
    char name[]="张三";
    char ID[] = "1400500001";
    char memo[] = "成绩优秀";
    Student obj(name,ID,19,95,memo);
    obj.show();
    return 0;
}
</code></pre>
<p>合理使用内存的动态分配技术，可以有效降低内存的使用量，动态分配的内存，需要程序员编写delete语句来释放，在构造函数中动态分配的内存，需要程序员编写<strong>析构函数</strong>，在析构函数中，用delete语句释放。</p>
<h3><strong>2、析构函数</strong></h3>
<p><strong>概念：</strong>当对象生存期结束时，计算机销毁对象，释放其内存空间，这个过程就是对象的析构。</p>
<p>c++语言允许程序员在类定义中添加析构，参与对象的析构过程，计算机在销毁对象时，自动调用该类的析构函数。与构造函数一样，析构函数也是类中的一种特殊函数成员，定义析构函数时，应当遵守以下几点语法细则</p>
<ul>
<li>析构函数名必须为：~类名</li>
<li>析构函数由计算机自动调用，程序员不能直接调用</li>
<li>析构函数没有形参</li>
<li>析构函数没有返回值，定义时不能写函数类型，写void也不行。</li>
<li>一个类只能有一个析构函数，但是构造函数可以有多个，这里存在区别</li>
<li>析构函数通常时类外调用，其访问权限应设为public或protected，不能设为private</li>
<li>一个类如果没有定义析构函数，编译器在编译时，将自动添加一个空的析构函数，称为默认析构函数，其形式为：<code>~类名(){}</code>
</li>
</ul>
<p>析构函数的功能主要有：清理内存；设置与当前对象相关的系统状态等。实例可以参考前文的学生信息类Student。</p>
<h3><strong>3、拷贝函数中的深拷贝与浅拷贝</strong></h3>
<p>当类中未定义拷贝构造函数时，c++编译器将添加一个默认的拷贝构造函数，默认拷贝构造函数的功能是把实参对象的数据成员，一一对应，拷贝给新建的数据成员，这时候，两个实例化对象使用的是同一个内存单元，称之为<strong>浅拷贝</strong>，如果两个对象各自使用自己的内存单元，只是将一个对象的信息复制给另一个对象，这种方式称为深拷贝，就需要对新的对象动态分配新的内存单元，再进行赋值初始化。</p>
<p>实列代码：学生信息类Student</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
class Student
{
private:
    char name[10],ID[11];
    int age; double score;
    char *memo;
public:
    void show();
    Student(char *pname, char *pID, int in_age, double in_score,char*pmemo)
    {
        strcpy(name,pname); strcpy(ID,pID);
        age = in_age; score = in_score;
        int len = strlen(pmemo);
        if(len&lt;=0) memo=0;
        else
        {
            memo = new char[len+1];
            strcpy(memo, pmemo);
        }
    };

    Student(Student&amp;obj)//定义拷贝结构函数，使用深度拷贝的方法。
    {
        strcpy(name,obj.name); strcpy(ID,obj.ID);
        age = obj.age; score = obj.score;
        int len = strlen(obj.memo);
        if(len&lt;=0) memo=0;
        else
        {
            memo = new char[len+1];
            strcpy(memo, obj.memo);
        }
    };

      ~Student() //析构函数，用于销毁动态分配的内存
    {
        if(memo!=0) delete []memo;
    };
};

void Student::show()
{
    cout&lt;&lt;"学生姓名："&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;"学生ID："&lt;&lt;ID&lt;&lt;endl;
    cout&lt;&lt;"学生年龄："&lt;&lt;age&lt;&lt;endl;
    cout&lt;&lt;"学生成绩："&lt;&lt;score&lt;&lt;endl;
    cout&lt;&lt;"学生情况："&lt;&lt;memo&lt;&lt;endl;
}

int main()
{
    char name[]="张三";
    char ID[] = "1400500001";
    char memo[] = "成绩优秀";
    Student obj(name,ID,19,95,memo);
    Student obj_n(obj);
    obj_n.show();
    return 0;
}
</code></pre>
<h2>4.3 类和对象编程的主要内容</h2>
<p>面向对象程序设计，主要包含2方面内容，即先定义类，然后用类定义对象，并访问对象及其成员</p>
<p><strong>定义类：</strong>程序员再定义类时要考虑5大要素，即数据成员、函数成员、各个成员的权限、构造函数和析构函数</p>
<p><strong>定义对象：</strong>将类当作一种自定义数据类型来定义变量，所定义的变量就称为对象，计算机执行定义对象语句就是严格按照类所描述的5大要素在内存中创建该类的对象，所创建的对象具有类所规定的数据成员、函数成员及访问权限。</p>
<p><strong>访问对象：</strong>访问对象就是通过接口（即公有成员）操作内存中的对象，实现特定的程序功能，比如读写对象中的公有数据成员，或调用其中的公有函数成员。</p>
<p>c++语言使用类的语法形式来描述类模型，将属性定义成类的数据成员，将方法定义成类的函数函数成员，通过为类成员设定访问权限来实现类的封装，为类添加构造函数可以为该类对象提供初始化方法，添加析构函数可以在销毁对象时做某些特定的善后处理。</p>
<p>任务：编写一个模拟银行存款账户管理的c++程序</p>
<p>要求：能够准确记录存款账户的：户名、账号、存款金额，管理功能应当具备：开户、存款、取款、查询等操作</p>
<p><strong>编写头文件：</strong>声明类代码</p>
<pre><code class="c++">class Account
{
    public:
        int a_num;      //账号
        char a_name[10];//户名
        float money;    //金额
        void deposit(); //存款
        void withdraw();//取款
        void show();    //余额查询
};
</code></pre>
<p><strong>定义方法：</strong></p>
<pre><code class="c++">#include &lt;iostream&gt;
#include "account.h"
using namespace std;
//存款方法
void Account::deposit()
{
    cout&lt;&lt;"请输入存款金额：";
    float x; cin&gt;&gt;x;
    money += x;
    show();
}

//定义取款方法
void Account::withdraw()
{
    cout&lt;&lt;"请输入取款金额：";
    float x; cin&gt;&gt;x;
    if(money&lt;x) cout&lt;&lt;"余额不足";
    else money -= x;
    show();
}

//余额查询
void Account::show()
{
    cout&lt;&lt;"账号"&lt;&lt;a_num&lt;&lt;"的余额为："&lt;&lt;money&lt;&lt;"元\n\n";
}
</code></pre>
<p><strong>定义主函数：</strong></p>
<pre><code class="c++">#include &lt;iostream&gt;
#include "account.h"
#include &lt;string.h&gt;
using namespace std;
int main()
{
    cout&lt;&lt;"请输入开户信息（账号、户名、存款金额）:";
    //定义3个临时变量，用于保存账号、户名、存款金额
    int x; char str[10]; float y;
     cin&gt;&gt;x&gt;&gt;str&gt;&gt;y;
    //创建对象并对数据成员进行赋值操作
    Account obj;
    obj.a_num = x; strcpy(obj.a_name,str); obj.money = y;
    int choice;
    while (true)
    {
        cout&lt;&lt;"1-存款\n2-取款\n3-查询余额\n0-退出\n请选择：";
        cin&gt;&gt;choice;
        if(choice==0) break;
        if(choice==1) obj.deposit();
        else if(choice==2) obj.withdraw();
        else if(choice==3) obj.show();
    }
    return 0;
}
</code></pre>
<p>上述例子中，虽然实现了开发需求所要求的功能，但是任然存在很多漏洞，例如客户信息存放在公有成员中，会非常不安全，主函数在创建对象时，无法初始化。这就需要通过结构函数和析构函数来解决上述问题。</p>
<h1>五、对象的应用</h1>
<h2>5.1 对象数组</h2>
<p>可以定义一个对象数组来保存多个对象。</p>
<p>实例代码：正方形类Square，用于求面积</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Square
{
    public:
        double length;//保存边长
    public:
        double area() //计算面积
        {
             return (length*length);
          };

Square(double x = 0)//带默认形参值得结构函数
  {
      length = x;
    };
};

int main()
{
    /*
    定义正方形类Square的对象obj
    数组obj有3个元素，每个元素是一个正方形对象，边长为2，3，4
    */
    Square obj[3] = {Square(2),Square(3),Square(4)};
        //显示面积
    for(int x=0; x&lt;3;x++)
    {
        cout&lt;&lt;obj[x].area()&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2><strong>1、定义对象数组的语法：</strong></h2>
<p>与定义普通数组的方法基本相同</p>
<pre><code class="c++">//类名 对象命名标识符[表达式];
Square obj[3];//为Square定义一个3个对象的对象数组
Square obj[3]={Square(2),Square(3),Square(4)};//为Square定义一个3个对象的对象数组,并初始化
Square obj[3]={Square(2),Square(3)};//部分初始化
</code></pre>
<p>构造：有多个数组元素，就会调用多少次构造函数。</p>
<h3><strong>2、对象数组的访问：</strong></h3>
<p>可以访问对象中的公有成员。</p>
<p><strong>下标法：</strong></p>
<pre><code class="c++">//对象数组名[].公有成员名
cout&lt;&lt;obj[x].area();//访问area()方法
</code></pre>
<p><strong>指针法：</strong></p>
<pre><code>Square*p = obj[n].a&lt;&lt;endl;
cout&lt;&lt;p-&gt;area()&lt;&lt;endl;
</code></pre>
<p>析构：有多少个数组元素，就会调用多少次析构函数</p>
<h2>5.2 对象的动态分配</h2>
<p>内存的动态分配，必须使用指针才能完成。</p>
<pre><code class="c++">Square *p; //定义对象指针
p = new Square;//使用new运算符动态分配一个对象
... ...
delete p;
</code></pre>
<p>使用new运算符动态分配单个对象的内存单元时，需要指定类型，分配成功后将返回内存单元的首地址，需要预先定义一个同类的对象指针来保存这个首地址，后续访问时，将使用这个指针间接访问，释放内存单元时，也需要使用对象指针，来指定释放那个哪内存单元。动态分配单个对象时，可以进行初始化</p>
<pre><code class="c++">p = new Square(2);
</code></pre>
<p>内存使用完以后也需要及时释放：</p>
<p>动态分配某个类的对象时，会自动调用这个类的构造函数，删除该类时，也会自动调用该类的析构函数，</p>
<p><strong>动态对象数组的分配与释放：</strong></p>
<p>使用new运算符，动态分配对象数组时，可以在程序执行时，更具需要，分配适量的内存，减少内存的不必要占用。内存使用完以后，也因及时释放。例子如下：</p>
<pre><code class="c++">Square *p;
p = new Square[3];
p[0].a = 2;  cout&lt;&lt;p[0].area()&lt;&lt;endl;
(p+1)-&gt; a=3;  cout&lt;&lt;(p+1)-&gt;area()&lt;&lt;endl;
... ...
delete[]p;
</code></pre>
<p>动态分配数组中，有多少个元素，就会调用多少次构造函数，删除数组时，有多少个元素，就会调用多少次析构函数。</p>
<h2>5.3 对象在函数中的应用</h2>
<h3>1、对象作为函数的形参</h3>
<p>定义在函数内部的对象是局部对象，其他函数不能直接访问，对象可以作为参数在函数间传递，调用函数时，主调函数与被调函数之间，需要通过形实结合来传递对象，将保存在主函数里的对象以对象实参的形式，传递给被调函数的对象形参。</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class Square //定义一个正方形类
{
    public:
        double a; //保存边长
        double area() //求正方形面积
        { return (a*a); }
        Square(double x=0) //带默认形参值的构造函数，内联函数
        {a=x;}
};

double inner_circle_area(Square s ) //求正方形内切圆面积，形参是一个正方形对象形参。
{
    double r = s.a/2; //通过形式结合，读取正方形的边长
    return(3.14*r*r);
}

int main(){
    Square obj(10);//定义一个正方形对象：obj，边长为10. 
   cout&lt;&lt;inner_circle_area(obj)&lt;&lt;endl;//调用函数，求出内切圆面积
    return 0;
}
</code></pre>
<p>上述例子中，对象形参：Square s，在调用时，相当于执行了Square(obj)指令，使用对象obj进行初始化，也就是调用了Square类的的默认拷贝函数。</p>
<h2>5.4 函数间的参数传递</h2>
<p>函数间的参数传递，分为值传递、引用传递、指针传递，3种类型，下面分别介绍在函数间传递对象时的值传递、引用传递、和指针传递。</p>
<h3>1、值传递与常对象</h3>
<p>函数间传递对象的值传递与函数间的值传递方法一致。实例可参考5.3节的实例代码。</p>
<p>像常变量一样，可以将任何只读不改的对象，定义为常对象。常对象定义时必须初始化，定义后不能再修改起数据成员。例如5.3求内切圆实例种的对象Square：</p>
<pre><code class="c++">const Square obj(2);
cout&lt;&lt;obj.a&lt;&lt;endl;
obj.a=5;//错误
/*使用常对象形参*/
double inner_circle_area(const Square s ) 
{ ... ... }
</code></pre>
<p>值传递，实际上是重修构造了一个对象形参，这需要花费执行时间和内存空间，相比而言，引用传递和指针传递拥有更高的传递效率。</p>
<h3>2、引用传递与常引用</h3>
<p>引用传递将被调函数的对象形参定义成主调函数中对象实参的引用，被调函数通过该引用间接访问该对象，实例如下：</p>
<pre><code class="c++">double inner_circle_area(Square &amp;s ) //定义时在形参s前加引用说明符
{
 double r = s.a/2;  return(3.14*r*r);
}
//主调函数中实参保持不变
cout&lt;&lt;inner_circle_area(obj)&lt;&lt;endl;
</code></pre>
<p>引用传递一方面可以提高数据传递效率，另一方面也有副作用，例如上述例子中，被调函数中任何对引用形参的数值修改，都会影响到所引用主调函数中的所对应的对象。如果要避免这种因函数间因引用带来的相互影响，可以将对象形参定义为常引用，就是在定义时加上const关键字。</p>
<pre><code class="c++">double inner_circle_area(const Square &amp;s){... ...}
</code></pre>
<p>将被调函数的对象形参定义为常引用后，任何通过该引用修改主调函数的对象实参的做法都是错误的，编译器会提示该错误信息。</p>
<h3>3、指针传递与指向常对象的指针</h3>
<p>指针传递将主调函数中对象实参的内存地址传递给被调函数的对象指针。被调函数通过该对象指针，间接访问主调函数中的对象。</p>
<pre><code class="c++">//被调函数
double inner_circle_area(Square *s)
{
 double r = s-&gt;a/2;  return(3.14*r*r);
}
//主调函数,调用的实参，需要对对象进行取地址操作。
cout&lt;&lt;inner_circle_area(&amp;obj)&lt;&lt;endl;
</code></pre>
<p>和引用传递一样，指针传递可以提高传递效率，另一方面也有副作用，如果要避免因指针传递导致的函数间的相互影响，可以将被调函数的对象指针定义为<strong>指向常变量的对象指针</strong>，定义方式同样是在定义语句前加上const关键字</p>
<pre><code class="c++">//指向常变量的对象指针
double inner_circle_area(const Square *s){... ...}
</code></pre>
<p>和引用传递一样，通过指向常变量的指针去间接修改对象实参的做法都是错误的。编译器会提示错误信息。</p>
<p>综上所述，函数间传递对象，有3种方式，分别是值传递、引用传递和指针传递，如果功能设计上，被调函数不需要修改主调函数传递过来的对象，而只是读取其中的数据，那么程序员可以主动的将被调函数的形参定义为常对象、常引用或指向常对象的指针。如果被调回函数的函数体中存在有修改对象的语句，编译器将会提示错误信息从而帮助程序员迅速排查这方面的错误。</p>
<h1>六、类中的常成员与静态成员</h1>
<p><strong>const数据保护机制</strong>：</p>
<p>常变量、常对象、常引用或指向常对象的指针等，在定义时都使用了const关键字，这是c++语言引用的一种数据保护机制称为const数据保护机制。</p>
<p>例如如果功能上只是使用主调函数传递过来的数据，而不需要修改，那么程序员在编写程序时，可以使用const关键字，主动对被调函数的形参进行限定。限定被调函数不能修改主调函数传递过来的数据，否则编译时，编译器会提示错误信息，这样就可以帮助程序员迅速排查错误。在定义类时，也可以使用const保护机制，保护数据成员不被修改。</p>
<p><strong>stacit静态机制：</strong></p>
<p>c++语言中的static静态机制是与作用域、生存期相关的一个概念。例如静态可以延长局部变量的生存期，可以将全局变量和函数的作用域，限定在本程序文件之内，我们统称为static静态机制。</p>
<p><strong>类中的常成员与静态成员：</strong></p>
<p>在类里，也可以定义为常成员和静态成员。</p>
<ul>
<li>常成员：常数据成员、常函数成员</li>
<li>静态成员：静态数据成员、静态函数成员</li>
</ul>
<p>本章将以一个计算圆形池子造价的实例进行讲解，代码如下：</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class CirclePool
{
    private:
        double price;//单价
        double r;
    public:
        //构造函数，初始化单价price和半径r
        CirclePool(double p1 =0,double p2 = 0)
        {
            price = p1;
            r = p2;
        }
        //对初始化的单价的合法性进行检查
        void CheckPrice(double x)
        {
            if (x&lt;=0)
            {
               price=0;
               cout&lt;&lt;"数据输出错误"&lt;&lt;endl;
            }
            else price =x;
        }
        //获取检查后的单价
        double GetPrice()
        { return price; }
        //对半径进行检查
        void CheckRadius(double x)
        {
            if (x&lt;=0)
            {
                r = 0;
                cout&lt;&lt;"数据输出错误"&lt;&lt;endl;
            }
            else r =x;
        }
        //读取检查后的半径
        double GetRadius()
        { return r; }
        //计算圆形水池的造价
        double GetCost()
        { return(3.14*r*r*price);
         }
 };

 int main()
 {
    double totalcost = 0;//保存造价计算结果
    double r1,r2;
    cin&gt;&gt;r1&gt;&gt;r2;
    CirclePool pool1,pool2;//定义2个对象
    pool1.CheckPrice(10);
    pool1.CheckRadius(r1);
    totalcost += pool1.GetCost();
    pool2.CheckPrice(10);
    pool2.CheckRadius(r1);
    totalcost += pool2.GetCost();
    cout&lt;&lt;totalcost&lt;&lt;endl;
    return 0;
 }
</code></pre>
<p>定义时，使用const关键字限定的称为常成员，数据成员和函数成员均可以定义成常成员，定义常成员的目的是保护数据成员不被修改。</p>
<h2><strong>6.1 常数据成员</strong></h2>
<p>如果一个数据成员保存的是一个常量值，初始化后不会改变，那么可以将该数据成员其定义成常数据成员，换句话说，如果定义成常数据成员，那么该成员只能在初始化时赋值，初始化后不能再次赋值，长数据成员的含义与常变量大致相同，所不同的是，在类中声明常数据成员时，不能直接初始化，类中的任何成员都不能声明时直接赋初始值，只能通过构造函数来进行初始化。</p>
<p>上述代码中，price保存的是一个常量，初始化后，就不会改变，故代码可以定义为如下的方式：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

class CirclePool
{
    private:
        const double price;//单价
        double r;
    public:
        /*构造函数，初始化单价price和半径r,
        在构造函数中，不能直接对常数据对象初始化,必须使用初始化列表的形式 */
        CirclePool(double p1 =0,double p2 = 0):price(p1)
        {
            r = p2;
        }
        double GetPrice()
        { return price; }
        //对半径进行检查
        void CheckRadius(double x)
        {
            if (x&lt;=0)
            {
                r = 0;
                cout&lt;&lt;"数据输出错误"&lt;&lt;endl;
            }
            else r =x;
        }
        //读取检查后的半径
        double GetRadius()
        { return r; }
        //计算圆形水池的造价
        double GetCost()
        { return(3.14*r*r*price); }
};

int main()
{
    double totalcost = 0;
    double r1,r2;
    cin&gt;&gt;r1&gt;&gt;r2;
    CirclePool pool1(10,r1),pool2(10,r2);

    pool1.CheckRadius(r1);
    totalcost += pool1.GetCost();
    pool2.CheckRadius(r1);
    totalcost += pool2.GetCost();

    cout&lt;&lt;totalcost&lt;&lt;endl;
    return 0;
 }
</code></pre>
<p><strong>常数据成员的语法细则：</strong></p>
<ul>
<li>关键字<strong>const</strong>：在类定义中声明常数据成员需要使用关键字const进行限定，声明时不能初始化。</li>
<li><strong>初始化列表：</strong>类中的任何函数都不能对常数据成员赋值，包括构造函数。为构造函数添加初始化列表是对常数据成员进行初始化的唯一途经。在构造函数的函数头后面添加初始化列表。</li>
</ul>
<pre><code class="c++">  构造函数名(形参列表):常数据成员名1(形参1),常数据成员名1(形参1),... ...
  {
      ...;//其他数据成员在此初始化
  }
  // 形参1、形参2是从形参列表中提取出来的，并在初始化列表中进行二次接力传递。
</code></pre>
<ul>
<li>
<strong>定义对象时初始化：</strong>定义含常数据成员类的对象时需要初始化，给出常数据成员的初始值</li>
</ul>
<h2>6.2 常函数成员</h2>
<p>如果某个函数成员只需要读取类中其他数据成员的值，不需要修改，那么可以将该函数定义成常函数成员。换句话说，如果将某个函数成员定义成常函数成员，那么该成员只能读取这个类中的数据成员，不能赋值修改。</p>
<p>在例子中一个函数成员GetCost他是读取数据成员的半径，计算圆形面积和造价，这个成员满足常函数成员的条件，可以将其定义成常函数成员。定义常函数成员有2种语法形式。</p>
<p><strong>内联函数：</strong></p>
<p>就是在类声明大括号中定义的函数</p>
<pre><code class="c++">double GetCost() const { return(3.14*r*r);}
</code></pre>
<p>定义时在函数名小括号后面添加const关键字</p>
<p><strong>非内联函数：</strong></p>
<p>需要在类声明部分，在函数名小括号后添加关键字const，在类实现部分，同样需要在需要在函数名小括号后面添加关键字const。</p>
<pre><code class="c++">//类声明部分
double GetCost() const;

//类实现部分
double CirclePool::GetCost() const{ return(3.14*r*r); }
</code></pre>
<p><strong>常函数成员的语法细则：</strong></p>
<ul>
<li>声明、定义常函数成员需要在函数头后面加关键字const进行限定</li>
<li>常函数成员只能读类中的数据成员，不能赋值修改</li>
<li>常函数成员只能调用其他常函数成员。换句话说，常函数成员不能调用其他无const限定的函数成员，以防这些函数间接修改了数据成员。</li>
<li>通过常对象， 只能调用其他函数成员。换句话说，通过常对象不能调用无const限定的函数成员，以防这些函数间接修改了常对象的数据成员。常对象就是数据成员不能修改的对象。</li>
<li>除形参个数、类型之外，还可以用const区分类中的重载函数。</li>
</ul>
<h2>6.3 静态数据成员</h2>
<p>定义类时，用static关键字进行限定的成员称为静态成员，数据成员和函数成员都可以定义成静态成员。c++语言中的static静态机制是与作用域、生存期相关的一个概念。例如静态可以延长局部变量的生存期，可以将全局变量和函数的作用域，限定在本程序文件之内。</p>
<p>全局变量，同样可以延申作用域和生存期，但是面向对象程序设计，建议将全局变量作为一种特殊成员，归属到某个类中进行同一管理，这种特殊成员就是静态数据成员。</p>
<p>使用静态成员修改CirclePool类：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class CirclePool
{
    private:
        static double price;//静态数据成员，使用static声明
        double r;
    public:
        /*构造函数，半径r,
        在构造函数中，不能直接对静态数据成员初始化,必须在类实现部分进行实现 */
        CirclePool(double p = 0)//构造函数初始化半径r
        {
            r = p;
        }
        double GetPrice()
        { return price; }
        //对半径进行检查
        void CheckRadius(double x)
        {
            if (x&lt;=0)
            {
                r = 0;
                cout&lt;&lt;"数据输出错误"&lt;&lt;endl;
            }
            else r =x;
        }
        //读取检查后的半径
        double GetRadius()
        { return r; }
        //计算圆形水池的造价
        double GetCost()
        { return(3.14*r*r*price);
 }
};

double CirclePool::price = 10;//在类实现部分进行静态成员的初始化，定义时前面类名进行指定是哪个类的静态数据成员

int main()
{
    double totalcost = 0;
    double r1,r2;
    cin&gt;&gt;r1&gt;&gt;r2;
    CirclePool pool1(r1),pool2(r2);
    pool1.CheckRadius(r1);
    totalcost += pool1.GetCost();
    pool2.CheckRadius(r1);
    totalcost += pool2.GetCost();
    cout&lt;&lt;totalcost&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><strong>静态数据成员的语法细则：</strong></p>
<ul>
<li>关键字<strong>static</strong>：在类定义中声明静态数据成员需要使用关键字static进行限定，声明时不能初始化。</li>
<li>定义及初始化：必须在类声明的大括号外面（通常时和函数成员定义在一起，放在类实现部分）对静态成员进行定义，定义时不能再加关键字static，定义时可以初始化。</li>
<li>在同类函数成员中访问：在同类的函数成员中访问静态数据成员直接使用其成员名访问，访问时不受权限约束。</li>
<li>在类外其他函数中访问：在类外其他函数（例如主函数）中访问静态数据成员需以“类名::静态数据成员名”的形式访问，或通过任何一个该类对象以“对象名.静态数据成员名”的形式访问，类外访问受权限约束，只能访问公有静态数据成员。</li>
<li>生存期及作用域：和全局变量一样，静态数据成员是静态分配的，程序加载后立即分配内存，知道程序执行结束退出时才被释放。访问权限决定静态数据成员的作用域，私有静态数据成员具有类作用域，只能在类内访问。公用静态数据成员具有文件作用域，可以被文本中任何函数访问，并且可通过类声明将其作用域扩展到任何程序文件。</li>
</ul>
<h2>6.4 静态函数成员</h2>
<p>如果某个函数成员只需要访问类中的静态数据成员，那么可以将该函数定义成静态函数成员，换句话说，如果将某个函数成员定义成静态函数成员，那么该函数只能访问类中的静态数据成员，或调用类中其他静态函数成员。</p>
<p>例子：修改圆形水池类CirclePool中的GetPrice方法。</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;
class CirclePool
{
    private:
        static double price;//静态数据成员，使用static声明
        double r;
    public:
        /*构造函数，半径r,
        在构造函数中，不能直接对静态数据成员初始化,必须在类实现部分进行实现 */
        CirclePool(double p = 0)//构造函数初始化半径r
        {
            r = p;
        }
        static double GetPrice();//类声明部分只能声明，不能写函数体。函数体只能写在类实现部分
... ...;//其他代码省略
};

double CirclePool::price = 10;//在类实现部分进行静态成员的初始化，定义时前面类名进行指定是哪个类的静态数据成员//类实现部分，不需再加static，对该静态函数的方法进行实现。
double CirclePool::GetPrice(){ return price;}//price必须是静态数据成员。
   ... ...;//主函数代码省略
</code></pre>
<p><strong>静态函数成员的语法细则：</strong></p>
<ul>
<li>声明时使用static关键字进行限定，定义时（类实现）不能再使用关键字static。</li>
<li>静态函数成员只能访问类中的静态数据成员，因为静态函数成员可以不定义对象直接调用，而非静态数据成员只有在定义对象后才分配内存空间，才能访问，同样的道理，静态函数成员不能调用其他非静态函数成员。</li>
<li>类中的其他函数成员调用静态函数成员直接使用其他函数名调用，调用时不受权限约束。</li>
<li>在类外调用静态函数成员需以“类名::静态函数成员名()”的形式调用，或通过任何一个该类对象以“对象名.静态数据成员名()”的形式调用，类外调用受权限约束，只能调用公有静态函数成员。</li>
<li>静态函数成员不能是内联函数，因编译器在编译时会调整内联函数，此时所访问的静态数据成员可能还未初始化，因此数据是不可靠的，此时访问会导致程序运行结果出现错误。</li>
</ul>
<h2>6.5 总结</h2>
<p>面向对象程序设计，希望用类管理所有的程序代码，程序中没有游离在类外的全局变量或外部函数，对于一些通用的全局变量和函数，可以将其定义成静态成员，从形式上归为一类进行同一管理。例如我们可以定义一个数学类Math，来管理这些数据和方法。</p>
<pre><code class="c++">//类声明与类实现部分
class Math
{
    public:
        static double pie;
        static double sin(double x);
        static double cos(double x);
    ... ...
};

double Math::pie = 3.1415926;
double Math::sin(double x){ ... ... };
double Math::cos(double x){ ... ... };
... ...
//访问
cout&lt;&lt;Math::pie&lt;&lt;endl;cout&lt;&lt;Math::cos(2)&lt;&lt;endl;
</code></pre>
<h1>七、类的友元</h1>
<p>友元是一个与访问权限相关的概念，编写类的程序员，定义类的时候，为类成员赋予不同的访问权限，将必须被外部访问的成员开放出来，以保证类的功能能够正常使用，将不需要被外部访问的成员隐藏起来以防止他们被误访问，被隐藏的成员，只能在内部使用，即能被类里的其他成员访问， 但不能在类的外部访问；使用类的程序员在编写程序代码时，用类定义对象，定义好的对象可以访问，访问对象就是通过其接口，即公有成员来操作内存中的对象，实现特定的程序功能，比如读写其中的公有成员或调用其中的公有函数成员。</p>
<p>假设有一个类A，如下所示：</p>
<pre><code class="c++">class A
{
    public:
        int x;//公有成员
    protected:
        int y;//保护成员
    private:
        int z;//私有成员
        //构造函数
        A(int p1=0,int p2=0,int p3=0)
        { x = p1; y = p2; z = p3;
 }
};

void fun()
{
    A obj(1,2,3);
    cout&lt;&lt;obj.x&lt;&lt;endl;//正确，公有成员可以访问
    cout&lt;&lt;obj.y&lt;&lt;endl;//错误，保护成员不能被外部函数访问
    cout&lt;&lt;obj.z&lt;&lt;endl;//错误，私有成员不能被外部函数访问
}
</code></pre>
<p>类中设定的访问权限对类外的函数一视同仁，具有相同的约束力，公有成员对大家都开放，都能访问，而私有成员和保护成员是隐藏的，对大家都不开放，不能访问。</p>
<p>内否向类某些函数定向开放某些成员，实现更加精细化的类成员访问控制呢？例如程序员在定义类的时候，可以授权某些函数可以访问类中的私有成员，c++语言可以在定义类的时候声明<strong>友元</strong>，向类外的某些函数或类定向的开放类中的所有成员，被类声明成友元的函数，称为该类的友元函数，被声明成友元的类，被称为友元类。</p>
<h2>7.1 友元函数</h2>
<p><strong>友元声明语法细则：</strong></p>
<pre><code class="c++">class 类名
{
    ...
    friend 友元函数的原型声明;
};
</code></pre>
<ul>
<li>在类声明部分声明友元函数的原型，声明时用“friend”关键字，声明语句可以放在大括号内的任意位置，该位置的访问权限与友元函数无关</li>
<li>友元函数时类外的其他函数，不是类成员</li>
<li>友元函数可以在其函数体内访问该类对象的所有成员，不受权限约束</li>
</ul>
<pre><code class="c++">class A
{
    public:
        int x;//公有成员
    protected:
        int y;//保护成员
    private:
        int z;//私有成员
        //构造函数
        A(int p1=0,int p2=0,int p3=0)
        { x = p1; y = p2; z = p3; }
    friend void fun(); //声明友元函数fun()，可以在类中任意位置
};

void fun()
{
    A obj(1,2,3);
    cout&lt;&lt;obj.x&lt;&lt;endl;//正确，公有成员可以访问
    cout&lt;&lt;obj.y&lt;&lt;endl;//正确，保护成员能被友元函数访问
    cout&lt;&lt;obj.z&lt;&lt;endl;//错误，私有成员能被友元函数访问
}
</code></pre>
<h2>7.2 友元类</h2>
<p>类A的友元函数，可以是另一个类B的函数成员，假设本节例子中类A的友元函数是类B的函数成员，类B的声明如下：</p>
<pre><code class="c++">class B
{
    ... ...
    void fun1(){... ...}
    void fun2(){... ...}
};
</code></pre>
<p>则在类A中声明友元函数fun1时，需要在函数名前加上类名限定：</p>
<pre><code class="c++">class A
{
    ... ...
    friend void B::fun1();//声明类B的函数成员fun1为类A的友元函数
};
</code></pre>
<p>如果类B的函数成员都是类A的友元函数，则称类B为类A的友元类。声明友元类时，不需要逐个声明其所有的函数成员，而是采用同一声明的语法形式：</p>
<pre><code class="c++">class A
{
    ... ...
    friend class B;//声明类B为类A的友元类
};
</code></pre>
<p><strong>友元类的注意事项：</strong></p>
<ol>
<li><strong>友元关系是单向的</strong>：若类A声明类B是自己的友元，并不意味着自己同时称为对方的友元，除非对方声明自己是它的友元</li>
<li><strong>友元关系不能传递</strong>：假设类B是类A的友元，类C是类B的友元，这并不意味着类A和类C之间存在任何友元关系，除非它们自己单独声明</li>
</ol>
﻿
</div>

<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="../index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 1001){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
    function myfun() 　　{ 　
        if(thispage3 == "index"){　 
         fpage = "1.html";
        document.getElementById("LPagea").href=fpage;           
            var obj5=document.getElementById("fPagea");
            obj5.style.display="none";
        }            　
    } 　　
    window.onload = myfun;
</script>

</div>
</body>
</html>
