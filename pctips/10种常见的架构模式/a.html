<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>

<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:75.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	margin-left:2em;
	color:blue;
	padding:8px;
	}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrowser {
	width:100%;
	margin:auto;
	border-collapse:collapse;
font-family:"宋体";
	text-align:left;
	line-height:1.3em;
	table-layout:fixed;
}

#tbrowser th,#tbrowser td{
border:1px solid #ddd;
font-size:1em;
color:#000000;
text-align:left;
font-family: "宋体";
vertical-align:top;
padding-left:3px;
height:28px;
//white-space:nowrap;
//overflow:hidden; 
//text-overflow:ellipsis; 
}


#tbrowser thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
#tbrowser .nd{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
background-color:#D3D3A9;
color:red;
}

#tbrowser th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
padding-left:2px;
}
#tbrowser th.title{
background-color:#e3e685;
}

#tbrowser caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
}


#tbrowser .xhx{
border-bottom:0px solid #aaa;
}


#tbrowser tr{
height:6px;
}

#tbrowser tr>td{/*1*/
font-size:1em;
text-align:left;
/*width:13%;*/
}
#tbrowser tr>td+td{/*2*/
text-align:left;
/*width:8%;*/
font-size:1em;
}
#tbrowser tr>td+td+td{/*3*/
font-size:1em;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td{/*4*/
font-size:1em;
text-align:left;
/*width:6%;*/
}
#tbrowser tr>td+td+td+td+td{/*5*/
font-size:1em;
text-align:left;
/*width:5%;*/
}
#tbrowser tr>td+td+td+td+td+td{/*6*/
/*width:13%;*/
font-size:1em;
}
#tbrowser tr>td+td+td+td+td+td+td{/*7*/
/*width:59%;*/
font-size:1em;
}


#tbrowser tfoot td{
border-width:0px;
text-align:left;
line-height:18px;
font-size:16px;
color:#777;
}

#tbrowser th a:link {
	text-decoration: none;
	color:white;
}
#tbrowser th a:hover {
	text-decoration: none;
	color:white;
}
#tbrowser th a:active {
	text-decoration: none;
	color:white;
}
#tbrowser th a:visited {
	text-decoration: none;
	color:white;
}
#tbrowser caption{
font-size:1.2em;
text-align:left;
}
#tbrowser thead td{
font-size:0.8em;
text-align:left;
}
pre{
    margin-left:2em;
	}
a:visited, a:link{
    color:blue;
}
a:visited{
    color:#CC0000;
}a:hover{
    color:green;
	}
pre{
	font-size:120%;
	line-height:130%;
	padding:5px;
	margin-left:2em;
	background-color:RGB(240,240,240);
    color:blue;
	margin-left:2em;
	}
</style>
</head>

<body>

<div id="container">
    <p align="left"><strong>10种常见的架构模式 </strong></p>

<p><a href="https://www.toutiao.com/article/7109675271879672335/?log_from=c409c01f0e30d_1655419897223">ref</a></p>

<p>想知道如何设计大型企业级的系统吗？在开始主要的代码开发之前，我们必须选择一种合适的体系架构，它将为我们提供所需的功能和质量属性。因此，在将它们应用到我们的设计之前，应该先了解不同的体系结构。</p>

<p><img border="0" width="100%" height="503" src="a_clip_image002.jpg" /></p>

<p><strong>- 什么是架构模式 -</strong></p>

<p>根据维基百科，架构模式是在给定上下文中解决软件架构中常见问题的通用、可重用的解决方案。架构模式类似于软件设计模式，但范围更广。</p>

<p>在本文中，我会简单介绍下列10种常见的架构模式，及其用途、优势和劣势。</p>


<p><strong><h3>- 1 分层模式 -</h3></strong></p>

<p>该模式可用于构建可分解为子任务组的程序，其中每个都处于特定的抽象级别。每一次都向更高层提供服务。一般信息系统中最常见的4层划分如下： </p>
<p></p>

<pre>
Presentation layer   表示层    （也就是UI层）
Application layer    应用层    （也就是服务层）
Business logic layer 业务逻辑层（也就是领域层）
Data access layer    数据访问层（也就是数据持久层）
</pre>

    <p align="left">应用 </p>
    <ul>
        <li>一般桌面应用程序 </li>
        <li>电子商务Web应用程序 </li>
    </ul>
<img border="0" height="20%" src="a_clip_image005.jpg" />

<p><strong><h3>- 2 客户端-服务器模式 -</h3></strong></p>

<p>该模式由两部分组成：一个服务端和多个客户端，服务器向多个客户端提供服务。客户端向服务器发起请求，服务器向这些客户端提供相关服务，之后，服务器继续侦听客户端的请求。 </p>
    <p align="left"><strong>应用 </strong></p>
    <ul>
        <li>在线应用程序，如电子邮件、文件共享和银行业务等 </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image006.jpg" /></p>

<p><strong><h3>- 3 主从模式 -</h3></strong></p>

<p>该模式也分为两块：主模块和从模块。主模块在相同的从模块之间分配工作，并根据从模块返回的结构来计算最终的结果。</p>

<p>应用 </p>
    <ul>
        <li>在数据库复制中，主数据库被视作权威数据源，而从数据库与其保持同步 </li>
        <li>连接到计算机系统总线上的外围设备（主驱动器和从驱动器） </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image007.jpg" /></p>

<p><strong><h3>- 4 管道过滤模式 -</h3></strong></p>

<p>此模式可用于构建产生和处理数据流的系统。每个处理步骤都包含在一个过滤器组件中，要处理的数据通过管道传递。这些管道可用于缓冲或者同步。 </p>
    <p align="left"><strong>应用 </strong></p>
    <ul>
        <li>编译器。依次使用不同的过滤器执行词法分析、解析、语法分析和代码生成 </li>
        <li>生物信息学中的工作流程 </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image009.jpg" /></p>

<p><strong><h3>- 5 Broker模式 -</h3></strong></p>

<p>此模式是使用解耦的组件构建分布式系统，这些组件可以通过远程服务调用实现交互。代理组件负责协调组件之间的通信。服务器将它们的功能（服务和特征等）发布到代理，客户端向代理请求服务，然后代理根据其注册表将客户端请求转发给合适的服务。 </p>
    <p align="left"><strong>应用 </strong></p>
    <ul>
        <li>消息代理软件，如  Apache ActiveMQ, Apache Kafka, RabbitMQ 和 JBoss  Messaging. </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image011.jpg" /></p>

<p><strong><h3>- 6 P2P模式 -</h3></strong></p>

<p>在此模式中，每个独立的组件被称为对等点（或对等端，peer）。对等端既可以充当客户端（向其它对等端请求服务），又可以充当服务器（向其它对等方提供服务）。同一个对等端可能既是客户端，又是服务器，并且可以动态改变其角色。 </p>
    <p align="left"><strong>应用 </strong></p>
    <ul>
        <li>文件共享网络，如Gnutella  和 G2 </li>
        <li>多媒体协议，如P2PTV  和 PDTP </li>
        <li>基于加密货币的产品，如比特币和区块链 </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image012.jpg" /></p>

<p><strong><h3>- 7 事物总线模式 -</h3></strong></p>

<p>该模式主要处理组件，有4个重要的组件：事件源、事件侦听器、通道和事件总线。事件源将消息发送到事件总线上的特定通道，侦听器会订阅特定的频道。当消息发送到频道中后，订阅该频道的侦听器会收到该消息的通知。 </p>
    <p align="left"><strong>应用 </strong></p>
    <ul>
        <li>安卓开发 </li>
        <li>通知服务 </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image014.jpg" /></p>

<p><strong><h3>- 8 MVC模式 -</h3></strong></p>

<p>该模式将交互式应用分为三个部分， </p>
    <ul>
        <li>模型——包含核心功能和数据 </li>
        <li>视图——向用户显示信息（可以定义多个视图） </li>
        <li>控制器——处理用户的输入 </li>
    </ul>
    <p align="left">这样做是为了将数据的内部表示与用户输入和向用户展示的形式分离开来，这样可以解耦组件，同时也可以进行高效的代码重用。 </p>
    <p align="left"><strong>应用 </strong></p>
    <ul>
        <li>主流编程语言的互联网应用架构 </li>
        <li>网络框架，如<strong>Django&nbsp;</strong>和&nbsp;<strong>Rails</strong>. </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image016.jpg" /></p>
    <p align="left"><img border="0" src="mvc.jpg" /></p>

<p><strong><h3>- 9 黑板模式 -</h3></strong></p>

<p>此模式对于尚无确定性解决方案的问题很有用，黑板模式由三部分组成： </p>
    <ul>
        <li>黑板—— 一个结构化的全局内存，包含解决方案领域的对象 </li>
        <li>知识源——具有自身含义的专业模块 </li>
        <li>控制组件——选择、配置和执行模块 </li>
    </ul>
    <p align="left">所有组件都可以访问黑板，组件可能会产生要添加到黑板中的新数据对象，组件在黑板上寻找特定类型的数据，并且可以通过与现有知识源进行模式匹配来找到这些数据。 </p>
    <p align="left"><strong>应用 </strong></p>
    <ul>
        <li>语音识别 </li>
        <li>车辆识别与跟踪 </li>
        <li>蛋白质结构鉴定 </li>
        <li>声呐信号解释 </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image018.jpg" /></p>

<p><strong><h3>- 10 解释器模式 -</h3></strong></p>

<p>此模式通常用于设计组件来解释使用专用语言写出的程序，它主要指定如何估算程序行，即以特定语言编写的语句或表达式。基本思想是为每种语言符号都设计一个类。</p>

<p><strong>应用 </strong></p>
    <ul>
        <li>数据库查询语言，如SQL </li>
        <li>用于描述通信协议的语言 </li>
    </ul>
    <p align="left"><img border="0" src="a_clip_image020.jpg" /></p>

<p><strong><h3>- 架构模式对比 -</h3></strong> </p>
<table id="tbrowser">
<col width="20%" />
<col width="40%" />
<col width="40%" />
        <tr>
            <th>模式 </th>
            <th>优点</th>
            <th>缺点</th>
        </tr>
        <tr>
            <td>分层模式</td>
            <td>一个底层服务可以被不同的高层服务使用；分层结果更容易进行标准化，因为可以清晰地定义每个层级层级内的修改不会影响其它层</td>
            <td>不是普适性的架构；某些场景下，需要跳过其中一些分层</td>
        </tr>
        <tr>
            <td>CS模式</td>
            <td>容易对系列服务进行建模，供客户端请求</td>
            <td>请求通常是在服务器的不同线程中进行响应的；因为不同客户端有不同形式，进程间通信会造成很大负载</td>
        </tr>
        <tr>
            <td>主从模式</td>
            <td>准确性——服务的执行委托给了不同的从模块</td>
            <td>从模块是独立的：没有共享状态；主从模块间的通信延迟可能是一个问题，尤其在实时系统中。</td>
        </tr>
        <tr>
            <td>管道过滤器模式</td>
            <td>支持并发处理，其中输入、输出由数据流组成时，过滤器在接收到数据时即开始计算；容易添加过滤器，系统很容易扩展；过滤器可重用，可以通过重新组合已有的过滤器来创建不同的管道流。</td>
            <td>整体效率受最慢的过滤程序限制；从一个过滤器传递到另一个时，存在数据转换的负载</td>
        </tr>
        <tr>
            <td>代理模式</td>
            <td>允许对象进行动态的修改、增、删、重定位，对开发者来说内容分发是透明的</td>
            <td>需要对服务描述进行标准化</td>
        </tr>
        <tr>
            <td>P2P模式</td>
            <td>支持去中心化运算；对任意节点的失败都有高度稳定性；在资源和计算能力方面具有高度可伸缩性</td>
            <td>无法保证服务质量，因为节点之间是自愿合作的；很难保证安全；性能取决于节点的数量</td>
        </tr>
        <tr>
            <td>事件总线模式</td>
            <td>很容易向系统好加入新的发布者、订阅者和连接；对于高度分布式应用很有效</td>
            <td>伸缩性可能是个难题，因为所有的信息传输都要通过相同的时间总线</td>
        </tr>
        <tr>
            <td>MVC模式</td>
            <td>对同一模型很容易构建多个视图，在运行时可以任意连接或断开</td>
            <td>增加了复杂性，用户操作可能导致很多不必要的更新</td>
        </tr>
        <tr>
            <td>黑板模式</td>
            <td>容易添加新应用；很容易扩展数据空间中的结构</td>
            <td>修改数据空间的结构很难，因为所有的应用都会被影响；可能需要同步机制和访问控制</td>
        </tr>
        <tr>
            <td>解释器模式</td>
            <td>可能支持高度动态化行为；有利于终端用户的可编程性；增强了灵活性，因为替换一个解释程序很容易</td>
            <td>因为解释型语言通常比编译型语言要慢，因此性能可能是一个问题</td>
        </tr>
    </table>
	
	
<p><h3>1 驱动架构</h3></p>


<p>        驱动架构的思想是将应用逻辑解耦为单一用途的事件处理组件，以异步方式接收和处理事件。这是一种较为收欢迎的分布式异步架构模型，以高扩展性和适应性出名。</p>



<img src="1.jpg" />


<p><h3>2 微内核架构（插件架构）</h3></p>


<p>        微内核架构中的设计模式包含两大部分：核心系统和插件模块。</p>


<p>        最典型的例子如WEB浏览器，它相当于核心系统，可以让你无限地安装扩展程序。</p>

<img src="2.jpg" />




<p><h3>3 微服务架构</h3></p>


<p>        微服务架构由单独部署的服务组成，每个服务最好豆油一个单一的责任。这些服务彼此之间相互独立也相互依赖，当其中一个服务出现故障时，其他服务不会因此中断。</p>


<img src="3.jpg" />



<p><h3>4 基于空间的架构（云架构）</h3></p>


<p>        云架构的主要思想是分布式共享内存，以缓解经常发生在数据库层面的问题。</p>


<p>        通过使用内存数据处理大部分操作，这样就可以避免在数据库中进行额外的操作，从而避免未来可能由此产生的任何问题，例如：如果你的用户活动数据实体发生了变化，你不需要改变一堆代码来持久化和从数据库中检索这些数据。</p>


<p>        基本的方法是将应用程序分离成处理单元，可以根据需求自动扩大和缩小，数据将在这些单元之间进行复制和处理，无需持久化到中央数据库。</p>
	<img src="4.jpg" />
	
<p><a href="https://baijiahao.baidu.com/s?id=1718412446117134434&wfr=spider&for=pc" title="">ref1</a></p>


</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>

<!--
_____________________________________________________________________________________

1 段落替换
\s*</p>

<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________
2 汉字中间的空格替换：
([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])
([^\s\*^{}"^u4e00-u9fa5])\s+([^\s\*^{}"^u4e00-u9fa5])


------------------
$1$2
_____________________________________________________________________________________
3 段落前的空格替换
\s*</p>\s*
\s*<p>\s*
------------------
</p>

<p>
_____________________________________________________________________________________

4 把第和章两个字去掉
第(\S*)章
------------------
$1
_____________________________________________________________________________________

7 正则表达式参考：
https://www.toutiao.com/i6370960744082571778/
_____________________________________________________________________________________

8
<p class="picsay">
<p class="picsay">
<p class="code0">
<p class="code2">
<p class="code4">
_____________________________________________________________________________________
9 将标注序号更改为上标，红色，需一个个替换，英文html中有[1]
(\[\d\])
------------------
<sup>$1</sup>
_____________________________________________________________________________________
10 替换章不是以1-9。?！…”“结尾的段落
([^1-90。?！…”：？“章])</p>
<p>
------------------
$1
-->


